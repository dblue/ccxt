# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Lykke < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'lykke',
        'name' => 'Lykke',
        'countries' => ['CH'],
        'version' => 'v1',
        'rateLimit' => 200,
        'has' => {
          'CORS' => false,
          'fetchOHLCV' => false,
          'fetchTrades' => false,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchOrder' => true,
          'fetchOrders' => true
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/34487620-3139a7b0-efe6-11e7-90f5-e520cef74451.jpg',
          'api' => {
            'mobile' => 'https://public-api.lykke.com/api',
            'public' => 'https://hft-api.lykke.com/api',
            'private' => 'https://hft-api.lykke.com/api',
            'test' => {
              'mobile' => 'https://public-api.lykke.com/api',
              'public' => 'https://hft-service-dev.lykkex.net/api',
              'private' => 'https://hft-service-dev.lykkex.net/api'
            }
          },
          'www' => 'https://www.lykke.com',
          'doc' => [
            'https://hft-api.lykke.com/swagger/ui/',
            'https://www.lykke.com/lykke_api'
          ],
          'fees' => 'https://www.lykke.com/trading-conditions'
        },
        'api' => {
          'mobile' => {
            'get' => [
              'Market/{market}'
            ]
          },
          'public' => {
            'get' => [
              'AssetPairs',
              'AssetPairs/{id}',
              'IsAlive',
              'OrderBooks',
              'OrderBooks/{AssetPairId}'
            ]
          },
          'private' => {
            'get' => [
              'Orders',
              'Orders/{id}',
              'Wallets'
            ],
            'post' => [
              'Orders/limit',
              'Orders/market',
              'Orders/{id}/Cancel'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.0, # as of 7 Feb 2018, see https://github.com/ccxt/ccxt/issues/1863
            'taker' => 0.0, # https://www.lykke.com/cp/wallet-fees-and-limits
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {
              'BTC' => 0.001
            },
            'deposit' => {
              'BTC' => 0
            }
          }
        }
      })
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privateGetWallets
      result = { 'info' => balances }
      for i in (0...balances.length)
        balance = balances[i]
        currency = balance['AssetId']
        total = balance['Balance']
        used = balance['Reserved']
        free = total - used
        result[currency] = {
          'free' => free,
          'used' => used,
          'total' => total
        }
      end
      return self.parse_balance(result)
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostOrdersIdCancel({ 'id' => id })
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      query = {
        'AssetPairId' => market['id'],
        'OrderAction' => self.capitalize(side),
        'Volume' => amount
      }
      if type == 'market'
        query['Asset'] = (side == 'buy') ? market['base'] : market['quote']
      elsif type == 'limit'
        query['Price'] = price
      end
      method = 'privatePostOrders' + self.capitalize(type)
      result = self.send_wrapper(method, self.shallow_extend(query, params))
      return {
        'id' => nil,
        'info' => result
      }
    end

    def fetch_markets(params = {})
      markets = self.publicGetAssetPairs
      #
      #     [{                Id => "AEBTC",
      #                      Name => "AE/BTC",
      #                  Accuracy =>  6,
      #          InvertedAccuracy =>  8,
      #               BaseAssetId => "6f75280b-a005-4016-a3d8-03dc644e8912",
      #            QuotingAssetId => "BTC",
      #                 MinVolume =>  0.4,
      #         MinInvertedVolume =>  0.0001                                 },
      #       {                Id => "AEETH",
      #                      Name => "AE/ETH",
      #                  Accuracy =>  6,
      #          InvertedAccuracy =>  8,
      #               BaseAssetId => "6f75280b-a005-4016-a3d8-03dc644e8912",
      #            QuotingAssetId => "ETH",
      #                 MinVolume =>  0.4,
      #         MinInvertedVolume =>  0.001                                  }]
      #
      result = []
      for i in (0...markets.length)
        market = markets[i]
        id = market['Id']
        name = market['Name']
        baseId, quoteId = name.split('/')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => market['Accuracy'],
          'price' => market['InvertedAccuracy']
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'active' => true,
          'info' => market,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => 10**precision['amount']
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => 10**precision['price']
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      close = parse_float(ticker['lastPrice'])
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => parse_float(ticker['bid']),
        'bidVolume' => nil,
        'ask' => parse_float(ticker['ask']),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => close,
        'last' => close,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => nil,
        'quoteVolume' => parse_float(ticker['volume24H']),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.mobileGetMarketMarket(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_order_status(status)
      statuses = {
        'Pending' => 'open',
        'InOrderBook' => 'open',
        'Processing' => 'open',
        'Matched' => 'closed',
        'Cancelled' => 'canceled'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      status = self.parse_order_status(self.safe_string(order, 'Status'))
      symbol = nil
      if market.nil?
        marketId = self.safe_string(order, 'AssetPairId')
        market = self.safe_value(self.markets_by_id, marketId)
      end
      if market
        symbol = market['symbol']
      end
      lastTradeTimestamp = self.parse8601(self.safe_string(order, 'LastMatchTime'))
      timestamp = nil
      if order.include?(('Registered')) && (order['Registered'])
        timestamp = self.parse8601(order['Registered'])
      elsif order.include?(('CreatedAt')) && (order['CreatedAt'])
        timestamp = self.parse8601(order['CreatedAt'])
      end
      price = self.safe_float(order, 'Price')
      amount = self.safe_float(order, 'Volume')
      remaining = self.safe_float(order, 'RemainingVolume')
      filled = amount - remaining
      cost = filled * price
      result = {
        'info' => order,
        'id' => order['Id'],
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => nil,
        'side' => nil,
        'price' => price,
        'cost' => cost,
        'average' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => nil
      }
      return result
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privateGetOrdersId(self.shallow_extend({
        'id' => id
      }, params))
      return self.parse_order(response)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      response = self.privateGetOrders
      return self.parse_orders(response, nil, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      response = self.privateGetOrders(self.shallow_extend({
        'status' => 'InOrderBook'
      }, params))
      return self.parse_orders(response, nil, since, limit)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      response = self.privateGetOrders(self.shallow_extend({
        'status' => 'Matched'
      }, params))
      return self.parse_orders(response, nil, since, limit)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      response = self.publicGetOrderBooksAssetPairId(self.shallow_extend({
        'AssetPairId' => self.market_id(symbol)
      }, params))
      orderbook = {
        'timestamp' => nil,
        'bids' => [],
        'asks' => []
      }
      timestamp = nil
      for i in (0...response.length)
        side = response[i]
        if side['IsBuy']
          orderbook['bids'] = self.array_concat(orderbook['bids'], side['Prices'])
        else
          orderbook['asks'] = self.array_concat(orderbook['asks'], side['Prices'])
        end
        sideTimestamp = self.parse8601(side['Timestamp'])
        timestamp = (timestamp.nil?) ? sideTimestamp : maximum_wrapper(timestamp, sideTimestamp)
      end
      return self.parse_order_book(orderbook, timestamp, 'bids', 'asks', 'Price', 'Volume')
    end

    def parse_bid_ask(bidask, priceKey = 0, amountKey = 1)
      price = parse_float(bidask[priceKey])
      amount = parse_float(bidask[amountKey])
      if amount < 0
        amount = -amount
      end
      return [price, amount]
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      elsif api == 'private'
        if method == 'GET'
          if query
            url += '?' + self.urlencode(query)
          end
        end
        self.check_required_credentials
        headers = {
          'api-key' => self.apiKey,
          'Accept' => 'application/json',
          'Content-Type' => 'application/json'
        }
        if method == 'POST'
          if params
            body = self.json(params)
          end
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
