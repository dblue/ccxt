# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Crex24 < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'crex24',
        'name' => 'CREX24',
        'countries' => ['EE'], # Estonia
        'rateLimit' => 500,
        'version' => 'v2',
        # new metainfo interface
        'has' => {
          'cancelAllOrders' => true,
          'CORS' => false,
          'editOrder' => true,
          'fetchBidsAsks' => true,
          'fetchClosedOrders' => true,
          'fetchCurrencies' => true,
          'fetchDepositAddress' => true,
          'fetchDeposits' => true,
          'fetchFundingFees' => false,
          'fetchMyTrades' => true,
          'fetchOHLCV' => false,
          'fetchOpenOrders' => true,
          'fetchOrder' => true,
          'fetchOrders' => false,
          'fetchOrderTrades' => true,
          'fetchTickers' => true,
          'fetchTradingFee' => false, # actually, true, but will be implemented later
          'fetchTradingFees' => false, # actually, true, but will be implemented later
          'fetchTransactions' => true,
          'fetchWithdrawals' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/47813922-6f12cc00-dd5d-11e8-97c6-70f957712d47.jpg',
          'api' => 'https://api.crex24.com',
          'www' => 'https://crex24.com',
          'referral' => 'https://crex24.com/?refid=slxsjsjtil8xexl9hksr',
          'doc' => 'https://docs.crex24.com/trade-api/v2',
          'fees' => 'https://crex24.com/fees'
        },
        'api' => {
          'public' => {
            'get' => [
              'currencies',
              'instruments',
              'tickers',
              'recentTrades',
              'orderBook'
            ]
          },
          'trading' => {
            'get' => [
              'orderStatus',
              'activeOrders',
              'orderHistory',
              'tradeHistory',
              'tradeFee',
              # self is in trading API according to their docs, but most likely a typo in their docs
              'moneyTransferStatus'
            ],
            'post' => [
              'placeOrder',
              'modifyOrder',
              'cancelOrdersById',
              'cancelOrdersByInstrument',
              'cancelAllOrders'
            ]
          },
          'account' => {
            'get' => [
              'balance',
              'depositAddress',
              'moneyTransfers',
              # self is in trading API according to their docs, but most likely a typo in their docs
              'moneyTransferStatus',
              'previewWithdrawal'
            ],
            'post' => [
              'withdraw'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'percentage' => true,
            'taker' => 0.001,
            'maker' => -0.01
          },
          # should be deleted, these are outdated and inaccurate
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {},
            'deposit' => {}
          }
        },
        'commonCurrencies' => {
          'YOYO' => 'YOYOW',
          'BCC' => 'BCH'
        },
        # exchange-specific options
        'options' => {
          'fetchTickersMethod' => 'publicGetTicker24hr',
          'defaultTimeInForce' => 'GTC', # 'GTC' = Good To Cancel(default), 'IOC' = Immediate Or Cancel
          'defaultLimitOrderType' => 'limit', # or 'limit_maker'
          'hasAlreadyAuthenticatedSuccessfully' => false,
          'warnOnFetchOpenOrdersWithoutSymbol' => true,
          'parseOrderToPrecision' => false, # force amounts and costs in parseOrder to precision
          'newOrderRespType' => 'RESULT', # 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
        },
        'exceptions' => {
          'exact' => {
            "Parameter 'filter' contains invalid value." => BadRequest, # eslint-disable-quotes
            "Mandatory parameter 'instrument' is missing." => BadRequest, # eslint-disable-quotes
            "The value of parameter 'till' must be greater than or equal to the value of parameter 'from'." => BadRequest, # eslint-disable-quotes
            'Failed to verify request signature.' => AuthenticationError, # eslint-disable-quotes
            "Nonce error. Make sure that the value passed in the 'X-CREX24-API-NONCE' header is greater in each consecutive request than in the previous one for the corresponding API-Key provided in 'X-CREX24-API-KEY' header." => InvalidNonce,
            'Market orders are not supported by the instrument currently.' => InvalidOrder
          },
          'broad' => {
            'API Key' => AuthenticationError, # "API Key '9edc48de-d5b0-4248-8e7e-f59ffcd1c7f1' doesn't exist."
            'Insufficient funds' => InsufficientFunds, # "Insufficient funds => new order requires 10 ETH which is more than the available balance."
          }
        }
      })
    end

    def nonce
      return self.milliseconds
    end

    def fetch_markets(params = {})
      response = self.publicGetInstruments
      #
      #     [{              symbol =>   "$PAC-BTC",
      #                baseCurrency =>   "$PAC",
      #               quoteCurrency =>   "BTC",
      #                 feeCurrency =>   "BTC",
      #                    tickSize =>    1e-8,
      #                    minPrice =>    1e-8,
      #                   minVolume =>    1,
      #         supportedOrderTypes => ["limit"],
      #                       state =>   "active"    },
      #       {              symbol =>   "ZZC-USD",
      #                baseCurrency =>   "ZZC",
      #               quoteCurrency =>   "USD",
      #                 feeCurrency =>   "USD",
      #                    tickSize =>    0.0001,
      #                    minPrice =>    0.0001,
      #                   minVolume =>    1,
      #         supportedOrderTypes => ["limit"],
      #                       state =>   "active"   }        ]
      #
      result = []
      for i in (0...response.length)
        market = response[i]
        id = market['symbol']
        baseId = market['baseCurrency']
        quoteId = market['quoteCurrency']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => self.precision_from_string(self.truncate_to_string(market['tickSize'], 8)),
          'price' => self.precision_from_string(self.truncate_to_string(market['minPrice'], 8))
        }
        active = (market['state'] == 'active')
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'info' => market,
          'active' => active,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => self.safe_float(market, 'minVolume'),
              'max' => nil
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def fetch_currencies(params = {})
      response = self.publicGetCurrencies(params)
      #
      #     [{                   symbol => "$PAC",
      #                             name => "PACCoin",
      #                           isFiat =>  false,
      #                  depositsAllowed =>  true,
      #         depositConfirmationCount =>  8,
      #                       minDeposit =>  0,
      #               withdrawalsAllowed =>  true,
      #              withdrawalPrecision =>  8,
      #                    minWithdrawal =>  4,
      #                    maxWithdrawal =>  1000000000,
      #                flatWithdrawalFee =>  2,
      #                       isDelisted =>  false       },
      #       {                   symbol => "ZZC",
      #                             name => "Zozo",
      #                           isFiat =>  false,
      #                  depositsAllowed =>  false,
      #         depositConfirmationCount =>  8,
      #                       minDeposit =>  0,
      #               withdrawalsAllowed =>  false,
      #              withdrawalPrecision =>  8,
      #                    minWithdrawal =>  0.2,
      #                    maxWithdrawal =>  1000000000,
      #                flatWithdrawalFee =>  0.1,
      #                       isDelisted =>  false       }]
      #
      result = {}
      for i in (0...response.length)
        currency = response[i]
        id = currency['symbol']
        code = self.common_currency_code(id)
        precision = self.safe_integer(currency, 'withdrawalPrecision')
        address = self.safe_value(currency, 'BaseAddress')
        active = (currency['depositsAllowed'] && currency['withdrawalsAllowed'] && !currency['isDelisted'])
        type = currency['isFiat'] ? 'fiat' : 'crypto'
        result[code] = {
          'id' => id,
          'code' => code,
          'address' => address,
          'info' => currency,
          'type' => type,
          'name' => self.safe_string(currency, 'name'),
          'active' => active,
          'fee' => self.safe_float(currency, 'flatWithdrawalFee'), # todo => redesign
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'deposit' => {
              'min' => self.safe_float(currency, 'minDeposit'),
              'max' => nil
            },
            'withdraw' => {
              'min' => self.safe_float(currency, 'minWithdrawal'),
              'max' => self.safe_float(currency, 'maxWithdrawal')
            }
          }
        }
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      request = {
        # 'currency' => 'ETH', # comma-separated list of currency ids
        # 'nonZeroOnly' => 'false', # true by default
      }
      response = self.accountGetBalance(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #           "currency" => "ETH",
      #           "available" => 0.0,
      #           "reserved" => 0.0
      #         }
      #     ]
      #
      # log = require('ololog').unlimited.green
      # log(response)
      # process.exit
      result = { 'info' => response }
      for i in (0...response.length)
        balance = response[i]
        currencyId = self.safe_string(balance, 'currency')
        code = currencyId
        if self.currencies_by_id.include?(currencyId)
          code = self.currencies_by_id[currencyId]['code']
        else
          code = self.common_currency_code(code)
        end
        free = self.safe_float(balance, 'available')
        used = self.safe_float(balance, 'reserved')
        total = self.sum(free, used)
        result[code] = {
          'free' => free,
          'used' => used,
          'total' => total
        }
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'instrument' => market['id']
      }
      if limit != nil
        request['limit'] = limit
      end # default = maximum = 100
      response = self.publicGetOrderBook(self.shallow_extend(request, params))
      #
      #     {  buyLevels => [{ price => 0.03099, volume => 0.00610063 },
      #                     { price => 0.03097, volume => 1.33455158 },
      #                     { price => 0.03096, volume => 0.0830889 },
      #                     { price => 0.03095, volume => 0.0820356 },
      #                     { price => 0.03093, volume => 0.5499419 },
      #                     { price => 0.03092, volume => 0.23317494 },
      #                     { price => 0.03091, volume => 0.62105322 },
      #                     { price => 0.00620041, volume => 0.003 }    ],
      #       sellLevels => [{ price => 0.03117, volume => 5.47492315 },
      #                     { price => 0.03118, volume => 1.97744139 },
      #                     { price => 0.03119, volume => 0.012 },
      #                     { price => 0.03121, volume => 0.741242 },
      #                     { price => 0.03122, volume => 0.96178089 },
      #                     { price => 0.03123, volume => 0.152326 },
      #                     { price => 0.03124, volume => 2.63462933 },
      #                     { price => 0.069, volume => 0.004 }            ] }
      #
      return self.parse_order_book(response, nil, 'buyLevels', 'sellLevels', 'price', 'volume')
    end

    def parse_ticker(ticker, market = nil)
      #
      #       {    instrument => "ZZC-USD",
      #                  last =>  0.065,
      #         percentChange =>  0,
      #                   low =>  0.065,
      #                  high =>  0.065,
      #            baseVolume =>  0,
      #           quoteVolume =>  0,
      #           volumeInBtc =>  0,
      #           volumeInUsd =>  0,
      #                   ask =>  0.5,
      #                   bid =>  0.0007,
      #             timestamp => "2018-10-31T09:21:25Z" }   ]
      #
      timestamp = self.parse8601(ticker['timestamp'])
      symbol = nil
      marketId = self.safe_string(ticker, 'instrument')
      market = self.safe_value(self.markets_by_id, marketId, market)
      if market != nil
        symbol = market['symbol']
      elsif marketId != nil
        baseId, quoteId = marketId.split('-')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil, # previous day close
        'change' => nil,
        'percentage' => self.safe_float(ticker, 'percentChange'),
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'baseVolume'),
        'quoteVolume' => self.safe_float(ticker, 'quoteVolume'),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'instrument' => market['id']
      }
      response = self.publicGetTickers(self.shallow_extend(request, params))
      #
      #     [{    instrument => "$PAC-BTC",
      #                  last =>  3.3e-7,
      #         percentChange =>  3.125,
      #                   low =>  2.7e-7,
      #                  high =>  3.3e-7,
      #            baseVolume =>  191700.79823187,
      #           quoteVolume =>  0.0587930939346704,
      #           volumeInBtc =>  0.0587930939346704,
      #           volumeInUsd =>  376.2006339435353,
      #                   ask =>  3.3e-7,
      #                   bid =>  3.1e-7,
      #             timestamp => "2018-10-31T09:21:25Z" }   ]
      #
      numTickers = response.length
      if numTickers < 1
        raise(ExchangeError, self.id + ' fetchTicker could not load quotes for symbol ' + symbol)
      end
      return self.parse_ticker(response[0], market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      request = {}
      if symbols != nil
        ids = self.market_ids(symbols)
        request['instrument'] = ids.join(',')
      end
      response = self.publicGetTickers(self.shallow_extend(request, params))
      #
      #     [{    instrument => "$PAC-BTC",
      #                  last =>  3.3e-7,
      #         percentChange =>  3.125,
      #                   low =>  2.7e-7,
      #                  high =>  3.3e-7,
      #            baseVolume =>  191700.79823187,
      #           quoteVolume =>  0.0587930939346704,
      #           volumeInBtc =>  0.0587930939346704,
      #           volumeInUsd =>  376.2006339435353,
      #                   ask =>  3.3e-7,
      #                   bid =>  3.1e-7,
      #             timestamp => "2018-10-31T09:21:25Z" },
      #       {    instrument => "ZZC-USD",
      #                  last =>  0.065,
      #         percentChange =>  0,
      #                   low =>  0.065,
      #                  high =>  0.065,
      #            baseVolume =>  0,
      #           quoteVolume =>  0,
      #           volumeInBtc =>  0,
      #           volumeInUsd =>  0,
      #                   ask =>  0.5,
      #                   bid =>  0.0007,
      #             timestamp => "2018-10-31T09:21:25Z" }   ]
      #
      return self.parse_tickers(response, symbols)
    end

    def parse_tickers(tickers, symbols = nil)
      result = []
      for i in (0...tickers.length)
        result.push(self.parse_ticker(tickers[i]))
      end
      return self.filter_by_array(result, 'symbol', symbols)
    end

    def parse_trade(trade, market = nil)
      #
      # public fetchTrades
      #
      #       {     price =>  0.03105,
      #            volume =>  0.11,
      #              side => "sell",
      #         timestamp => "2018-10-31T04:19:35Z" }  ]
      #
      # private fetchMyTrades
      #
      #     {
      #         "id" => 3005866,
      #         "orderId" => 468533093,
      #         "timestamp" => "2018-06-02T16:26:27Z",
      #         "instrument" => "BCH-ETH",
      #         "side" => "buy",
      #         "price" => 1.78882,
      #         "volume" => 0.027,
      #         "fee" => 0.0000483,
      #         "feeCurrency" => "ETH"
      #     }
      #
      timestamp = self.parse8601(trade['timestamp'])
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'volume')
      cost = nil
      if price != nil
        if amount != nil
          cost = amount * price
        end
      end
      id = nil
      side = self.safe_string(trade, 'side')
      orderId = self.safe_string(trade, 'orderId')
      symbol = nil
      marketId = self.safe_string(trade, 'instrument')
      market = self.safe_value(self.markets_by_id, marketId, market)
      if market != nil
        symbol = market['symbol']
      end
      fee = nil
      feeCurrencyId = self.safe_string(trade, 'feeCurrency')
      feeCurrency = self.safe_value(self.currencies_by_id, feeCurrencyId)
      feeCode = nil
      if feeCurrency != nil
        feeCode = feeCurrency['code']
      elsif market != nil
        feeCode = market['quote']
      end
      feeCost = self.safe_float(trade, 'fee')
      if feeCost != nil
        fee = {
          'cost' => feeCost,
          'currency' => feeCode
        }
      end
      takerOrMaker = nil
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => id,
        'order' => orderId,
        'type' => nil,
        'takerOrMaker' => takerOrMaker,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'instrument' => market['id']
      }
      if limit != nil
        request['limit'] = limit # min 1, max 1000, default 100
      end
      response = self.publicGetRecentTrades(self.shallow_extend(request, params))
      #
      #     [{     price =>  0.03117,
      #            volume =>  0.02597403,
      #              side => "buy",
      #         timestamp => "2018-10-31T09:37:46Z" },
      #       {     price =>  0.03105,
      #            volume =>  0.11,
      #              side => "sell",
      #         timestamp => "2018-10-31T04:19:35Z" }  ]
      #
      return self.parse_trades(response, market, since, limit)
    end

    def parse_order_status(status)
      statuses = {
        'submitting' => 'open', # A newly created limit order has a status "submitting" until it has been processed.
        # This status changes during the lifetime of an order and can have different values depending on the value of the parameter Time In Force.
        'unfilledActive' => 'open', # order is active, no trades have been made
        'partiallyFilledActive' => 'open', # part of the order has been filled, the other part is active
        'filled' => 'closed', # order has been filled entirely
        'partiallyFilledCancelled' => 'canceled', # part of the order has been filled, the other part has been cancelled either by the trader or by the system(see the value of cancellationReason of an Order for more details on the reason of cancellation)
        'unfilledCancelled' => 'canceled', # order has been cancelled, no trades have taken place(see the value of cancellationReason of an Order for more details on the reason of cancellation)
      }
      return(statuses.include?(status)) ? statuses[status] : status
    end

    def parse_order(order, market = nil)
      #
      # createOrder
      #
      #     {
      #         "id" => 469594855,
      #         "timestamp" => "2018-06-08T16:59:44Z",
      #         "instrument" => "BTS-BTC",
      #         "side" => "buy",
      #         "type" => "limit",
      #         "status" => "submitting",
      #         "cancellationReason" => null,
      #         "timeInForce" => "GTC",
      #         "volume" => 4.0,
      #         "price" => 0.000025,
      #         "stopPrice" => null,
      #         "remainingVolume" => 4.0,
      #         "lastUpdate" => null,
      #         "parentOrderId" => null,
      #         "childOrderId" => null
      #     }
      #
      status = self.parse_order_status(self.safe_string(order, 'status'))
      symbol = self.find_symbol(self.safe_string(order, 'symbol'), market)
      timestamp = self.parse8601(self.safe_string(order, 'timestamp'))
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'volume')
      remaining = self.safe_float(order, 'remainingVolume')
      filled = nil
      lastTradeTimestamp = self.parse8601(self.safe_string(order, 'lastUpdate'))
      cost = nil
      if remaining != nil
        if amount != nil
          filled = amount - remaining
          if self.options['parseOrderToPrecision']
            filled = parse_float(self.amount_to_precision(symbol, filled))
          end
          filled = maximum_wrapper(filled, 0.0)
          if price != nil
            cost = price * filled
          end
        end
      end
      id = self.safe_string(order, 'id')
      type = self.safe_string(order, 'type')
      if type == 'market'
        if price == 0.0
          if (cost != nil) && (filled != nil)
            if (cost > 0) && (filled > 0)
              price = cost / filled
            end
          end
        end
      end
      side = self.safe_string(order, 'side')
      fee = nil
      trades = nil
      average = nil
      if cost != nil
        if filled
          average = cost / filled
        end
        if self.options['parseOrderToPrecision']
          cost = parse_float(self.cost_to_precision(symbol, cost))
        end
      end
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'average' => average,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee,
        'trades' => trades
      }
      return result
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'instrument' => market['id'],
        'volume' => self.amount_to_precision(symbol, amount),
        # The value must comply with the list of order types supported by the instrument(see the value of parameter supportedOrderTypes of the Instrument)
        # If the parameter is not specified, the default value "limit" is used
        # More about order types in the corresponding section of documentation
        'type' => type, # 'limit', 'market', 'stopLimit', in fact as of 2018-10-31, only 'limit' orders are supported for all markets
        'side' => side, # 'buy' or 'sell'
        # "GTC" - Good-Til-Cancelled
        # "IOC" - Immediate-Or-Cancel(currently not supported by the exchange API, reserved for future use)
        # "FOK" - Fill-Or-Kill(currently not supported by the exchange API, reserved for future use)
        # 'timeInForce' => 'GTC', # IOC', 'FOK'
        # 'strictValidation' => false, # false - prices will be rounded to meet the requirement, true - execution of the method will be aborted and an error message will be returned
      }
      priceIsRequired = false
      stopPriceIsRequired = false
      if type == 'limit'
        priceIsRequired = true
      elsif type == 'stopLimit'
        priceIsRequired = true
        stopPriceIsRequired = true
      end
      if priceIsRequired
        if price.nil?
          raise(InvalidOrder, self.id + ' createOrder method requires a price argument for a ' + type + ' order')
        end
        request['price'] = self.price_to_precision(symbol, price)
      end
      if stopPriceIsRequired
        stopPrice = self.safe_float(params, 'stopPrice')
        if stopPrice.nil?
          raise(InvalidOrder, self.id + ' createOrder method requires a stopPrice extra param for a ' + type + ' order')
        else
          request['stopPrice'] = self.price_to_precision(symbol, stopPrice)
        end
      end
      response = self.tradingPostPlaceOrder(self.shallow_extend(request, params))
      #
      #     {
      #         "id" => 469594855,
      #         "timestamp" => "2018-06-08T16:59:44Z",
      #         "instrument" => "BTS-BTC",
      #         "side" => "buy",
      #         "type" => "limit",
      #         "status" => "submitting",
      #         "cancellationReason" => null,
      #         "timeInForce" => "GTC",
      #         "volume" => 4.0,
      #         "price" => 0.000025,
      #         "stopPrice" => null,
      #         "remainingVolume" => 4.0,
      #         "lastUpdate" => null,
      #         "parentOrderId" => null,
      #         "childOrderId" => null
      #     }
      #
      return self.parse_order(response, market)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'id' => id
      }
      response = self.tradingGetOrderStatus(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #           "id" => 466747915,
      #           "timestamp" => "2018-05-26T06:43:49Z",
      #           "instrument" => "UNI-BTC",
      #           "side" => "sell",
      #           "type" => "limit",
      #           "status" => "partiallyFilledActive",
      #           "cancellationReason" => null,
      #           "timeInForce" => "GTC",
      #           "volume" => 5700.0,
      #           "price" => 0.000005,
      #           "stopPrice" => null,
      #           "remainingVolume" => 1.948051948052,
      #           "lastUpdate" => null,
      #           "parentOrderId" => null,
      #           "childOrderId" => null
      #         }
      #     ]
      #
      numOrders = response.length
      if numOrders < 1
        raise(OrderNotFound, self.id + ' fetchOrder could not fetch order id ' + id)
      end
      return self.parse_order(response[0])
    end

    def fetch_orders_by_ids(ids = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {
        'id' => ids.join(',')
      }
      response = self.tradingGetOrderStatus(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #           "id" => 466747915,
      #           "timestamp" => "2018-05-26T06:43:49Z",
      #           "instrument" => "UNI-BTC",
      #           "side" => "sell",
      #           "type" => "limit",
      #           "status" => "partiallyFilledActive",
      #           "cancellationReason" => null,
      #           "timeInForce" => "GTC",
      #           "volume" => 5700.0,
      #           "price" => 0.000005,
      #           "stopPrice" => null,
      #           "remainingVolume" => 1.948051948052,
      #           "lastUpdate" => null,
      #           "parentOrderId" => null,
      #           "childOrderId" => null
      #         }
      #     ]
      #
      return self.parse_orders(response, nil, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      request = {}
      if symbol != nil
        market = self.market(symbol)
        request['instrument'] = market['id']
      end
      response = self.tradingGetActiveOrders(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #             "id" => 466747915,
      #             "timestamp" => "2018-05-26T06:43:49Z",
      #             "instrument" => "UNI-BTC",
      #             "side" => "sell",
      #             "type" => "limit",
      #             "status" => "partiallyFilledActive",
      #             "cancellationReason" => null,
      #             "timeInForce" => "GTC",
      #             "volume" => 5700.0,
      #             "price" => 0.000005,
      #             "stopPrice" => null,
      #             "remainingVolume" => 1.948051948052,
      #             "lastUpdate" => null,
      #             "parentOrderId" => null,
      #             "childOrderId" => null
      #         },
      #         {
      #             "id" => 466748077,
      #             "timestamp" => "2018-05-26T06:45:29Z",
      #             "instrument" => "PRJ-BTC",
      #             "side" => "sell",
      #             "type" => "limit",
      #             "status" => "partiallyFilledActive",
      #             "cancellationReason" => null,
      #             "timeInForce" => "GTC",
      #             "volume" => 10000.0,
      #             "price" => 0.0000007,
      #             "stopPrice" => null,
      #             "remainingVolume" => 9975.0,
      #             "lastUpdate" => null,
      #             "parentOrderId" => null,
      #             "childOrderId" => null
      #         },
      #         ...
      #     ]
      #
      return self.parse_orders(response, market, since, limit)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      request = {}
      if symbol != nil
        market = self.market(symbol)
        request['instrument'] = market['id']
      end
      if since != nil
        request['from'] = self.ymdhms(since, 'T')
      end
      if limit != nil
        request['limit'] = limit # min 1, max 1000, default 100
      end
      response = self.tradingGetActiveOrders(self.shallow_extend(request, params))
      #     [
      #         {
      #             "id" => 468535711,
      #             "timestamp" => "2018-06-02T16:42:40Z",
      #             "instrument" => "BTC-EUR",
      #             "side" => "sell",
      #             "type" => "limit",
      #             "status" => "submitting",
      #             "cancellationReason" => null,
      #             "timeInForce" => "GTC",
      #             "volume" => 0.00770733,
      #             "price" => 6724.9,
      #             "stopPrice" => null,
      #             "remainingVolume" => 0.00770733,
      #             "lastUpdate" => null,
      #             "parentOrderId" => null,
      #             "childOrderId" => null
      #         },
      #         {
      #             "id" => 468535707,
      #             "timestamp" => "2018-06-02T16:42:37Z",
      #             "instrument" => "BTG-BTC",
      #             "side" => "buy",
      #             "type" => "limit",
      #             "status" => "unfilledActive",
      #             "cancellationReason" => null,
      #             "timeInForce" => "GTC",
      #             "volume" => 0.0173737,
      #             "price" => 0.00589027,
      #             "stopPrice" => null,
      #             "remainingVolume" => 0.0173737,
      #             "lastUpdate" => null,
      #             "parentOrderId" => null,
      #             "childOrderId" => null
      #         },
      #         ...
      #     ]
      #
      return self.parse_orders(response, market, since, limit)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.tradingPostCancelOrdersById(self.shallow_extend({
        'ids' => [
          parse_int(id)
        ]
      }, params))
      #
      #     [
      #         465448358,
      #         468364313
      #     ]
      #
      return self.parse_order(response)
    end

    def cancel_all_orders(symbol = nil, params = {})
      response = self.tradingPostCancelAllOrders(params)
      #
      #     [
      #         465448358,
      #         468364313
      #     ]
      #
      return response
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      request = {}
      if symbol != nil
        market = self.market(symbol)
        request['instrument'] = market['id']
      end
      if since != nil
        request['from'] = self.ymdhms(since, 'T')
      end
      if limit != nil
        request['limit'] = limit # min 1, max 1000, default 100
      end
      response = self.tradingGetTradeHistory(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #             "id" => 3005866,
      #             "orderId" => 468533093,
      #             "timestamp" => "2018-06-02T16:26:27Z",
      #             "instrument" => "BCH-ETH",
      #             "side" => "buy",
      #             "price" => 1.78882,
      #             "volume" => 0.027,
      #             "fee" => 0.0000483,
      #             "feeCurrency" => "ETH"
      #         },
      #         {
      #             "id" => 3005812,
      #             "orderId" => 468515771,
      #             "timestamp" => "2018-06-02T16:16:05Z",
      #             "instrument" => "ETC-BTC",
      #             "side" => "sell",
      #             "price" => 0.00210958,
      #             "volume" => 0.05994006,
      #             "fee" => -0.000000063224,
      #             "feeCurrency" => "BTC"
      #         },
      #         ...
      #     ]
      #
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      currency = nil
      request = {}
      if code != nil
        currency = self.currency(code)
        request['currency'] = currency['id']
      end
      if since != nil
        request['from'] = self.ymd(since, 'T')
      end
      response = self.accountGetMoneyTransfers(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #           "id" => 756446,
      #           "type" => "deposit",
      #           "currency" => "ETH",
      #           "address" => "0x451d5a1b7519aa75164f440df78c74aac96023fe",
      #           "paymentId" => null,
      #           "amount" => 0.142,
      #           "fee" => null,
      #           "txId" => "0x2b49098749840a9482c4894be94f94864b498a1306b6874687a5640cc9871918",
      #           "createdAt" => "2018-06-02T19:30:28Z",
      #           "processedAt" => "2018-06-02T21:10:41Z",
      #           "confirmationsRequired" => 12,
      #           "confirmationCount" => 12,
      #           "status" => "success",
      #           "errorDescription" => null
      #         },
      #         {
      #           "id" => 754618,
      #           "type" => "deposit",
      #           "currency" => "BTC",
      #           "address" => "1IgNfmERVcier4IhfGEfutkLfu4AcmeiUC",
      #           "paymentId" => null,
      #           "amount" => 0.09,
      #           "fee" => null,
      #           "txId" => "6876541687a9187e987c9187654f7198b9718af974641687b19a87987f91874f",
      #           "createdAt" => "2018-06-02T16:19:44Z",
      #           "processedAt" => "2018-06-02T16:20:50Z",
      #           "confirmationsRequired" => 1,
      #           "confirmationCount" => 1,
      #           "status" => "success",
      #           "errorDescription" => null
      #         },
      #         ...
      #     ]
      #
      return self.parseTransactions(response, currency, since, limit)
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions(code, since, limit, self.shallow_extend({
        'type' => 'deposit'
      }, params))
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions(code, since, limit, self.shallow_extend({
        'type' => 'withdrawal'
      }, params))
    end

    def parse_transaction_status(status)
      statuses = {
        'pending' => 'pending', # transfer is in progress
        'success' => 'ok', # completed successfully
        'failed' => 'failed', # aborted at some point(money will be credited back to the account of origin)
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction(transaction, currency = nil)
      #
      #     {
      #         "id" => 756446,
      #         "type" => "deposit",
      #         "currency" => "ETH",
      #         "address" => "0x451d5a1b7519aa75164f440df78c74aac96023fe",
      #         "paymentId" => null,
      #         "amount" => 0.142,
      #         "fee" => null,
      #         "txId" => "0x2b49098749840a9482c4894be94f94864b498a1306b6874687a5640cc9871918",
      #         "createdAt" => "2018-06-02T19:30:28Z",
      #         "processedAt" => "2018-06-02T21:10:41Z",
      #         "confirmationsRequired" => 12,
      #         "confirmationCount" => 12,
      #         "status" => "success",
      #         "errorDescription" => null,
      #     }
      #
      id = self.safe_string(transaction, 'id')
      address = self.safe_string(transaction, 'address')
      tag = self.safe_string(transaction, 'paymentId')
      txid = self.safe_value(transaction, 'txId')
      code = nil
      currencyId = self.safe_string(transaction, 'currency')
      if self.currencies_by_id.include?(currencyId)
        currency = self.currencies_by_id[currencyId]
      else
        code = self.common_currency_code(currencyId)
      end
      if currency != nil
        code = currency['code']
      end
      type = self.safe_string(transaction, 'type')
      timestamp = self.parse8601(self.safe_string(transaction, 'createdAt'))
      updated = self.parse8601(self.safe_string(transaction, 'processedAt'))
      status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
      amount = self.safe_float(transaction, 'amount')
      feeCost = self.safe_float(transaction, 'fee')
      fee = {
        'cost' => feeCost,
        'currency' => code
      }
      return {
        'info' => transaction,
        'id' => id,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => address,
        'tag' => tag,
        'type' => type,
        'amount' => amount,
        'currency' => code,
        'status' => status,
        'updated' => updated,
        'fee' => fee
      }
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = self.accountGetDepositAddress(self.shallow_extend(request, params))
      #
      #     {
      #         "currency" => "BTS",
      #         "address" => "crex24",
      #         "paymentId" => "0fg4da4186741579"
      #     }
      #
      address = self.safe_string(response, 'address')
      tag = self.safe_string(response, 'paymentId')
      return {
        'currency' => code,
        'address' => self.check_address(address),
        'tag' => tag,
        'info' => response
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'address' => address,
        'amount' => parse_float(self.currency_to_precision(code, amount)),
        # sets whether the specified amount includes fee, can have either of the two values
        # true - balance will be decreased by amount, whereas [amount - fee] will be transferred to the specified address
        # false - amount will be deposited to the specified address, whereas the balance will be decreased by [amount + fee]
        # 'includeFee' => false, # the default value is false
      }
      if tag != nil
        request['paymentId'] = tag
      end
      response = self.accountPostWithdraw(self.shallow_extend(request, params))
      return self.parse_transaction(response)
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = '/' + self.version + '/' + api + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if method == 'GET'
        if query
          request += '?' + self.urlencode(query)
        end
      end
      url = self.urls['api'] + request
      if (api == 'trading') || (api == 'account')
        self.check_required_credentials
        nonce = self.nonce.to_s
        secret = Base64.decode64(self.secret)
        auth = request + nonce
        headers = {
          'X-CREX24-API-KEY' => self.apiKey,
          'X-CREX24-API-NONCE' => nonce
        }
        if method == 'POST'
          headers['Content-Type'] = 'application/json'
          body = self.json(params)
          auth += body
        end
        signature = Base64.encode64(self.hmac(self.encode(auth), secret, 'sha512', 'binary'))
        headers['X-CREX24-API-SIGN'] = signature
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if !self.is_json_encoded_object(body)
        return # fallback to default error handler
      end
      if (code >= 200) && (code < 300)
        return # no error
      end
      message = self.safe_string(response, 'errorDescription')
      feedback = self.id + ' ' + self.json(response)
      exact = self.exceptions['exact']
      if exact.include?(message)
        raise(exact[message], feedback)
      end
      broad = self.exceptions['broad']
      broadKey = self.findBroadlyMatchedKey(broad, message)
      if broadKey != nil
        raise(broad[broadKey], feedback)
      end
      if code == 400
        raise(BadRequest, feedback)
      elsif code == 401
        raise(AuthenticationError, feedback)
      elsif code == 403
        raise(AuthenticationError, feedback)
      elsif code == 429
        raise(DDoSProtection, feedback)
      elsif code == 500
        raise(ExchangeError, feedback)
      elsif code == 503
        raise(ExchangeNotAvailable, feedback)
      elsif code == 504
        raise(RequestTimeout, feedback)
      end
      raise(ExchangeError, feedback) # unknown message
    end
  end
end
