# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coingi < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coingi',
        'name' => 'Coingi',
        'rateLimit' => 1000,
        'countries' => ['PA', 'BG', 'CN', 'US'], # Panama, Bulgaria, China, US
        'has' => {
          'CORS' => false,
          'fetchTickers' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/28619707-5c9232a8-7212-11e7-86d6-98fe5d15cc6e.jpg',
          'api' => {
            'www' => 'https://coingi.com',
            'current' => 'https://api.coingi.com',
            'user' => 'https://api.coingi.com'
          },
          'www' => 'https://coingi.com',
          'doc' => 'https://coingi.docs.apiary.io'
        },
        'api' => {
          'www' => {
            'get' => [
              ''
            ]
          },
          'current' => {
            'get' => [
              'order-book/{pair}/{askCount}/{bidCount}/{depth}',
              'transactions/{pair}/{maxCount}',
              '24hour-rolling-aggregation'
            ]
          },
          'user' => {
            'post' => [
              'balance',
              'add-order',
              'cancel-order',
              'orders',
              'transactions',
              'create-crypto-withdrawal'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'taker' => 0.2 / 100,
            'maker' => 0.2 / 100
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {
              'BTC' => 0.001,
              'LTC' => 0.01,
              'DOGE' => 2,
              'PPC' => 0.02,
              'VTC' => 0.2,
              'NMC' => 2,
              'DASH' => 0.002,
              'USD' => 10,
              'EUR' => 10
            },
            'deposit' => {
              'BTC' => 0,
              'LTC' => 0,
              'DOGE' => 0,
              'PPC' => 0,
              'VTC' => 0,
              'NMC' => 0,
              'DASH' => 0,
              'USD' => 5,
              'EUR' => 1
            }
          }
        }
      })
    end

    def fetch_markets(params = {})
      response = self.wwwGet
      parts = response.split('do=currencyPairSelector-selectCurrencyPair" class="active">')
      currencyParts = parts[1].split('<div class="currency-pair-label">')
      result = []
      for i in (1...currencyParts.length)
        currencyPart = currencyParts[i]
        idParts = currencyPart.split('</div>')
        id = idParts[0]
        symbol = id
        id = id.gsub('/', '-')
        id = id.downcase
        base, quote = symbol.split('/')
        precision = {
          'amount' => 8,
          'price' => 8
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'info' => id,
          'active' => true,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => 10**precision['amount']
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            },
            'cost' => {
              'min' => 0,
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      lowercaseCurrencies = []
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        lowercaseCurrencies.push(currency.downcase)
      end
      balances = self.userPostBalance({
        'currencies' => lowercaseCurrencies.join(',')
      })
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency']['name']
        currency = currency.upcase
        account = {
          'free' => balance['available'],
          'used' => balance['blocked'] + balance['inOrders'] + balance['withdrawing'],
          'total' => 0.0
        }
        account['total'] = self.sum(account['free'], account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = 512, params = {})
      self.load_markets
      market = self.market(symbol)
      orderbook = self.currentGetOrderBookPairAskCountBidCountDepth(self.shallow_extend({
        'pair' => market['id'],
        'depth' => 32, # maximum number of depth range steps 1-32
        'askCount' => limit, # maximum returned number of asks 1-512
        'bidCount' => limit, # maximum returned number of bids 1-512
      }, params))
      return self.parse_order_book(orderbook, nil, 'bids', 'asks', 'price', 'baseAmount')
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => ticker['high'],
        'low' => ticker['low'],
        'bid' => ticker['highestBid'],
        'bidVolume' => nil,
        'ask' => ticker['lowestAsk'],
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => nil,
        'last' => nil,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => ticker['baseVolume'],
        'quoteVolume' => ticker['counterVolume'],
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.currentGet24hourRollingAggregation(params)
      result = {}
      for t in (0...response.length)
        ticker = response[t]
        base = ticker['currencyPair']['base'].upcase
        quote = ticker['currencyPair']['counter'].upcase
        symbol = base + '/' + quote
        market = nil
        if self.markets.include?(symbol)
          market = self.markets[symbol]
        end
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      tickers = self.fetch_tickers(nil, params)
      if tickers.include?(symbol)
        return tickers[symbol]
      end
      raise(ExchangeError, self.id + ' return did not contain ' + symbol)
    end

    def parse_trade(trade, market = nil)
      if !market
        market = self.markets_by_id[trade['currencyPair']]
      end
      return {
        'id' => trade['id'],
        'info' => trade,
        'timestamp' => trade['timestamp'],
        'datetime' => self.iso8601(trade['timestamp']),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => nil, # type
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.currentGetTransactionsPairMaxCount(self.shallow_extend({
        'pair' => market['id'],
        'maxCount' => 128
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      order = {
        'currencyPair' => self.market_id(symbol),
        'volume' => amount,
        'price' => price,
        'orderType' => (side == 'buy') ? 0 : 1
      }
      response = self.userPostAddOrder(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['result']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.userPostCancelOrder({ 'orderId' => id })
    end

    def sign(path, api = 'current', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api]
      if api != 'www'
        url += '/' + api + '/' + self.implode_params(path, params)
      end
      query = self.omit(params, self.extract_params(path))
      if api == 'current'
        if query
          url += '?' + self.urlencode(query)
        end
      elsif api == 'user'
        self.check_required_credentials
        nonce = self.nonce
        request = self.shallow_extend({
          'token' => self.apiKey,
          'nonce' => nonce
        }, query)
        auth = nonce.to_s + '$' + self.apiKey
        request['signature'] = self.hmac(self.encode(auth), self.encode(self.secret))
        body = self.json(request)
        headers = {
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'current', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if !response.is_a?(String)
        if response.include?('errors')
          raise(ExchangeError, self.id + ' ' + self.json(response))
        end
      end
      return response
    end
  end
end
