# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Livecoin < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'livecoin',
        'name' => 'LiveCoin',
        'countries' => ['US', 'UK', 'RU'],
        'rateLimit' => 1000,
        'userAgent' => self.userAgents['chrome'],
        'has' => {
          'fetchDepositAddress' => true,
          'fetchDeposits' => true,
          'CORS' => false,
          'fetchTickers' => true,
          'fetchCurrencies' => true,
          'fetchTradingFee' => true,
          'fetchTradingFees' => true,
          'fetchOrders' => true,
          'fetchOrder' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchMyTrades' => true,
          'fetchWithdrawals' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27980768-f22fc424-638a-11e7-89c9-6010a54ff9be.jpg',
          'api' => 'https://api.livecoin.net',
          'www' => 'https://www.livecoin.net',
          'doc' => 'https://www.livecoin.net/api?lang=en',
          'referral' => 'https://livecoin.net/?from=Livecoin-CQ1hfx44'
        },
        'api' => {
          'public' => {
            'get' => [
              'exchange/all/order_book',
              'exchange/last_trades',
              'exchange/maxbid_minask',
              'exchange/order_book',
              'exchange/restrictions',
              'exchange/ticker', # omit params to get all tickers at once
              'info/coinInfo'
            ]
          },
          'private' => {
            'get' => [
              'exchange/client_orders',
              'exchange/order',
              'exchange/trades',
              'exchange/commission',
              'exchange/commissionCommonInfo',
              'payment/balances',
              'payment/balance',
              'payment/get/address',
              'payment/history/size',
              'payment/history/transactions'
            ],
            'post' => [
              'exchange/buylimit',
              'exchange/buymarket',
              'exchange/cancellimit',
              'exchange/selllimit',
              'exchange/sellmarket',
              'payment/out/capitalist',
              'payment/out/card',
              'payment/out/coin',
              'payment/out/okpay',
              'payment/out/payeer',
              'payment/out/perfectmoney',
              'payment/voucher/amount',
              'payment/voucher/make',
              'payment/voucher/redeem'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.18 / 100,
            'taker' => 0.18 / 100
          }
        },
        'commonCurrencies' => {
          'BTCH' => 'Bithash',
          'CPC' => 'CapriCoin',
          'EDR' => 'E-Dinar Coin', # conflicts with EDR for Endor Protocol and EDRCoin
          'eETT' => 'EETT',
          'FirstBlood' => '1ST',
          'FORTYTWO' => '42',
          'ORE' => 'Orectic',
          'RUR' => 'RUB',
          'SCT' => 'SpaceCoin',
          'TPI' => 'ThaneCoin',
          'wETT' => 'WETT',
          'XBT' => 'Bricktox'
        },
        'exceptions' => {
          '1' => ExchangeError,
          '10' => AuthenticationError,
          '100' => ExchangeError, # invalid parameters
          '101' => AuthenticationError,
          '102' => AuthenticationError,
          '103' => InvalidOrder, # invalid currency
          '104' => InvalidOrder, # invalid amount
          '105' => InvalidOrder, # unable to block funds
          '11' => AuthenticationError,
          '12' => AuthenticationError,
          '2' => AuthenticationError, # "User not found"
          '20' => AuthenticationError,
          '30' => AuthenticationError,
          '31' => NotSupported,
          '32' => ExchangeError,
          '429' => DDoSProtection,
          '503' => ExchangeNotAvailable
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetExchangeTicker
      restrictions = self.publicGetExchangeRestrictions
      restrictionsById = self.index_by(restrictions['restrictions'], 'currencyPair')
      result = []
      for p in (0...markets.length)
        market = markets[p]
        id = market['symbol']
        baseId, quoteId = id.split('/')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        coinRestrictions = self.safe_value(restrictionsById, symbol)
        precision = {
          'price' => 5,
          'amount' => 8,
          'cost' => 8
        }
        limits = {
          'amount' => {
            'min' => 10**-precision['amount'],
            'max' => 10**precision['amount']
          }
        }
        if coinRestrictions
          precision['price'] = self.safe_integer(coinRestrictions, 'priceScale', 5)
          limits['amount']['min'] = self.safe_float(coinRestrictions, 'minLimitQuantity', limits['amount']['min'])
        end
        limits['price'] = {
          'min' => 10**-precision['price'],
          'max' => 10**precision['price']
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => limits,
          'info' => market
        })
      end
      return result
    end

    def fetch_currencies(params = {})
      response = self.publicGetInfoCoinInfo(params)
      currencies = response['info']
      result = {}
      for i in (0...currencies.length)
        currency = currencies[i]
        id = currency['symbol']
        # todo => will need to rethink the fees
        # to add support for multiple withdrawal/deposit methods and
        # differentiated fees for each particular method
        code = self.common_currency_code(id)
        precision = 8 # default precision, todo => fix "magic constants"
        active = (currency['walletStatus'] == 'normal')
        result[code] = {
          'id' => id,
          'code' => code,
          'info' => currency,
          'name' => currency['name'],
          'active' => active,
          'fee' => currency['withdrawFee'], # todo => redesign
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => currency['minOrderAmount'],
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => currency['minOrderAmount'],
              'max' => nil
            },
            'withdraw' => {
              'min' => currency['minWithdrawAmount'],
              'max' => 10**precision
            },
            'deposit' => {
              'min' => currency['minDepositAmount'],
              'max' => nil
            }
          }
        }
      end
      result = self.append_fiat_currencies(result)
      return result
    end

    def append_fiat_currencies(result)
      precision = 8
      defaults = {
        'info' => nil,
        'active' => true,
        'fee' => nil,
        'precision' => precision,
        'limits' => {
          'withdraw' => { 'min' => nil, 'max' => nil },
          'deposit' => { 'min' => nil, 'max' => nil },
          'amount' => { 'min' => nil, 'max' => nil },
          'cost' => { 'min' => nil, 'max' => nil },
          'price' => {
            'min' => 10**-precision,
            'max' => 10**precision
          }
        }
      }
      currencies = [
        { 'id' => 'USD', 'code' => 'USD', 'name' => 'US Dollar' },
        { 'id' => 'EUR', 'code' => 'EUR', 'name' => 'Euro' },
        # { 'id' => 'RUR', 'code' => 'RUB', 'name' => 'Russian ruble' }
      ]
      currencies.push({
        'id' => 'RUR',
        'code' => self.common_currency_code('RUR'),
        'name' => 'Russian ruble'
      })
      for i in (0...currencies.length)
        currency = currencies[i]
        code = currency['code']
        result[code] = shallow_extend(defaults, currency)
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privateGetPaymentBalances
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency']
        account = nil
        if result.include?(currency)
          account = result[currency]
        else
          account = self.account
        end
        if balance['type'] == 'total'
          account['total'] = balance['value'].to_f
        end
        if balance['type'] == 'available'
          account['free'] = balance['value'].to_f
        end
        if balance['type'] == 'trade'
          account['used'] = balance['value'].to_f
        end
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_trading_fees(params = {})
      self.load_markets
      response = self.privateGetExchangeCommissionCommonInfo(params)
      commission = self.safe_float(response, 'commission')
      return {
        'info' => response,
        'maker' => commission,
        'taker' => commission
      }
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'currencyPair' => self.market_id(symbol),
        'groupByPrice' => 'false'
      }
      if limit != nil
        request['depth'] = limit # 100
      end
      orderbook = self.publicGetExchangeOrderBook(shallow_extend(request, params))
      timestamp = orderbook['timestamp']
      return self.parse_order_book(orderbook, timestamp)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      vwap = self.safe_float(ticker, 'vwap')
      baseVolume = self.safe_float(ticker, 'volume')
      quoteVolume = nil
      if baseVolume != nil && vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'best_bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'best_ask'),
        'askVolume' => nil,
        'vwap' => self.safe_float(ticker, 'vwap'),
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetExchangeTicker(params)
      tickers = self.index_by(response, 'symbol')
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        market = self.markets_by_id[id]
        symbol = market['symbol']
        ticker = tickers[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetExchangeTicker(shallow_extend({
        'currencyPair' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      #
      # fetchTrades(public)
      #
      #     {
      #         "time" => 1409935047,
      #         "id" => 99451,
      #         "price" => 350,
      #         "quantity" => 2.85714285,
      #         "type" => "BUY"
      #     }
      #
      # fetchMyTrades(private)
      #
      #     {
      #         "datetime" => 1435844369,
      #         "id" => 30651619,
      #         "type" => "sell",
      #         "symbol" => "BTC/EUR",
      #         "price" => 230,
      #         "quantity" => 0.1,
      #         "commission" => 0,
      #         "clientorderid" => 1472837650
      #     }
      timestamp = self.safe_string_2(trade, 'time', 'datetime')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      fee = nil
      feeCost = self.safe_float(trade, 'commission')
      if feeCost != nil
        feeCurrency = market ? market['quote'] : nil
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      orderId = self.safe_string(trade, 'clientorderid')
      id = self.safe_string(trade, 'id')
      side = self.safe_string(trade, 'type')
      if side != nil
        side = side.downcase
      end
      amount = self.safe_float(trade, 'quantity')
      price = self.safe_float(trade, 'price')
      cost = nil
      if amount != nil
        if price != nil
          cost = amount * price
        end
      end
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'id' => id,
        'order' => orderId,
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'currencyPair' => market['id'],
        # orderDesc' => 'true', # or 'false', if true then new orders will be first, otherwise old orders will be first.
        # 'offset' => 0, # page offset, position of the first item on the page
      }
      if limit != nil
        request['limit'] = limit
      end
      response = self.privateGetExchangeTrades(shallow_extend(request, params))
      #
      #     [
      #         {
      #             "datetime" => 1435844369,
      #             "id" => 30651619,
      #             "type" => "sell",
      #             "symbol" => "BTC/EUR",
      #             "price" => 230,
      #             "quantity" => 0.1,
      #             "commission" => 0,
      #             "clientorderid" => 1472837650
      #         },
      #         {
      #             "datetime" => 1435844356,
      #             "id" => 30651618,
      #             "type" => "sell",
      #             "symbol" => "BTC/EUR",
      #             "price" => 230,
      #             "quantity" => 0.2,
      #             "commission" => 0.092,
      #             "clientorderid" => 1472837651
      #         }
      #     ]
      #
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'currencyPair' => market['id']
      }
      response = self.publicGetExchangeLastTrades(shallow_extend(request, params))
      #
      #     [
      #         {
      #             "time" => 1409935047,
      #             "id" => 99451,
      #             "price" => 350,
      #             "quantity" => 2.85714285,
      #             "type" => "BUY"
      #         },
      #         {
      #             "time" => 1409934792,
      #             "id" => 99450,
      #             "price" => 350,
      #             "quantity" => 0.57142857,
      #             "type" => "SELL"
      #         }
      #     ]
      #
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'orderId' => id
      }
      response = self.privateGetExchangeOrder(shallow_extend(request, params))
      return self.parse_order(response)
    end

    def parse_order_status(status)
      statuses = {
        'OPEN' => 'open',
        'PARTIALLY_FILLED' => 'open',
        'EXECUTED' => 'closed',
        'CANCELLED' => 'canceled',
        'PARTIALLY_FILLED_AND_CANCELLED' => 'canceled'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      timestamp = nil
      if order.include?('lastModificationTime')
        timestamp = self.safe_string(order, 'lastModificationTime')
        if timestamp != nil
          if timestamp.index('T')
            timestamp = self.parse8601(timestamp)
          else
            timestamp = self.safe_integer(order, 'lastModificationTime')
          end
        end
      end
      # TODO currently not supported by livecoin
      # trades = self.parse_trades(order['trades'], market, since, limit)
      trades = nil
      status = self.parse_order_status(self.safe_string_2(order, 'status', 'orderStatus'))
      symbol = nil
      if market.nil?
        marketId = self.safe_string(order, 'currencyPair')
        marketId = self.safe_string(order, 'symbol', marketId)
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      type = nil
      side = nil
      if order.include?('type')
        lowercaseType = order['type'].downcase
        orderType = lowercaseType.split('_')
        type = orderType[0]
        side = orderType[1]
      end
      price = self.safe_float(order, 'price')
      # of the next two lines the latter overrides the former, if present in the order structure
      remaining = self.safe_float(order, 'remainingQuantity')
      remaining = self.safe_float(order, 'remaining_quantity', remaining)
      amount = self.safe_float(order, 'quantity', remaining)
      filled = nil
      if remaining != nil
        filled = amount - remaining
      end
      cost = nil
      if filled != nil && price != nil
        cost = filled * price
      end
      feeRate = self.safe_float(order, 'commission_rate')
      feeCost = nil
      if cost != nil && feeRate != nil
        feeCost = cost * feeRate
      end
      feeCurrency = nil
      if market != nil
        symbol = market['symbol']
        feeCurrency = market['quote']
      end
      return {
        'info' => order,
        'id' => order['id'],
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => trades,
        'fee' => {
          'cost' => feeCost,
          'currency' => feeCurrency,
          'rate' => feeRate
        }
      }
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      request = {}
      if symbol != nil
        market = self.market(symbol)
        request['currencyPair'] = market['id']
      end
      if since != nil
        request['issuedFrom'] = (since).to_i
      end
      if limit != nil
        request['endRow'] = limit - 1
      end
      response = self.privateGetExchangeClientOrders(shallow_extend(request, params))
      result = []
      rawOrders = []
      if response['data']
        rawOrders = response['data']
      end
      for i in (0...rawOrders.length)
        order = rawOrders[i]
        result.push(self.parse_order(order, market))
      end
      return self.sort_by(result, 'timestamp')
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      request = {
        'openClosed' => 'OPEN'
      }
      return self.fetch_orders(symbol, since, limit, shallow_extend(request, params))
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      request = {
        'openClosed' => 'CLOSED'
      }
      return self.fetch_orders(symbol, since, limit, shallow_extend(request, params))
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      method = 'privatePostExchange' + self.capitalize(side) + type
      market = self.market(symbol)
      request = {
        'quantity' => self.amount_to_precision(symbol, amount),
        'currencyPair' => market['id']
      }
      if type == 'limit'
        request['price'] = self.price_to_precision(symbol, price)
      end
      response = self.send_wrapper(method, shallow_extend(request, params))
      result = {
        'info' => response,
        'id' => response['orderId'].to_s
      }
      success = self.safe_value(response, 'success')
      if success
        result['status'] = 'open'
      end
      return result
    end

    def cancel_order(id, symbol = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' cancelOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      currencyPair = market['id']
      response = self.privatePostExchangeCancellimit(shallow_extend({
        'orderId' => id,
        'currencyPair' => currencyPair
      }, params))
      message = self.safe_string(response, 'message', self.json(response))
      if response.include?('success')
        if !response['success']
          raise(InvalidOrder, message)
        elsif response.include?('cancelled')
          if response['cancelled']
            return {
              'status' => 'canceled',
              'info' => response
            }
          else
            raise(OrderNotFound, message)
          end
        end
      end
      raise(ExchangeError, self.id + ' cancelOrder failed => ' + self.json(response))
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      # Sometimes the response with be { key => null } for all keys.
      # An example is if you attempt to withdraw more than is allowed when withdrawal fees are considered.
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      wallet = address
      if tag != nil
        wallet += '::' + tag
      end
      request = {
        'amount' => self.decimal_to_precision(amount, TRUNCATE, currency['precision'], DECIMAL_PLACES),
        'currency' => currency['id'],
        'wallet' => wallet
      }
      response = self.privatePostPaymentOutCoin(shallow_extend(request, params))
      id = self.safe_integer(response, 'id')
      if id.nil?
        raise(InsufficientFunds, self.id + ' insufficient funds to cover requested withdrawal amount post fees ' + self.json(response))
      end
      return {
        'info' => response,
        'id' => id
      }
    end

    def parse_transaction(transaction, currency = nil)
      #    {
      #        "id" => "c853093d5aa06df1c92d79c2...",(tx on deposits, address on withdrawals)
      #        "type" => "DEPOSIT",
      #        "date" => 1553186482676,
      #        "amount" => 712.61266,
      #        "fee" => 0,
      #        "fixedCurrency" => "XVG",
      #        "taxCurrency" => "XVG",
      #        "variableAmount" => null,
      #        "variableCurrency" => null,
      #        "external" => "Coin",
      #        "login" => "USERNAME",
      #        "externalKey" => "....87diPBy......3hTtuwUT78Yi",(address on deposits, tx on withdrawals)
      #        "documentId" => 1110662453
      #    },
      code = nil
      txid = nil
      address = nil
      id = self.safe_string(transaction, 'documentId')
      amount = self.safe_float(transaction, 'amount')
      timestamp = self.safe_integer(transaction, 'date')
      type = self.safe_string(transaction, 'type').downcase
      currencyId = self.safe_string(transaction, 'fixedCurrency')
      feeCost = self.safe_float(transaction, 'fee')
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency != nil
        code = currency['code']
      else
        code = self.common_currency_code(currencyId)
      end
      if type == 'withdrawal'
        txid = self.safe_string(transaction, 'externalKey')
        address = self.safe_string(transaction, 'id')
      elsif type == 'deposit'
        address = self.safe_string(transaction, 'externalKey')
        txid = self.safe_string(transaction, 'id')
      end
      status = nil
      if type == 'deposit'
        status = 'ok' # Deposits is not registered until they are in account. Withdrawals are left as nil, not entirely sure about theyre status.
      end
      return {
        'info' => transaction,
        'id' => id,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => nil,
        'status' => status,
        'type' => type,
        'updated' => nil,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => {
          'currency' => code,
          'cost' => feeCost
        }
      }
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      endtime = 2505600000 # 29 days - exchange has maximum 30 days.
      now = self.milliseconds
      request = {
        'types' => 'DEPOSIT',
        'end' => now,
        'start' => (since != nil) ?(since).to_i : now - endtime
      }
      currency = nil
      if code != nil
        currency = self.currency(code)
      end
      if limit != nil
        request['limit'] = limit # default is 100
      end
      response = self.privateGetPaymentHistoryTransactions(shallow_extend(request, params))
      return self.parseTransactions(response, currency, since, limit)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      endtime = 2505600000 # 29 days - exchange has maximum 30 days.
      now = self.milliseconds
      request = {
        'types' => 'WITHDRAWAL',
        'end' => now,
        'start' => (since != nil) ?(since).to_i : now - endtime
      }
      currency = nil
      if code != nil
        currency = self.currency(code)
      end
      if limit != nil
        request['limit'] = limit # default is 100
      end
      if since != nil
        request['start'] = since
      end
      response = self.privateGetPaymentHistoryTransactions(shallow_extend(request, params))
      return self.parseTransactions(response, currency, since, limit)
    end

    def fetch_deposit_address(currency, params = {})
      request = {
        'currency' => currency
      }
      response = self.privateGetPaymentGetAddress(shallow_extend(request, params))
      address = self.safe_string(response, 'wallet')
      tag = nil
      if address.index(':')
        parts = address.split(':')
        address = parts[0]
        tag = parts[2]
      end
      self.check_address(address)
      return {
        'currency' => currency,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + path
      query = self.urlencode(self.keysort(params))
      if method == 'GET'
        if params
          url += '?' + query
        end
      end
      if api == 'private'
        self.check_required_credentials
        if method == 'POST'
          body = query
        end
        signature = self.hmac(self.encode(query), self.encode(self.secret), sha256)
        headers = {
          'Api-Key' => self.apiKey,
          'Sign' => signature.upcase,
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end
      if body[0] == '{'
        if code >= 300
          errorCode = self.safe_string(response, 'errorCode')
          if self.exceptions.include?(errorCode)
            # ExceptionClass = self.exceptions[errorCode]
            # raise(ExceptionClass, self.id + ' ' + body)
            raise new self.exceptions[errorCode]
          else
            raise(ExchangeError, self.id + ' ' + body)
          end
        end
        # returns status code 200 even if success == false
        success = self.safe_value(response, 'success', true)
        if !success
          message = self.safe_string(response, 'message')
          if message != nil
            if message.index('Cannot find order')
              raise(OrderNotFound, self.id + ' ' + body)
            end
          end
          exception = self.safe_string(response, 'exception')
          if exception != nil
            if exception.index('Minimal amount is')
              raise(InvalidOrder, self.id + ' ' + body)
            end
          end
          raise(ExchangeError, self.id + ' ' + body)
        end
      end
    end
  end
end
