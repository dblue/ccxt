# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coinfalcon < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coinfalcon',
        'name' => 'CoinFalcon',
        'countries' => ['GB'],
        'rateLimit' => 1000,
        'version' => 'v1',
        'has' => {
          'fetchTickers' => true,
          'fetchOpenOrders' => true,
          'fetchMyTrades' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/41822275-ed982188-77f5-11e8-92bb-496bcd14ca52.jpg',
          'api' => 'https://coinfalcon.com',
          'www' => 'https://coinfalcon.com',
          'doc' => 'https://docs.coinfalcon.com',
          'fees' => 'https://coinfalcon.com/fees',
          'referral' => 'https://coinfalcon.com/?ref=CFJSVGTUPASB'
        },
        'api' => {
          'public' => {
            'get' => [
              'markets',
              'markets/{market}/orders',
              'markets/{market}/trades'
            ]
          },
          'private' => {
            'get' => [
              'user/accounts',
              'user/orders',
              'user/orders/{id}',
              'user/trades'
            ],
            'post' => [
              'user/orders'
            ],
            'delete' => [
              'user/orders/{id}'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'maker' => 0.0,
            'taker' => 0.002, # tiered fee starts at 0.2%
          }
        },
        'precision' => {
          'amount' => 8,
          'price' => 8
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetMarkets
      markets = response['data']
      result = []
      for i in (0...markets.length)
        market = markets[i]
        baseId, quoteId = market['name'].split('-')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => self.safe_integer(market, 'size_precision'),
          'price' => self.safe_integer(market, 'price_precision')
        }
        result.push({
          'id' => market['name'],
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => nil
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => market
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      if market.nil?
        marketId = self.safe_string(ticker, 'name')
        market = self.safe_value(self.markets_by_id, marketId, market)
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.milliseconds
      last = parse_float(ticker['last_price'])
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => nil,
        'bidVolume' => nil,
        'ask' => nil,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => parse_float(ticker['change_in_24h']),
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => nil,
        'quoteVolume' => parse_float(ticker['volume']),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      tickers = self.fetch_tickers(params)
      return tickers[symbol]
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetMarkets
      tickers = response['data']
      result = {}
      for i in (0...tickers.length)
        ticker = self.parse_ticker(tickers[i])
        symbol = ticker['symbol']
        result[symbol] = ticker
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      response = self.publicGetMarketsMarketOrders(self.shallow_extend({
        'market' => self.market_id(symbol),
        'level' => '3'
      }, params))
      return self.parse_order_book(response['data'], nil, 'bids', 'asks', 'price', 'size')
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(trade['created_at'])
      price = parse_float(trade['price'])
      amount = parse_float(trade['size'])
      symbol = market['symbol']
      cost = parse_float(self.cost_to_precision(symbol, price * amount))
      tradeId = self.safe_string(trade, 'id')
      side = self.safe_string(trade, 'side')
      orderId = self.safe_string(trade, 'order_id')
      fee = nil
      feeCost = self.safe_float(trade, 'fee')
      if feeCost != nil
        feeCurrencyCode = nil
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrencyCode
        }
      end
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => tradeId,
        'order' => orderId,
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'market' => market['id']
      }
      if since != nil
        request['start_time'] = self.iso8601(since)
      end
      if limit != nil
        request['limit'] = limit
      end
      response = self.privateGetUserTrades(self.shallow_extend(request, params))
      return self.parse_trades(response['data'], market, since, limit)
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'market' => market['id']
      }
      if since != nil
        request['since'] = self.iso8601(since)
      end
      response = self.publicGetMarketsMarketTrades(self.shallow_extend(request, params))
      return self.parse_trades(response['data'], market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetUserAccounts(params)
      result = { 'info' => response }
      balances = response['data']
      for i in (0...balances.length)
        balance = balances[i]
        currencyId = self.safe_string(balance, 'currency_code')
        uppercase = currencyId.upcase
        code = self.common_currency_code(uppercase)
        if self.currencies_by_id.include?(uppercase)
          code = self.currencies_by_id[uppercase]['code']
        end
        account = {
          'free' => parse_float(balance['available_balance']),
          'used' => parse_float(balance['hold_balance']),
          'total' => parse_float(balance['balance'])
        }
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def parse_order(order, market = nil)
      if market.nil?
        marketId = self.safe_string(order, 'market')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.parse8601(order['created_at'])
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'size')
      filled = self.safe_float(order, 'size_filled')
      remaining = parse_float(self.amount_to_precision(symbol, amount - filled))
      cost = parse_float(self.price_to_precision(symbol, amount * price))
      # pending, open, partially_filled, fullfilled, canceled
      status = order['status']
      if status == 'fulfilled'
        status = 'closed'
      elsif status == 'canceled'
        status = 'canceled'
      else
        status = 'open'
      end
      type = order['operation_type'].split('_')
      return {
        'id' => self.safe_string(order, 'id'),
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'status' => status,
        'symbol' => symbol,
        'type' => type[0],
        'side' => order['order_type'],
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => nil,
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      # price/size must be string
      amount = self.amount_to_precision(symbol, amount)
      request = {
        'market' => market['id'],
        'size' => amount,
        'order_type' => side
      }
      if type == 'limit'
        price = self.price_to_precision(symbol, price)
        request['price'] = price.to_s
      end
      request['operation_type'] = type + '_order'
      response = self.privatePostUserOrders(self.shallow_extend(request, params))
      order = self.parse_order(response['data'], market)
      id = order['id']
      self.orders[id] = order
      return order
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privateDeleteUserOrdersId(self.shallow_extend({
        'id' => id
      }, params))
      market = self.market(symbol)
      return self.parse_order(response['data'], market)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privateGetUserOrdersId(self.shallow_extend({
        'id' => id
      }, params))
      return self.parse_order(response['data'])
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      if symbol != nil
        request['market'] = self.market_id(symbol)
      end
      if since != nil
        request['since_time'] = self.iso8601(self.milliseconds)
      end
      # TODO => test status=all if it works for closed orders too
      response = self.privateGetUserOrders(self.shallow_extend(request, params))
      return self.parse_orders(response['data'])
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = '/api/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          request += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        if method == 'GET'
          if query
            request += '?' + self.urlencode(query)
          end
        else
          body = self.json(query)
        end
        seconds = self.seconds.to_s
        payload = '|'.join([seconds, method, request])
        if body
          payload += '|' + body
        end
        signature = self.hmac(self.encode(payload), self.encode(self.secret))
        headers = {
          'CF-API-KEY' => self.apiKey,
          'CF-API-TIMESTAMP' => seconds,
          'CF-API-SIGNATURE' => signature,
          'Content-Type' => 'application/json'
        }
      end
      url = self.urls['api'] + request
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if code < 400
        return
      end
      errorClass = self.safe_value({
        '401' => AuthenticationError,
        '429' => DDoSProtection
      }, code, ExchangeError)
      raise(errorClass, body)
    end
  end
end
