# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Braziliex < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'braziliex',
        'name' => 'Braziliex',
        'countries' => ['BR'],
        'rateLimit' => 1000,
        'has' => {
          'fetchCurrencies' => true,
          'fetchTickers' => true,
          'fetchOpenOrders' => true,
          'fetchMyTrades' => true,
          'fetchDepositAddress' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/34703593-c4498674-f504-11e7-8d14-ff8e44fb78c1.jpg',
          'api' => 'https://braziliex.com/api/v1',
          'www' => 'https://braziliex.com/',
          'doc' => 'https://braziliex.com/exchange/api.php',
          'fees' => 'https://braziliex.com/exchange/fees.php',
          'referral' => 'https://braziliex.com/?ref=5FE61AB6F6D67DA885BC98BA27223465'
        },
        'api' => {
          'public' => {
            'get' => [
              'currencies',
              'ticker',
              'ticker/{market}',
              'orderbook/{market}',
              'tradehistory/{market}'
            ]
          },
          'private' => {
            'post' => [
              'balance',
              'complete_balance',
              'open_orders',
              'trade_history',
              'deposit_address',
              'sell',
              'buy',
              'cancel_order'
            ]
          }
        },
        'commonCurrencies' => {
          'EPC' => 'Epacoin',
          'ABC' => 'Anti Bureaucracy Coin'
        },
        'fees' => {
          'trading' => {
            'maker' => 0.005,
            'taker' => 0.005
          }
        },
        'precision' => {
          'amount' => 8,
          'price' => 8
        },
        'options' => {
          'fetchCurrencies' => {
            'expires' => 1000, # 1 second
          }
        }
      })
    end

    def fetch_currencies_from_cache(params = {})
      # self method is now redundant
      # currencies are now fetched before markets
      options = self.safe_value(self.options, 'fetchCurrencies', {})
      timestamp = self.safe_integer(options, 'timestamp')
      expires = self.safe_integer(options, 'expires', 1000)
      now = self.milliseconds
      if (timestamp.nil?) || ((now - timestamp) > expires)
        response = self.publicGetCurrencies(params)
        self.options['fetchCurrencies'] = self.shallow_extend(options, {
          'response' => response,
          'timestamp' => now
        })
      end
      return self.safe_value(self.options['fetchCurrencies'], 'response')
    end

    def fetch_currencies(params = {})
      response = self.fetch_currencies_from_cache(params)
      #
      #     {
      #         brl => {
      #             name => "Real",
      #             withdrawal_txFee =>  0.0075,
      #             txWithdrawalFee =>  9,
      #             MinWithdrawal =>  30,
      #             minConf =>  1,
      #             minDeposit =>  0,
      #             txDepositFee =>  0,
      #             txDepositPercentageFee =>  0,
      #             minAmountTradeFIAT =>  5,
      #             minAmountTradeBTC =>  0.0001,
      #             minAmountTradeUSDT =>  0.0001,
      #             decimal =>  8,
      #             decimal_withdrawal =>  8,
      #             active =>  1,
      #             dev_active =>  1,
      #             under_maintenance =>  0,
      #             order => "010",
      #             is_withdrawal_active =>  1,
      #             is_deposit_active =>  1,
      #             is_token_erc20 =>  0,
      #             is_fiat =>  1,
      #             gateway =>  0,
      #         },
      #         btc => {
      #             name => "Bitcoin",
      #             txWithdrawalMinFee =>  0.000125,
      #             txWithdrawalFee =>  0.00015625,
      #             MinWithdrawal =>  0.0005,
      #             minConf =>  1,
      #             minDeposit =>  0,
      #             txDepositFee =>  0,
      #             txDepositPercentageFee =>  0,
      #             minAmountTradeFIAT =>  5,
      #             minAmountTradeBTC =>  0.0001,
      #             minAmountTradeUSDT =>  0.0001,
      #             decimal =>  8,
      #             decimal_withdrawal =>  8,
      #             active =>  1,
      #             dev_active =>  1,
      #             under_maintenance =>  0,
      #             order => "011",
      #             is_withdrawal_active =>  1,
      #             is_deposit_active =>  1,
      #             is_token_erc20 =>  0,
      #             is_fiat =>  0,
      #             gateway =>  1,
      #         }
      #     }
      #
      self.options['currencies'] = {
        'timestamp' => self.milliseconds,
        'response' => response
      }
      ids = response.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        currency = response[id]
        precision = self.safe_integer(currency, 'decimal')
        uppercase = id.upcase
        code = self.common_currency_code(uppercase)
        active = self.safe_integer(currency, 'active') == 1
        maintenance = self.safe_integer(currency, 'under_maintenance')
        if maintenance != 0
          active = false
        end
        canWithdraw = self.safe_integer(currency, 'is_withdrawal_active') == 1
        canDeposit = self.safe_integer(currency, 'is_deposit_active') == 1
        if !canWithdraw || !canDeposit
          active = false
        end
        result[code] = {
          'id' => id,
          'code' => code,
          'name' => currency['name'],
          'active' => active,
          'precision' => precision,
          'funding' => {
            'withdraw' => {
              'active' => canWithdraw,
              'fee' => self.safe_float(currency, 'txWithdrawalFee')
            },
            'deposit' => {
              'active' => canDeposit,
              'fee' => self.safe_float(currency, 'txDepositFee')
            }
          },
          'limits' => {
            'amount' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'withdraw' => {
              'min' => self.safe_float(currency, 'MinWithdrawal'),
              'max' => 10**precision
            },
            'deposit' => {
              'min' => self.safe_float(currency, 'minDeposit'),
              'max' => nil
            }
          },
          'info' => currency
        }
      end
      return result
    end

    def fetch_markets(params = {})
      currencies = self.fetch_currencies_from_cache(params)
      response = self.publicGetTicker
      #
      #     {
      #         btc_brl => {
      #             active => 1,
      #             market => 'btc_brl',
      #             last => 14648,
      #             percentChange => -0.95,
      #             baseVolume24 => 27.856,
      #             quoteVolume24 => 409328.039,
      #             baseVolume => 27.856,
      #             quoteVolume => 409328.039,
      #             highestBid24 => 14790,
      #             lowestAsk24 => 14450.01,
      #             highestBid => 14450.37,
      #             lowestAsk => 14699.98
      #         },
      #         ...
      #     }
      #
      ids = response.keys
      result = []
      for i in (0...ids.length)
        id = ids[i]
        market = response[id]
        baseId, quoteId = id.split('_')
        uppercaseBaseId = baseId.upcase
        uppercaseQuoteId = quoteId.upcase
        base = self.common_currency_code(uppercaseBaseId)
        quote = self.common_currency_code(uppercaseQuoteId)
        symbol = base + '/' + quote
        baseCurrency = self.safe_value(currencies, baseId, {})
        quoteCurrency = self.safe_value(currencies, quoteId, {})
        quoteIsFiat = self.safe_integer(quoteCurrency, 'is_fiat', 0)
        minCost = nil
        if quoteIsFiat
          minCost = self.safe_float(baseCurrency, 'minAmountTradeFIAT')
        else
          minCost = self.safe_float(baseCurrency, 'minAmountTrade' + uppercaseQuoteId)
        end
        isActive = self.safe_integer(market, 'active')
        active = (isActive == 1)
        precision = {
          'amount' => 8,
          'price' => 8
        }
        result.push({
          'id' => id,
          'symbol' => symbol.upcase,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => 10**precision['amount']
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => 10**precision['price']
            },
            'cost' => {
              'min' => minCost,
              'max' => nil
            }
          },
          'info' => market
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      symbol = market['symbol']
      timestamp = ticker['date']
      ticker = ticker['ticker']
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'highestBid24'),
        'low' => self.safe_float(ticker, 'lowestAsk24'),
        'bid' => self.safe_float(ticker, 'highestBid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'lowestAsk'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => self.safe_float(ticker, 'percentChange'),
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'baseVolume24'),
        'quoteVolume' => self.safe_float(ticker, 'quoteVolume24'),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetTickerMarket(self.shallow_extend({
        'market' => market['id']
      }, params))
      ticker = {
        'date' => self.milliseconds,
        'ticker' => ticker
      }
      return self.parse_ticker(ticker, market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTicker(params)
      result = {}
      timestamp = self.milliseconds
      ids = tickers.keys
      for i in (0...ids.length)
        id = ids[i]
        market = self.markets_by_id[id]
        symbol = market['symbol']
        ticker = {
          'date' => timestamp,
          'ticker' => tickers[id]
        }
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetOrderbookMarket(self.shallow_extend({
        'market' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook, nil, 'bids', 'asks', 'price', 'amount')
    end

    def parse_trade(trade, market = nil)
      timestamp = nil
      if trade.include?('date_exec')
        timestamp = self.parse8601(trade['date_exec'])
      else
        timestamp = self.parse8601(trade['date'])
      end
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      symbol = market['symbol']
      cost = self.safe_float(trade, 'total')
      orderId = self.safe_string(trade, 'order_number')
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => self.safe_string(trade, '_id'),
        'order' => orderId,
        'type' => 'limit',
        'side' => trade['type'],
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      trades = self.publicGetTradehistoryMarket(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privatePostCompleteBalance(params)
      result = { 'info' => balances }
      currencies = balances.keys
      for i in (0...currencies.length)
        id = currencies[i]
        balance = balances[id]
        currency = self.common_currency_code(id)
        account = {
          'free' => parse_float(balance['available']),
          'used' => 0.0,
          'total' => parse_float(balance['total'])
        }
        account['used'] = account['total'] - account['free']
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def parse_order(order, market = nil)
      symbol = nil
      if market.nil?
        marketId = self.safe_string(order, 'market')
        if marketId
          if self.markets_by_id.include?(marketId)
            market = self.markets_by_id[marketId]
          end
        end
      end
      if market
        symbol = market['symbol']
      end
      timestamp = self.safe_value(order, 'timestamp')
      if !timestamp
        timestamp = self.parse8601(order['date'])
      end
      price = self.safe_float(order, 'price')
      cost = self.safe_float(order, 'total', 0.0)
      amount = self.safe_float(order, 'amount')
      filledPercentage = self.safe_float(order, 'progress')
      filled = amount * filledPercentage
      remaining = parse_float(self.amount_to_precision(symbol, amount - filled))
      info = order
      if info.include?('info')
        info = order['info']
      end
      return {
        'id' => order['order_number'],
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => 'open',
        'symbol' => symbol,
        'type' => 'limit',
        'side' => order['type'],
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => self.safe_value(order, 'fee'),
        'info' => info
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      method = 'privatePost' + self.capitalize(side)
      response = self.send_wrapper(method, self.shallow_extend({
        'market' => market['id'],
        # 'price' => self.price_to_precision(symbol, price),
        # 'amount' => self.amount_to_precision(symbol, amount),
        'price' => price,
        'amount' => amount
      }, params))
      success = self.safe_integer(response, 'success')
      if success != 1
        raise(InvalidOrder, self.id + ' ' + self.json(response))
      end
      parts = response['message'].split(' / ')
      parts = parts[1..-1]
      feeParts = parts[5].split(' ')
      order = self.parse_order({
        'timestamp' => self.milliseconds,
        'order_number' => response['order_number'],
        'type' => parts[0].downcase,
        'market' => parts[0].downcase,
        'amount' => parts[2].split(' ')[1],
        'price' => parts[3].split(' ')[1],
        'total' => parts[4].split(' ')[1],
        'fee' => {
          'cost' => parse_float(feeParts[1]),
          'currency' => feeParts[2]
        },
        'progress' => '0.0',
        'info' => response
      }, market)
      id = order['id']
      self.orders[id] = order
      return order
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      result = self.privatePostCancelOrder(self.shallow_extend({
        'order_number' => id,
        'market' => market['id']
      }, params))
      return result
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      orders = self.privatePostOpenOrders(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_orders(orders['order_open'], market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      trades = self.privatePostTradeHistory(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_trades(trades['trade_history'], market, since, limit)
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostDepositAddress(self.shallow_extend({
        'currency' => currency['id']
      }, params))
      address = self.safe_string(response, 'deposit_address')
      self.check_address(address)
      tag = self.safe_string(response, 'payment_id')
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + api
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        url += '/' + self.implode_params(path, params)
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        query = self.shallow_extend({
          'command' => path,
          'nonce' => self.nonce
        }, query)
        body = self.urlencode(query)
        signature = self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        headers = {
          'Content-type' => 'application/x-www-form-urlencoded',
          'Key' => self.apiKey,
          'Sign' => self.decode(signature)
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('success')
        success = self.safe_integer(response, 'success')
        if success == 0
          message = self.safe_string(response, 'message')
          if message == 'Invalid APIKey'
            raise(AuthenticationError, message)
          end
          raise(ExchangeError, message)
        end
      end
      return response
    end
  end
end
