# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Itbit < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'itbit',
        'name' => 'itBit',
        'countries' => ['US'],
        'rateLimit' => 2000,
        'version' => 'v1',
        'has' => {
          'CORS' => true,
          'createMarketOrder' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg',
          'api' => 'https://api.itbit.com',
          'www' => 'https://www.itbit.com',
          'doc' => [
            'https://api.itbit.com/docs',
            'https://www.itbit.com/api'
          ]
        },
        'api' => {
          'public' => {
            'get' => [
              'markets/{symbol}/ticker',
              'markets/{symbol}/order_book',
              'markets/{symbol}/trades'
            ]
          },
          'private' => {
            'get' => [
              'wallets',
              'wallets/{walletId}',
              'wallets/{walletId}/balances/{currencyCode}',
              'wallets/{walletId}/funding_history',
              'wallets/{walletId}/trades',
              'wallets/{walletId}/orders',
              'wallets/{walletId}/orders/{id}'
            ],
            'post' => [
              'wallet_transfers',
              'wallets',
              'wallets/{walletId}/cryptocurrency_deposits',
              'wallets/{walletId}/cryptocurrency_withdrawals',
              'wallets/{walletId}/orders',
              'wire_withdrawal'
            ],
            'delete' => [
              'wallets/{walletId}/orders/{id}'
            ]
          }
        },
        'markets' => {
          'BTC/USD' => { 'id' => 'XBTUSD', 'symbol' => 'BTC/USD', 'base' => 'BTC', 'quote' => 'USD' },
          'BTC/SGD' => { 'id' => 'XBTSGD', 'symbol' => 'BTC/SGD', 'base' => 'BTC', 'quote' => 'SGD' },
          'BTC/EUR' => { 'id' => 'XBTEUR', 'symbol' => 'BTC/EUR', 'base' => 'BTC', 'quote' => 'EUR' },
          'ETH/USD' => { 'id' => 'ETHUSD', 'symbol' => 'ETH/USD', 'base' => 'ETH', 'quote' => 'USD' },
          'ETH/EUR' => { 'id' => 'ETHEUR', 'symbol' => 'ETH/EUR', 'base' => 'ETH', 'quote' => 'EUR' },
          'ETH/SGD' => { 'id' => 'ETHSGD', 'symbol' => 'ETH/SGD', 'base' => 'ETH', 'quote' => 'SGD' }
        },
        'fees' => {
          'trading' => {
            'maker' => -0.03 / 100,
            'taker' => 0.35 / 100
          }
        },
        'commonCurrencies' => {
          'XBT' => 'BTC'
        }
      })
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetMarketsSymbolOrderBook(self.shallow_extend({
        'symbol' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook)
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      ticker = self.publicGetMarketsSymbolTicker(self.shallow_extend({
        'symbol' => self.market_id(symbol)
      }, params))
      serverTimeUTC = self.safe_string(ticker, 'serverTimeUTC')
      if !serverTimeUTC
        raise(ExchangeError, self.id + ' fetchTicker returned a bad response => ' + self.json(ticker))
      end
      timestamp = self.parse8601(serverTimeUTC)
      vwap = self.safe_float(ticker, 'vwap24h')
      baseVolume = self.safe_float(ticker, 'volume24h')
      quoteVolume = nil
      if baseVolume != nil && vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = self.safe_float(ticker, 'lastPrice')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high24h'),
        'low' => self.safe_float(ticker, 'low24h'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => self.safe_float(ticker, 'openToday'),
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #     {
      #         timestamp => "2015-05-22T17:45:34.7570000Z",
      #         matchNumber => "5CR1JEUBBM8J",
      #         price => "351.45000000",
      #         amount => "0.00010000"
      #     }
      #
      # fetchMyTrades(private)
      #
      #     {
      #         "orderId" => "248ffda4-83a0-4033-a5bb-8929d523f59f",
      #         "timestamp" => "2015-05-11T14:48:01.9870000Z",
      #         "instrument" => "XBTUSD",
      #         "direction" => "buy",                      # buy or sell
      #         "currency1" => "XBT",                      # base currency
      #         "currency1Amount" => "0.00010000",         # order amount in base currency
      #         "currency2" => "USD",                      # quote currency
      #         "currency2Amount" => "0.0250530000000000", # order cost in quote currency
      #         "rate" => "250.53000000",
      #         "commissionPaid" => "0.00000000",   # net trade fee paid after using any available rebate balance
      #         "commissionCurrency" => "USD",
      #         "rebatesApplied" => "-0.000125265", # negative values represent amount of rebate balance used for trades removing liquidity from order book positive values represent amount of rebate balance earned from trades adding liquidity to order book
      #         "rebateCurrency" => "USD",
      #         "executionId" => "23132"
      #     }
      #
      id = self.safe_string_2(trade, 'executionId', 'matchNumber')
      timestamp = self.parse8601(self.safe_string(trade, 'timestamp'))
      side = self.safe_string(trade, 'direction')
      orderId = self.safe_string(trade, 'orderId')
      feeCost = self.safe_float(trade, 'commissionPaid')
      feeCurrencyId = self.safe_string(trade, 'commissionCurrency')
      feeCurrency = self.common_currency_code(feeCurrencyId)
      rebatesApplied = self.safe_float(trade, 'rebatesApplied')
      if rebatesApplied != nil
        rebatesApplied = -rebatesApplied
      end
      rebateCurrencyId = self.safe_string(trade, 'rebateCurrency')
      rebateCurrency = self.common_currency_code(rebateCurrencyId)
      price = self.safe_float_2(trade, 'price', 'rate')
      amount = self.safe_float_2(trade, 'currency1Amount', 'amount')
      cost = nil
      if price != nil
        if amount != nil
          cost = price * amount
        end
      end
      symbol = nil
      marketId = self.safe_string(trade, 'instrument')
      if marketId != nil
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        else
          baseId = self.safe_string(trade, 'currency1')
          quoteId = self.safe_string(trade, 'currency2')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
      end
      if symbol.nil?
        if market != nil
          symbol = market['symbol']
        end
      end
      result = {
        'info' => trade,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => orderId,
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost
      }
      if feeCost != nil
        if rebatesApplied != nil
          if feeCurrency == rebateCurrency
            feeCost = self.sum(feeCost, rebatesApplied)
            result['fee'] = {
              'cost' => feeCost,
              'currency' => feeCurrency
            }
          else
            result['fees'] = [
              {
                'cost' => feeCost,
                'currency' => feeCurrency
              },
              {
                'cost' => rebatesApplied,
                'currency' => rebateCurrency
              }
            ]
          end
        else
          result['fee'] = {
            'cost' => feeCost,
            'currency' => feeCurrency
          }
        end
      end
      return result
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      walletId = self.safe_string(params, 'walletId')
      if walletId.nil?
        raise(ExchangeError, self.id + ' fetchMyTrades requires a walletId parameter')
      end
      self.load_markets
      request = {
        'walletId' => walletId
      }
      if since != nil
        request['rangeStart'] = self.ymdhms(since, 'T')
      end
      if limit != nil
        request['perPage'] = limit # default 50, max 50
      end
      response = self.privateGetWalletsWalletIdTrades(self.shallow_extend(request, params))
      #
      #     {
      #         "totalNumberOfRecords" => "2",
      #         "currentPageNumber" => "1",
      #         "latestExecutionId" => "332", # most recent execution at time of response
      #         "recordsPerPage" => "50",
      #         "tradingHistory" => [
      #             {
      #                 "orderId" => "248ffda4-83a0-4033-a5bb-8929d523f59f",
      #                 "timestamp" => "2015-05-11T14:48:01.9870000Z",
      #                 "instrument" => "XBTUSD",
      #                 "direction" => "buy",                      # buy or sell
      #                 "currency1" => "XBT",                      # base currency
      #                 "currency1Amount" => "0.00010000",         # order amount in base currency
      #                 "currency2" => "USD",                      # quote currency
      #                 "currency2Amount" => "0.0250530000000000", # order cost in quote currency
      #                 "rate" => "250.53000000",
      #                 "commissionPaid" => "0.00000000",   # net trade fee paid after using any available rebate balance
      #                 "commissionCurrency" => "USD",
      #                 "rebatesApplied" => "-0.000125265", # negative values represent amount of rebate balance used for trades removing liquidity from order book positive values represent amount of rebate balance earned from trades adding liquidity to order book
      #                 "rebateCurrency" => "USD",
      #                 "executionId" => "23132"
      #             },
      #         ],
      #     }
      #
      trades = self.safe_value(response, 'tradingHistory', [])
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id']
      }
      response = self.publicGetMarketsSymbolTrades(self.shallow_extend(request, params))
      #
      #     {
      #         count => 3,
      #         recentTrades => [
      #             {
      #                 timestamp => "2015-05-22T17:45:34.7570000Z",
      #                 matchNumber => "5CR1JEUBBM8J",
      #                 price => "351.45000000",
      #                 amount => "0.00010000"
      #             },
      #         ]
      #     }
      #
      trades = self.safe_value(response, 'recentTrades', [])
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.fetch_wallets(params)
      balances = response[0]['balances']
      result = { 'info' => response }
      for i in (0...balances.length)
        balance = balances[i]
        currencyId = self.safe_string(balance, 'currency')
        code = self.common_currency_code(currencyId)
        account = {
          'free' => self.safe_float(balance, 'availableBalance'),
          'used' => 0.0,
          'total' => self.safe_float(balance, 'totalBalance')
        }
        account['used'] = account['total'] - account['free']
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_wallets(params = {})
      if !self.uid
        raise(AuthenticationError, self.id + ' fetchWallets requires uid API credential')
      end
      request = {
        'userId' => self.uid
      }
      return self.privateGetWallets(self.shallow_extend(request, params))
    end

    def fetch_wallet(walletId, params = {})
      wallet = {
        'walletId' => walletId
      }
      return self.privateGetWalletsWalletId(self.shallow_extend(wallet, params))
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'status' => 'open'
      }, params))
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'status' => 'filled'
      }, params))
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      walletIdInParams = (params.include?('walletId'))
      if !walletIdInParams
        raise(ExchangeError, self.id + ' fetchOrders requires a walletId parameter')
      end
      walletId = params['walletId']
      response = self.privateGetWalletsWalletIdOrders(self.shallow_extend({
        'walletId' => walletId
      }, params))
      orders = self.parse_orders(response, nil, since, limit)
      return orders
    end

    def parse_order(order, market = nil)
      side = order['side']
      type = order['type']
      symbol = self.markets_by_id[order['instrument']]['symbol']
      timestamp = self.parse8601(order['createdTime'])
      amount = self.safe_float(order, 'amount')
      filled = self.safe_float(order, 'amountFilled')
      remaining = amount - filled
      fee = nil
      price = self.safe_float(order, 'price')
      cost = price * self.safe_float(order, 'volumeWeightedAveragePrice')
      return {
        'id' => order['id'],
        'info' => order,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => order['status'],
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'fee' => fee,
        # 'trades' => self.parse_trades(order['trades'], market)
      }
    end

    def nonce
      return self.milliseconds
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      walletIdInParams = (params.include?('walletId'))
      if !walletIdInParams
        raise(ExchangeError, self.id + ' createOrder requires a walletId parameter')
      end
      amount = amount.to_s
      price = price.to_s
      market = self.market(symbol)
      order = {
        'side' => side,
        'type' => type,
        'currency' => market['id'].gsub(market['quote'], ''),
        'amount' => amount,
        'display' => amount,
        'price' => price,
        'instrument' => market['id']
      }
      response = self.privatePostWalletsWalletIdOrders(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['id']
      }
    end

    def fetch_order(id, symbol = nil, params = {})
      walletIdInParams = (params.include?('walletId'))
      if !walletIdInParams
        raise(ExchangeError, self.id + ' fetchOrder requires a walletId parameter')
      end
      request = { 'id' => id }
      response = self.privateGetWalletsWalletIdOrdersId(self.shallow_extend(request, params))
      return self.parse_order(response)
    end

    def cancel_order(id, symbol = nil, params = {})
      walletIdInParams = (params.include?('walletId'))
      if !walletIdInParams
        raise(ExchangeError, self.id + ' cancelOrder requires a walletId parameter')
      end
      return self.privateDeleteWalletsWalletIdOrdersId(self.shallow_extend({
        'id' => id
      }, params))
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if method == 'GET' && query
        url += '?' + self.urlencode(query)
      end
      if method == 'POST' && query
        body = self.json(query)
      else
        body = ''
      end
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce.to_s
        timestamp = nonce
        auth = [method, url, body, nonce, timestamp]
        message = nonce + self.json(auth).gsub('\\/', '/')
        hash = self.hash(self.encode(message), 'sha256', 'binary')
        binaryUrl = self.encode(url)
        binhash = self.binary_concat(binaryUrl, hash)
        signature = self.hmac(binhash, self.encode(self.secret), 'sha512', 'base64')
        headers = {
          'Authorization' => self.apiKey + ':' + signature,
          'Content-Type' => 'application/json',
          'X-Auth-Timestamp' => timestamp,
          'X-Auth-Nonce' => nonce
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('code')
        raise(ExchangeError, self.id + ' ' + self.json(response))
      end
      return response
    end
  end
end
