# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Xbtce < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'xbtce',
        'name' => 'xBTCe',
        'countries' => ['RU'],
        'rateLimit' => 2000, # responses are cached every 2 seconds
        'version' => 'v1',
        'has' => {
          'CORS' => false,
          'fetchTickers' => true,
          'createMarketOrder' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/28059414-e235970c-662c-11e7-8c3a-08e31f78684b.jpg',
          'api' => 'https://cryptottlivewebapi.xbtce.net:8443/api',
          'www' => 'https://www.xbtce.com',
          'doc' => [
            'https://www.xbtce.com/tradeapi',
            'https://support.xbtce.info/Knowledgebase/Article/View/52/25/xbtce-exchange-api'
          ]
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true,
          'uid' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'currency',
              'currency/{filter}',
              'level2',
              'level2/{filter}',
              'quotehistory/{symbol}/{periodicity}/bars/ask',
              'quotehistory/{symbol}/{periodicity}/bars/bid',
              'quotehistory/{symbol}/level2',
              'quotehistory/{symbol}/ticks',
              'symbol',
              'symbol/{filter}',
              'tick',
              'tick/{filter}',
              'ticker',
              'ticker/{filter}',
              'tradesession'
            ]
          },
          'private' => {
            'get' => [
              'tradeserverinfo',
              'tradesession',
              'currency',
              'currency/{filter}',
              'level2',
              'level2/{filter}',
              'symbol',
              'symbol/{filter}',
              'tick',
              'tick/{filter}',
              'account',
              'asset',
              'asset/{id}',
              'position',
              'position/{id}',
              'trade',
              'trade/{id}',
              'quotehistory/{symbol}/{periodicity}/bars/ask',
              'quotehistory/{symbol}/{periodicity}/bars/ask/info',
              'quotehistory/{symbol}/{periodicity}/bars/bid',
              'quotehistory/{symbol}/{periodicity}/bars/bid/info',
              'quotehistory/{symbol}/level2',
              'quotehistory/{symbol}/level2/info',
              'quotehistory/{symbol}/periodicities',
              'quotehistory/{symbol}/ticks',
              'quotehistory/{symbol}/ticks/info',
              'quotehistory/cache/{symbol}/{periodicity}/bars/ask',
              'quotehistory/cache/{symbol}/{periodicity}/bars/bid',
              'quotehistory/cache/{symbol}/level2',
              'quotehistory/cache/{symbol}/ticks',
              'quotehistory/symbols',
              'quotehistory/version'
            ],
            'post' => [
              'trade',
              'tradehistory'
            ],
            'put' => [
              'trade'
            ],
            'delete' => [
              'trade'
            ]
          }
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.privateGetSymbol
      result = []
      for p in (0...markets.length)
        market = markets[p]
        id = market['Symbol']
        base = market['MarginCurrency']
        quote = market['ProfitCurrency']
        if base == 'DSH'
          base = 'DASH'
        end
        symbol = base + '/' + quote
        symbol = market['IsTradeAllowed'] ? symbol : id
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privateGetAsset
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['Currency']
        uppercase = currency.upcase
        # xbtce names DASH incorrectly as DSH
        if uppercase == 'DSH'
          uppercase = 'DASH'
        end
        account = {
          'free' => balance['FreeAmount'],
          'used' => balance['LockedAmount'],
          'total' => balance['Amount']
        }
        result[uppercase] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      orderbook = self.privateGetLevel2Filter(self.shallow_extend({
        'filter' => market['id']
      }, params))
      orderbook = orderbook[0]
      timestamp = orderbook['Timestamp']
      return self.parse_order_book(orderbook, timestamp, 'Bids', 'Asks', 'Price', 'Volume')
    end

    def parse_ticker(ticker, market = nil)
      timestamp = 0
      last = nil
      if ticker.include?('LastBuyTimestamp')
        if timestamp < ticker['LastBuyTimestamp']
          timestamp = ticker['LastBuyTimestamp']
          last = ticker['LastBuyPrice']
        end
      end
      if ticker.include?('LastSellTimestamp')
        if timestamp < ticker['LastSellTimestamp']
          timestamp = ticker['LastSellTimestamp']
          last = ticker['LastSellPrice']
        end
      end
      if !timestamp
        timestamp = self.milliseconds
      end
      symbol = nil
      if market
        symbol = market['symbol']
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => ticker['DailyBestBuyPrice'],
        'low' => ticker['DailyBestSellPrice'],
        'bid' => ticker['BestBid'],
        'bidVolume' => nil,
        'ask' => ticker['BestAsk'],
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => ticker['DailyTradedTotalVolume'],
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTicker(params)
      tickers = self.index_by(tickers, 'Symbol')
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        market = nil
        symbol = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        else
          base = id[0...3]
          quote = id[3...6]
          if base == 'DSH'
            base = 'DASH'
          end
          if quote == 'DSH'
            quote = 'DASH'
          end
          symbol = base + '/' + quote
        end
        ticker = tickers[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      tickers = self.publicGetTickerFilter(self.shallow_extend({
        'filter' => market['id']
      }, params))
      length = tickers.length
      if length < 1
        raise(ExchangeError, self.id + ' fetchTicker returned empty response, xBTCe public API error')
      end
      tickers = self.index_by(tickers, 'Symbol')
      ticker = tickers[market['id']]
      return self.parse_ticker(ticker, market)
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      # no method for trades?
      return self.privateGetTrade(params)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv['Timestamp'],
        ohlcv['Open'],
        ohlcv['High'],
        ohlcv['Low'],
        ohlcv['Close'],
        ohlcv['Volume']
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      #     minutes = parse_int(timeframe / 60) # 1 minute by default
      #     periodicity = minutes.to_s
      #     self.load_markets
      #     market = self.market(symbol)
      #     if since.nil?
      #         since = self.seconds - 86400 * 7 # last day by defulat
      #     if limit.nil?
      #         limit = 1000 # default
      #     response = self.privateGetQuotehistorySymbolPeriodicityBarsBid(self.shallow_extend({
      #         'symbol' => market['id'],
      #         'periodicity' => periodicity,
      #         'timestamp' => since,
      #         'count' => limit,
      #     }, params))
      #     return self.parse_ohlcvs(response['Bars'], market, timeframe, since, limit)
      raise(NotSupported, self.id + ' fetchOHLCV is disabled by the exchange')
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      response = self.privatePostTrade(self.shallow_extend({
        'pair' => self.market_id(symbol),
        'type' => side,
        'amount' => amount,
        'rate' => price
      }, params))
      return {
        'info' => response,
        'id' => response['Id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privateDeleteTrade(self.shallow_extend({
        'Type' => 'Cancel',
        'Id' => id
      }, params))
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      if !self.apiKey
        raise(AuthenticationError, self.id + ' requires apiKey for all requests, their public API is always busy')
      end
      if !self.uid
        raise(AuthenticationError, self.id + ' requires uid property for authentication and trading, their public API is always busy')
      end
      url = self.urls['api'] + '/' + self.version
      if api == 'public'
        url += '/' + api
      end
      url += '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        headers = { 'Accept-Encoding' => 'gzip, deflate' }
        nonce = self.nonce.to_s
        if method == 'POST'
          if query
            headers['Content-Type'] = 'application/json'
            body = self.json(query)
          else
            url += '?' + self.urlencode(query)
          end
        end
        auth = nonce + self.uid + self.apiKey + method + url
        if body
          auth += body
        end
        signature = self.hmac(self.encode(auth), self.encode(self.secret), 'sha256', 'base64')
        credentials = self.uid + ':' + self.apiKey + ':' + nonce + ':' + self.binary_to_string(signature)
        headers['Authorization'] = 'HMAC ' + credentials
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
