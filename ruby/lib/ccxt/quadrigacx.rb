# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Quadrigacx < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'quadrigacx',
        'name' => 'QuadrigaCX',
        'countries' => ['CA'],
        'rateLimit' => 1000,
        'version' => 'v2',
        'has' => {
          'fetchDepositAddress' => true,
          'fetchTickers' => true,
          'fetchOrder' => true,
          'fetchMyTrades' => true,
          'fetchTransactions' => true,
          'CORS' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766825-98a6d0de-5ee7-11e7-9fa4-38e11a2c6f52.jpg',
          'api' => 'https://api.quadrigacx.com',
          'www' => 'https://www.quadrigacx.com',
          'doc' => 'https://www.quadrigacx.com/api_info',
          'referral' => 'https://www.quadrigacx.com/?ref=laiqgbp6juewva44finhtmrk'
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true,
          'uid' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'order_book',
              'ticker',
              'transactions'
            ]
          },
          'private' => {
            'post' => [
              'balance',
              'bitcoin_deposit_address',
              'bitcoin_withdrawal',
              'bitcoincash_deposit_address',
              'bitcoincash_withdrawal',
              'bitcoingold_deposit_address',
              'bitcoingold_withdrawal',
              'buy',
              'cancel_order',
              'ether_deposit_address',
              'ether_withdrawal',
              'litecoin_deposit_address',
              'litecoin_withdrawal',
              'lookup_order',
              'open_orders',
              'sell',
              'user_transactions'
            ]
          }
        },
        'markets' => {
          'BTC/CAD' => { 'id' => 'btc_cad', 'symbol' => 'BTC/CAD', 'base' => 'BTC', 'quote' => 'CAD', 'baseId' => 'btc', 'quoteId' => 'cad', 'maker' => 0.005, 'taker' => 0.005 },
          'BTC/USD' => { 'id' => 'btc_usd', 'symbol' => 'BTC/USD', 'base' => 'BTC', 'quote' => 'USD', 'baseId' => 'btc', 'quoteId' => 'usd', 'maker' => 0.005, 'taker' => 0.005 },
          'ETH/BTC' => { 'id' => 'eth_btc', 'symbol' => 'ETH/BTC', 'base' => 'ETH', 'quote' => 'BTC', 'baseId' => 'eth', 'quoteId' => 'btc', 'maker' => 0.002, 'taker' => 0.002 },
          'ETH/CAD' => { 'id' => 'eth_cad', 'symbol' => 'ETH/CAD', 'base' => 'ETH', 'quote' => 'CAD', 'baseId' => 'eth', 'quoteId' => 'cad', 'maker' => 0.005, 'taker' => 0.005 },
          'LTC/CAD' => { 'id' => 'ltc_cad', 'symbol' => 'LTC/CAD', 'base' => 'LTC', 'quote' => 'CAD', 'baseId' => 'ltc', 'quoteId' => 'cad', 'maker' => 0.005, 'taker' => 0.005 },
          'LTC/BTC' => { 'id' => 'ltc_btc', 'symbol' => 'LTC/BTC', 'base' => 'LTC', 'quote' => 'BTC', 'baseId' => 'ltc', 'quoteId' => 'btc', 'maker' => 0.005, 'taker' => 0.005 },
          'BCH/CAD' => { 'id' => 'bch_cad', 'symbol' => 'BCH/CAD', 'base' => 'BCH', 'quote' => 'CAD', 'baseId' => 'bch', 'quoteId' => 'cad', 'maker' => 0.005, 'taker' => 0.005 },
          'BCH/BTC' => { 'id' => 'bch_btc', 'symbol' => 'BCH/BTC', 'base' => 'BCH', 'quote' => 'BTC', 'baseId' => 'bch', 'quoteId' => 'btc', 'maker' => 0.005, 'taker' => 0.005 },
          'BSV/CAD' => { 'id' => 'bsv_cad', 'symbol' => 'BSV/CAD', 'base' => 'BSV', 'quote' => 'CAD', 'baseId' => 'bsv', 'quoteId' => 'cad', 'maker' => 0.005, 'taker' => 0.005 },
          'BTG/CAD' => { 'id' => 'btg_cad', 'symbol' => 'BTG/CAD', 'base' => 'BTG', 'quote' => 'CAD', 'baseId' => 'btg', 'quoteId' => 'cad', 'maker' => 0.005, 'taker' => 0.005 },
          'BTG/BTC' => { 'id' => 'btg_btc', 'symbol' => 'BTG/BTC', 'base' => 'BTG', 'quote' => 'BTC', 'baseId' => 'btg', 'quoteId' => 'btc', 'maker' => 0.005, 'taker' => 0.005 }
        },
        'exceptions' => {
          '101' => AuthenticationError,
          '106' => OrderNotFound, # { 'code':106, 'message' => 'Cannot perform request - not found' }
        }
      })
    end

    def fetch_balance(params = {})
      balances = self.privatePostBalance
      result = { 'info' => balances }
      currencyIds = self.currencies_by_id.keys
      for i in (0...currencyIds.length)
        currencyId = currencyIds[i]
        currency = self.currencies_by_id[currencyId]
        code = currency['code']
        result[code] = {
          'free' => self.safe_float(balances, currencyId + '_available'),
          'used' => self.safe_float(balances, currencyId + '_reserved'),
          'total' => self.safe_float(balances, currencyId + '_balance')
        }
      end
      return self.parse_balance(result)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      market = nil
      request = {}
      if symbol != nil
        market = self.market(symbol)
        request['book'] = market['id']
      end
      if limit != nil
        request['limit'] = limit
      end
      response = self.privatePostUserTransactions(self.shallow_extend(request, params))
      trades = self.filter_by(response, 'type', 2)
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_transactions(symbol = nil, since = nil, limit = nil, params = {})
      market = nil
      request = {}
      if symbol != nil
        market = self.market(symbol)
        request['book'] = market['id']
      end
      if limit != nil
        request['limit'] = limit
      end
      response = self.privatePostUserTransactions(self.shallow_extend(request, params))
      user_transactions = self.filter_by_array(response, 'type', [0, 1], false)
      # return user_transactions
      return self.parseTransactions(user_transactions, market, since, limit)
    end

    def parse_transaction(transaction, currency = nil)
      #
      #     {
      #         "btc":"0.99985260",
      #         "method":"Bitcoin",
      #         "fee":"0.00000000",
      #         "type":0,
      #         "datetime":"2018-10-08 05:26:23"
      #     }
      #
      #     {
      #         "btc":"-0.50000000",
      #         "method":"Bitcoin",
      #         "fee":"0.00000000",
      #         "type":1,
      #         "datetime":"2018-08-27 13:50:10"
      #     }
      #
      code = nil
      amount = nil
      omitted = self.omit(transaction, ['datetime', 'type', 'method', 'fee'])
      keys = omitted.keys
      for i in (0...keys.length)
        if self.currencies_by_id.include?(keys[i])
          code = keys[i]
        end
      end
      if code != nil
        amount = self.safe_string(transaction, code)
      end
      timestamp = self.parse8601(self.safe_string(transaction, 'datetime'))
      status = 'ok'
      fee = self.safe_float(transaction, 'fee')
      type = self.safe_integer(transaction, 'type')
      type = (type == 1) ? 'withdrawal' : 'deposit'
      return {
        'info' => transaction,
        'id' => nil,
        'txid' => nil,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => nil,
        'tag' => nil,
        'type' => type,
        'amount' => amount,
        'currency' => code,
        'status' => status,
        'updated' => nil,
        'fee' => {
          'currency' => code,
          'cost' => fee
        }
      }
    end

    def fetch_order(id, symbol = nil, params = {})
      request = {
        'id' => id
      }
      response = self.privatePostLookupOrder(self.shallow_extend(request, params))
      return self.parse_orders(response)
    end

    def parse_order_status(status)
      statuses = {
        '-1' => 'canceled',
        '0' => 'open',
        '1' => 'open',
        '2' => 'closed'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      id = self.safe_string(order, 'id')
      price = self.safe_float(order, 'price')
      amount = nil
      filled = nil
      remaining = self.safe_float(order, 'amount')
      cost = nil
      symbol = nil
      marketId = self.safe_string(order, 'book')
      if self.markets_by_id.include?(marketId)
        market = self.markets_by_id[marketId]
      else
        baseId, quoteId = marketId.split('_')
        base = baseId.upcase
        quote = quoteId.upcase
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
      end
      side = self.safe_string(order, 'type')
      if side == '0'
        side = 'buy'
      else
        side = 'sell'
      end
      status = self.parse_order_status(self.safe_string(order, 'status'))
      timestamp = self.parse8601(self.safe_string(order, 'created'))
      lastTradeTimestamp = self.parse8601(self.safe_string(order, 'updated'))
      type = (price == 0.0) ? 'market' : 'limit'
      if market != nil
        symbol = market['symbol']
      end
      if status == 'closed'
        amount = remaining
        filled = remaining
        remaining = 0
      end
      if (type == 'limit') && (price != nil)
        if filled != nil
          cost = price * filled
        end
      end
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => nil
      }
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      orderbook = self.publicGetOrderBook(self.shallow_extend({
        'book' => self.market_id(symbol)
      }, params))
      timestamp = parse_int(orderbook['timestamp']) * 1000
      return self.parse_order_book(orderbook, timestamp)
    end

    def fetch_tickers(symbols = nil, params = {})
      response = self.publicGetTicker(self.shallow_extend({
        'book' => 'all'
      }, params))
      ids = response.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        symbol = id
        market = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        else
          baseId, quoteId = id.split('_')
          base = baseId.upcase
          quote = quoteId.upcase
          base = self.common_currency_code(base)
          quote = self.common_currency_code(base)
          symbol = base + '/' + quote
          market = {
            'symbol' => symbol
          }
        end
        result[symbol] = self.parse_ticker(response[id], market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTicker(self.shallow_extend({
        'book' => market['id']
      }, params))
      return self.parse_ticker(response, market)
    end

    def parse_ticker(ticker, market = nil)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      timestamp = parse_int(ticker['timestamp']) * 1000
      vwap = self.safe_float(ticker, 'vwap')
      baseVolume = self.safe_float(ticker, 'volume')
      quoteVolume = nil
      if baseVolume != nil && vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #     {"amount":"2.26252009","date":"1541355778","price":"0.03300000","tid":3701722,"side":"sell"}
      #
      # fetchMyTrades(private)
      #
      #     {
      #         "datetime" => "2018-01-01T00:00:00", # date and time
      #         "id" => 123, # unique identifier(only for trades)
      #         "type" => 2, # transaction type(0 - deposit 1 - withdrawal 2 - trade)
      #         "method" => "...", # deposit or withdrawal method
      #         "(minor currency code)" – the minor currency amount
      #         "(major currency code)" – the major currency amount
      #         "order_id" => "...", # a 64 character long hexadecimal string representing the order that was fully or partially filled(only for trades)
      #         "fee" => 123.45, # transaction fee
      #         "rate" => 54.321, # rate per btc(only for trades)
      #     }
      #
      id = self.safe_string_2(trade, 'tid', 'id')
      timestamp = self.parse8601(self.safe_string(trade, 'datetime'))
      if timestamp.nil?
        timestamp = self.safe_integer(trade, 'date')
        if timestamp != nil
          timestamp *= 1000
        end
      end
      symbol = nil
      omitted = self.omit(trade, ['datetime', 'id', 'type', 'method', 'order_id', 'fee', 'rate'])
      keys = omitted.keys
      rate = self.safe_float(trade, 'rate')
      for i in (0...keys.length)
        marketId = keys[i]
        floatValue = self.safe_float(trade, marketId)
        if floatValue == rate
          if self.markets_by_id.include?(marketId)
            market = self.markets_by_id[marketId]
          else
            currencyIds = marketId.split('_')
            numCurrencyIds = currencyIds.length
            if numCurrencyIds == 2
              baseId = currencyIds[0]
              quoteId = currencyIds[1]
              base = baseId.upcase
              quote = quoteId.upcase
              base = self.common_currency_code(base)
              quote = self.common_currency_code(base)
              symbol = base + '/' + quote
            end
          end
        end
      end
      orderId = self.safe_string(trade, 'order_id')
      side = self.safe_string(trade, 'side')
      price = self.safe_float(trade, 'price', rate)
      amount = self.safe_float(trade, 'amount')
      cost = nil
      if market != nil
        symbol = market['symbol']
        baseId = market['baseId']
        quoteId = market['quoteId']
        if amount.nil?
          amount = self.safe_float(trade, baseId)
          if amount != nil
            amount = amount.abs
          end
        end
        cost = self.safe_float(trade, quoteId)
        if cost != nil
          cost = cost.abs
        end
        if side.nil?
          baseValue = self.safe_float(trade, market['baseId'])
          if (baseValue != nil) && (baseValue > 0)
            side = 'buy'
          else
            side = 'sell'
          end
        end
      end
      if cost.nil?
        if price != nil
          if amount != nil
            cost = amount * price
          end
        end
      end
      fee = nil
      feeCost = self.safe_float(trade, 'fee')
      if feeCost != nil
        feeCurrency = nil
        if market != nil
          feeCurrency = (side == 'buy') ? market['base'] : market['quote']
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      return {
        'info' => trade,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => orderId,
        'type' => nil,
        'side' => side,
        'takerOrMaker' => nil,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetTransactions(self.shallow_extend({
        'book' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      method = 'privatePost' + self.capitalize(side)
      order = {
        'amount' => amount,
        'book' => self.market_id(symbol)
      }
      if type == 'limit'
        order['price'] = price
      end
      response = self.send_wrapper(method, self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancelOrder(self.shallow_extend({
        'id' => id
      }, params))
    end

    def fetch_deposit_address(code, params = {})
      method = 'privatePost' + self.get_currency_name(code) + 'DepositAddress'
      response = self.send_wrapper(method, params)
      # [E|e]rror
      if response.include?('rror')
        raise(ExchangeError, self.id + ' ' + response)
      end
      self.check_address(response)
      return {
        'currency' => code,
        'address' => response,
        'tag' => nil,
        'info' => response
      }
    end

    def get_currency_name(code)
      currencies = {
        'ETH' => 'Ether',
        'BTC' => 'Bitcoin',
        'LTC' => 'Litecoin',
        'BCH' => 'Bitcoincash',
        'BTG' => 'Bitcoingold'
      }
      return currencies[code]
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      request = {
        'amount' => amount,
        'address' => address
      }
      method = 'privatePost' + self.get_currency_name(code) + 'Withdrawal'
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => nil
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + path
      if api == 'public'
        url += '?' + self.urlencode(params)
      else
        self.check_required_credentials
        nonce = self.nonce
        request = ''.join([nonce.to_s, self.uid, self.apiKey])
        signature = self.hmac(self.encode(request), self.encode(self.secret))
        query = self.shallow_extend({
          'key' => self.apiKey,
          'nonce' => nonce,
          'signature' => signature
        }, params)
        body = self.json(query)
        headers = {
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(statusCode, statusText, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end
      if (body[0] == '{') || (body[0] == '[')
        error = self.safe_value(response, 'error')
        if error != nil
          #
          # {"error":{"code":101,"message":"Invalid API Code or Invalid Signature"}}
          #
          code = self.safe_string(error, 'code')
          feedback = self.id + ' ' + self.json(response)
          exceptions = self.exceptions
          if exceptions.include?(code)
            raise(exceptions[code], feedback)
          else
            raise(ExchangeError, self.id + ' unknown "error" value => ' + self.json(response))
          end
        end
      end
    end
  end
end
