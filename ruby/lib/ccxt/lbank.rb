# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Lbank < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'lbank',
        'name' => 'LBank',
        'countries' => ['CN'],
        'version' => 'v1',
        'has' => {
          'fetchTickers' => true,
          'fetchOHLCV' => true,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => false, # status 0 API doesn't work
          'fetchClosedOrders' => true
        },
        'timeframes' => {
          '1m' => 'minute1',
          '5m' => 'minute5',
          '15m' => 'minute15',
          '30m' => 'minute30',
          '1h' => 'hour1',
          '2h' => 'hour2',
          '4h' => 'hour4',
          '6h' => 'hour6',
          '8h' => 'hour8',
          '12h' => 'hour12',
          '1d' => 'day1',
          '1w' => 'week1'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg',
          'api' => 'https://api.lbank.info',
          'www' => 'https://www.lbank.info',
          'doc' => 'https://github.com/LBank-exchange/lbank-official-api-docs',
          'fees' => 'https://lbankinfo.zendesk.com/hc/zh-cn/articles/115002295114--%E8%B4%B9%E7%8E%87%E8%AF%B4%E6%98%8E',
          'referral' => 'https://www.lbank.info/sign-up.html?icode=7QCY&lang=en-US'
        },
        'api' => {
          'public' => {
            'get' => [
              'currencyPairs',
              'ticker',
              'depth',
              'trades',
              'kline',
              'accuracy'
            ]
          },
          'private' => {
            'post' => [
              'user_info',
              'create_order',
              'cancel_order',
              'orders_info',
              'orders_info_history',
              'withdraw',
              'withdrawCancel',
              'withdraws',
              'withdrawConfigs'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.1 / 100,
            'taker' => 0.1 / 100
          },
          'funding' => {
            'withdraw' => {
              'BTC' => nil,
              'ZEC' => 0.01,
              'ETH' => 0.01,
              'ETC' => 0.01,
              # 'QTUM' => amount => Math.max(0.01, amount * (0.1 / 100)),
              'VEN' => 10.0,
              'BCH' => 0.0002,
              'SC' => 50.0,
              'BTM' => 20.0,
              'NAS' => 1.0,
              'EOS' => 1.0,
              'XWC' => 5.0,
              'BTS' => 1.0,
              'INK' => 10.0,
              'BOT' => 3.0,
              'YOYOW' => 15.0,
              'TGC' => 10.0,
              'NEO' => 0.0,
              'CMT' => 20.0,
              'SEER' => 2000.0,
              'FIL' => nil,
              'BTG' => nil
            }
          }
        },
        'commonCurrencies' => {
          'VET_ERC20' => 'VEN'
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetAccuracy
      result = []
      for i in (0...markets.length)
        market = markets[i]
        id = market['symbol']
        parts = id.split('_')
        baseId = nil
        quoteId = nil
        numParts = parts.length
        # lbank will return symbols like "vet_erc20_usdt"
        if numParts > 2
          baseId = parts[0] + '_' + parts[1]
          quoteId = parts[2]
        else
          baseId = parts[0]
          quoteId = parts[1]
        end
        base = self.common_currency_code(baseId.upcase)
        quote = self.common_currency_code(quoteId.upcase)
        symbol = base + '/' + quote
        precision = {
          'amount' => self.safe_integer(market, 'quantityAccuracy'),
          'price' => self.safe_integer(market, 'priceAccuracy')
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => nil
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => 10**precision['price']
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => id
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      symbol = nil
      if market.nil?
        marketId = self.safe_string(ticker, 'symbol')
        if self.markets_by_id.include?(marketId)
          market = self.marketsById[marketId]
          symbol = market['symbol']
        else
          parts = marketId.split('_')
          baseId = nil
          quoteId = nil
          numParts = parts.length
          # lbank will return symbols like "vet_erc20_usdt"
          if numParts > 2
            baseId = parts[0] + '_' + parts[1]
            quoteId = parts[2]
          else
            baseId = parts[0]
            quoteId = parts[1]
          end
          base = self.common_currency_code(baseId.upcase)
          quote = self.common_currency_code(quoteId.upcase)
          symbol = base + '/' + quote
        end
      end
      timestamp = self.safe_integer(ticker, 'timestamp')
      info = ticker
      ticker = info['ticker']
      last = self.safe_float(ticker, 'latest')
      percentage = self.safe_float(ticker, 'change')
      relativeChange = percentage / 100
      open = last / self.sum(1, relativeChange)
      change = last - open
      average = self.sum(last, open) / 2
      if market != nil
        symbol = market['symbol']
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => nil,
        'bidVolume' => nil,
        'ask' => nil,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => percentage,
        'average' => average,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => self.safe_float(ticker, 'turnover'),
        'info' => info
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTicker(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_ticker(response, market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTicker(self.shallow_extend({
        'symbol' => 'all'
      }, params))
      result = {}
      for i in (0...tickers.length)
        ticker = self.parse_ticker(tickers[i])
        symbol = ticker['symbol']
        result[symbol] = ticker
      end
      return result
    end

    def fetch_order_book(symbol, limit = 60, params = {})
      self.load_markets
      size = 60
      if limit != nil
        size = Math.min(limit, size)
      end
      response = self.publicGetDepth(self.shallow_extend({
        'symbol' => self.market_id(symbol),
        'size' => size
      }, params))
      return self.parse_order_book(response)
    end

    def parse_trade(trade, market = nil)
      symbol = market['symbol']
      timestamp = parse_int(trade['date_ms'])
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      cost = self.cost_to_precision(symbol, price * amount)
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => self.safe_string(trade, 'tid'),
        'order' => nil,
        'type' => nil,
        'side' => trade['type'],
        'price' => price,
        'amount' => amount,
        'cost' => parse_float(cost),
        'fee' => nil,
        'info' => self.safe_value(trade, 'info', trade)
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'size' => 100
      }
      if since != nil
        request['time'] = parse_int(since)
      end
      if limit != nil
        request['size'] = limit
      end
      response = self.publicGetTrades(self.shallow_extend(request, params))
      return self.parse_trades(response, market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv[0] * 1000,
        ohlcv[1],
        ohlcv[2],
        ohlcv[3],
        ohlcv[4],
        ohlcv[5]
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '5m', since = nil, limit = 1000, params = {})
      self.load_markets
      market = self.market(symbol)
      if since.nil?
        raise(ExchangeError, self.id + ' fetchOHLCV requires a since argument')
      end
      if limit.nil?
        raise(ExchangeError, self.id + ' fetchOHLCV requires a limit argument')
      end
      request = {
        'symbol' => market['id'],
        'type' => self.timeframes[timeframe],
        'size' => limit,
        'time' => parse_int(since / 1000)
      }
      response = self.publicGetKline(self.shallow_extend(request, params))
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostUserInfo(params)
      result = { 'info' => response }
      ids = self.shallow_extend(response['info']['free'], response['info']['freeze']).keys
      for i in (0...ids.length)
        id = ids[i]
        code = id
        if self.currencies_by_id.include?(id)
          code = self.currencies_by_id[id]['code']
        end
        free = self.safe_float(response['info']['free'], id, 0.0)
        used = self.safe_float(response['info']['freeze'], id, 0.0)
        account = {
          'free' => free,
          'used' => used,
          'total' => 0.0
        }
        account['total'] = self.sum(account['free'], account['used'])
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def parse_order_status(status)
      statuses = {
        '-1' => 'cancelled', # cancelled
        '0' => 'open', # not traded
        '1' => 'open', # partial deal
        '2' => 'closed', # complete deal
        '4' => 'closed', # disposal processing
      }
      return self.safe_string(statuses, status)
    end

    def parse_order(order, market = nil)
      symbol = nil
      responseMarket = self.safe_value(self.marketsById, order['symbol'])
      if responseMarket != nil
        symbol = responseMarket['symbol']
      elsif market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'create_time')
      # Limit Order Request Returns => Order Price
      # Market Order Returns => cny amount of market order
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'amount', 0.0)
      filled = self.safe_float(order, 'deal_amount', 0.0)
      av_price = self.safe_float(order, 'avg_price')
      cost = nil
      if av_price != nil
        cost = filled * av_price
      end
      status = self.parse_order_status(self.safe_string(order, 'status'))
      return {
        'id' => self.safe_string(order, 'order_id'),
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => self.safe_string(order, 'order_type'),
        'side' => order['type'],
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => amount - filled,
        'trades' => nil,
        'fee' => nil,
        'info' => self.safe_value(order, 'info', order)
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      order = {
        'symbol' => market['id'],
        'type' => side,
        'amount' => amount
      }
      if type == 'market'
        order['type'] += '_market'
      else
        order['price'] = price
      end
      response = self.privatePostCreateOrder(self.shallow_extend(order, params))
      order = self.omit(order, 'type')
      order['order_id'] = response['order_id']
      order['type'] = side
      order['order_type'] = type
      order['create_time'] = self.milliseconds
      order['info'] = response
      order = self.parse_order(order, market)
      id = order['id']
      self.orders[id] = order
      return order
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostCancelOrder(self.shallow_extend({
        'symbol' => market['id'],
        'order_id' => id
      }, params))
      return response
    end

    def fetch_order(id, symbol = nil, params = {})
      # Id can be a list of ids delimited by a comma
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostOrdersInfo(self.shallow_extend({
        'symbol' => market['id'],
        'order_id' => id
      }, params))
      orders = self.parse_orders(response['orders'], market)
      if orders.length == 1
        return orders[0]
      else
        return orders
      end
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if limit.nil?
        limit = 100
      end
      market = self.market(symbol)
      response = self.privatePostOrdersInfoHistory(self.shallow_extend({
        'symbol' => market['id'],
        'current_page' => 1,
        'page_length' => limit
      }, params))
      return self.parse_orders(response['orders'], nil, since, limit)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, params)
      closed = self.filter_by(orders, 'status', 'closed')
      cancelled = self.filter_by(orders, 'status', 'cancelled') # cancelled orders may be partially filled
      return closed + cancelled
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      # mark and fee are optional params, mark is a note and must be less than 255 characters
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      request = {
        'assetCode' => currency['id'],
        'amount' => amount,
        'account' => address
      }
      if tag != nil
        request['memo'] = tag
      end
      response = self.privatePostWithdraw(self.shallow_extend(request, params))
      return {
        'id' => response['id'],
        'info' => response
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      query = self.omit(params, self.extract_params(path))
      url = self.urls['api'] + '/' + self.version + '/' + self.implode_params(path, params)
      # Every endpoint ends with ".do"
      url += '.do'
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        query = self.keysort(self.shallow_extend({
          'api_key' => self.apiKey
        }, params))
        queryString = self.rawencode(query) + '&secret_key=' + self.secret
        query['sign'] = self.hash(self.encode(queryString)).upcase
        body = self.urlencode(query)
        headers = { 'Content-Type' => 'application/x-www-form-urlencoded' }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      success = self.safe_string(response, 'result')
      if success == 'false'
        errorCode = self.safe_string(response, 'error_code')
        message = self.safe_string({
          '10000' => 'Internal error',
          '10001' => 'The required parameters can not be empty',
          '10002' => 'verification failed',
          '10003' => 'Illegal parameters',
          '10004' => 'User requests are too frequent',
          '10005' => 'Key does not exist',
          '10006' => 'user does not exist',
          '10007' => 'Invalid signature',
          '10008' => 'This currency pair is not supported',
          '10009' => 'Limit orders can not be missing orders and the number of orders',
          '10010' => 'Order price or order quantity must be greater than 0',
          '10011' => 'Market orders can not be missing the amount of the order',
          '10012' => 'market sell orders can not be missing orders',
          '10013' => 'is less than the minimum trading position 0.001',
          '10014' => 'Account number is not enough',
          '10015' => 'The order type is wrong',
          '10016' => 'Account balance is not enough',
          '10017' => 'Abnormal server',
          '10018' => 'order inquiry can not be more than 50 less than one',
          '10019' => 'withdrawal orders can not be more than 3 less than one',
          '10020' => 'less than the minimum amount of the transaction limit of 0.001',
          '10022' => 'Insufficient key authority'
        }, errorCode, self.json(response))
        errorClass = self.safe_value({
          '10002' => AuthenticationError,
          '10004' => DDoSProtection,
          '10005' => AuthenticationError,
          '10006' => AuthenticationError,
          '10007' => AuthenticationError,
          '10009' => InvalidOrder,
          '10010' => InvalidOrder,
          '10011' => InvalidOrder,
          '10012' => InvalidOrder,
          '10013' => InvalidOrder,
          '10014' => InvalidOrder,
          '10015' => InvalidOrder,
          '10016' => InvalidOrder,
          '10022' => AuthenticationError
        }, errorCode, ExchangeError)
        raise(errorClass, message)
      end
      return response
    end
  end
end
