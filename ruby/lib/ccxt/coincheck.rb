# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coincheck < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coincheck',
        'name' => 'coincheck',
        'countries' => ['JP', 'ID'],
        'rateLimit' => 1500,
        'has' => {
          'CORS' => false,
          'fetchOpenOrders' => true,
          'fetchMyTrades' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766464-3b5c3c74-5ed9-11e7-840e-31b32968e1da.jpg',
          'api' => 'https://coincheck.com/api',
          'www' => 'https://coincheck.com',
          'doc' => 'https://coincheck.com/documents/exchange/api',
          'fees' => [
            'https://coincheck.com/exchange/fee',
            'https://coincheck.com/info/fee'
          ]
        },
        'api' => {
          'public' => {
            'get' => [
              'exchange/orders/rate',
              'order_books',
              'rate/{pair}',
              'ticker',
              'trades'
            ]
          },
          'private' => {
            'get' => [
              'accounts',
              'accounts/balance',
              'accounts/leverage_balance',
              'bank_accounts',
              'deposit_money',
              'exchange/orders/opens',
              'exchange/orders/transactions',
              'exchange/orders/transactions_pagination',
              'exchange/leverage/positions',
              'lending/borrows/matches',
              'send_money',
              'withdraws'
            ],
            'post' => [
              'bank_accounts',
              'deposit_money/{id}/fast',
              'exchange/orders',
              'exchange/transfers/to_leverage',
              'exchange/transfers/from_leverage',
              'lending/borrows',
              'lending/borrows/{id}/repay',
              'send_money',
              'withdraws'
            ],
            'delete' => [
              'bank_accounts/{id}',
              'exchange/orders/{id}',
              'withdraws/{id}'
            ]
          }
        },
        'markets' => {
          'BTC/JPY' => { 'id' => 'btc_jpy', 'symbol' => 'BTC/JPY', 'base' => 'BTC', 'quote' => 'JPY', 'baseId' => 'btc', 'quoteId' => 'jpy' }, # the only real pair
          # 'ETH/JPY' => { 'id' => 'eth_jpy', 'symbol' => 'ETH/JPY', 'base' => 'ETH', 'quote' => 'JPY', 'baseId' => 'eth', 'quoteId' => 'jpy' },
          # 'ETC/JPY' => { 'id' => 'etc_jpy', 'symbol' => 'ETC/JPY', 'base' => 'ETC', 'quote' => 'JPY', 'baseId' => 'etc', 'quoteId' => 'jpy' },
          # 'DAO/JPY' => { 'id' => 'dao_jpy', 'symbol' => 'DAO/JPY', 'base' => 'DAO', 'quote' => 'JPY', 'baseId' => 'dao', 'quoteId' => 'jpy' },
          # 'LSK/JPY' => { 'id' => 'lsk_jpy', 'symbol' => 'LSK/JPY', 'base' => 'LSK', 'quote' => 'JPY', 'baseId' => 'lsk', 'quoteId' => 'jpy' },
          # 'FCT/JPY' => { 'id' => 'fct_jpy', 'symbol' => 'FCT/JPY', 'base' => 'FCT', 'quote' => 'JPY', 'baseId' => 'fct', 'quoteId' => 'jpy' },
          # 'XMR/JPY' => { 'id' => 'xmr_jpy', 'symbol' => 'XMR/JPY', 'base' => 'XMR', 'quote' => 'JPY', 'baseId' => 'xmr', 'quoteId' => 'jpy' },
          # 'REP/JPY' => { 'id' => 'rep_jpy', 'symbol' => 'REP/JPY', 'base' => 'REP', 'quote' => 'JPY', 'baseId' => 'rep', 'quoteId' => 'jpy' },
          # 'XRP/JPY' => { 'id' => 'xrp_jpy', 'symbol' => 'XRP/JPY', 'base' => 'XRP', 'quote' => 'JPY', 'baseId' => 'xrp', 'quoteId' => 'jpy' },
          # 'ZEC/JPY' => { 'id' => 'zec_jpy', 'symbol' => 'ZEC/JPY', 'base' => 'ZEC', 'quote' => 'JPY', 'baseId' => 'zec', 'quoteId' => 'jpy' },
          # 'XEM/JPY' => { 'id' => 'xem_jpy', 'symbol' => 'XEM/JPY', 'base' => 'XEM', 'quote' => 'JPY', 'baseId' => 'xem', 'quoteId' => 'jpy' },
          # 'LTC/JPY' => { 'id' => 'ltc_jpy', 'symbol' => 'LTC/JPY', 'base' => 'LTC', 'quote' => 'JPY', 'baseId' => 'ltc', 'quoteId' => 'jpy' },
          # 'DASH/JPY' => { 'id' => 'dash_jpy', 'symbol' => 'DASH/JPY', 'base' => 'DASH', 'quote' => 'JPY', 'baseId' => 'dash', 'quoteId' => 'jpy' },
          # 'ETH/BTC' => { 'id' => 'eth_btc', 'symbol' => 'ETH/BTC', 'base' => 'ETH', 'quote' => 'BTC', 'baseId' => 'eth', 'quoteId' => 'btc' },
          # 'ETC/BTC' => { 'id' => 'etc_btc', 'symbol' => 'ETC/BTC', 'base' => 'ETC', 'quote' => 'BTC', 'baseId' => 'etc', 'quoteId' => 'btc' },
          # 'LSK/BTC' => { 'id' => 'lsk_btc', 'symbol' => 'LSK/BTC', 'base' => 'LSK', 'quote' => 'BTC', 'baseId' => 'lsk', 'quoteId' => 'btc' },
          # 'FCT/BTC' => { 'id' => 'fct_btc', 'symbol' => 'FCT/BTC', 'base' => 'FCT', 'quote' => 'BTC', 'baseId' => 'fct', 'quoteId' => 'btc' },
          # 'XMR/BTC' => { 'id' => 'xmr_btc', 'symbol' => 'XMR/BTC', 'base' => 'XMR', 'quote' => 'BTC', 'baseId' => 'xmr', 'quoteId' => 'btc' },
          # 'REP/BTC' => { 'id' => 'rep_btc', 'symbol' => 'REP/BTC', 'base' => 'REP', 'quote' => 'BTC', 'baseId' => 'rep', 'quoteId' => 'btc' },
          # 'XRP/BTC' => { 'id' => 'xrp_btc', 'symbol' => 'XRP/BTC', 'base' => 'XRP', 'quote' => 'BTC', 'baseId' => 'xrp', 'quoteId' => 'btc' },
          # 'ZEC/BTC' => { 'id' => 'zec_btc', 'symbol' => 'ZEC/BTC', 'base' => 'ZEC', 'quote' => 'BTC', 'baseId' => 'zec', 'quoteId' => 'btc' },
          # 'XEM/BTC' => { 'id' => 'xem_btc', 'symbol' => 'XEM/BTC', 'base' => 'XEM', 'quote' => 'BTC', 'baseId' => 'xem', 'quoteId' => 'btc' },
          # 'LTC/BTC' => { 'id' => 'ltc_btc', 'symbol' => 'LTC/BTC', 'base' => 'LTC', 'quote' => 'BTC', 'baseId' => 'ltc', 'quoteId' => 'btc' },
          # 'DASH/BTC' => { 'id' => 'dash_btc', 'symbol' => 'DASH/BTC', 'base' => 'DASH', 'quote' => 'BTC', 'baseId' => 'dash', 'quoteId' => 'btc' }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0,
            'taker' => 0
          }
        }
      })
    end

    def fetch_balance(params = {})
      balances = self.privateGetAccountsBalance
      result = { 'info' => balances }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        lowercase = currency.downcase
        account = self.account
        if balances.include?(lowercase)
          account['free'] = parse_float(balances[lowercase])
        end
        reserved = lowercase + '_reserved'
        if balances.include?(reserved)
          account['used'] = parse_float(balances[reserved])
        end
        account['total'] = self.sum(account['free'], account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      # Only BTC/JPY is meaningful
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      response = self.privateGetExchangeOrdersOpens(params)
      rawOrders = self.safe_value(response, 'orders', [])
      parsedOrders = self.parse_orders(rawOrders, market, since, limit)
      result = []
      for i in (0...parsedOrders.length)
        result.push(self.shallow_extend(parsedOrders[i], { 'status' => 'open' }))
      end
      return result
    end

    def parse_order(order, market = nil)
      #
      # fetchOpenOrders
      #
      #     {                        id =>  202835,
      #                      order_type => "buy",
      #                            rate =>  26890,
      #                            pair => "btc_jpy",
      #                  pending_amount => "0.5527",
      #       pending_market_buy_amount =>  null,
      #                  stop_loss_rate =>  null,
      #                      created_at => "2015-01-10T05:55:38.000Z" }
      #
      # todo => add formats for fetchOrder, fetchClosedOrders here
      #
      id = self.safe_string(order, 'id')
      side = self.safe_string(order, 'order_type')
      timestamp = self.parse8601(self.safe_string(order, 'created_at'))
      amount = self.safe_float(order, 'pending_amount')
      remaining = self.safe_float(order, 'pending_amount')
      price = self.safe_float(order, 'rate')
      filled = nil
      cost = nil
      if remaining != nil
        if amount != nil
          filled = maximum_wrapper(amount - remaining, 0)
          if price != nil
            cost = filled * price
          end
        end
      end
      status = nil
      marketId = self.safe_string(order, 'pair')
      symbol = nil
      if marketId != nil
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
          symbol = market['symbol']
        else
          baseId, quoteId = marketId.split('_')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
      end
      return {
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'amount' => amount,
        'remaining' => remaining,
        'filled' => filled,
        'side' => side,
        'type' => nil,
        'status' => status,
        'symbol' => symbol,
        'price' => price,
        'cost' => cost,
        'fee' => nil,
        'info' => order
      }
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      if symbol != 'BTC/JPY'
        raise(NotSupported, self.id + ' fetchOrderBook supports BTC/JPY only')
      end
      orderbook = self.publicGetOrderBooks(params)
      return self.parse_order_book(orderbook)
    end

    def fetch_ticker(symbol, params = {})
      if symbol != 'BTC/JPY'
        raise(NotSupported, self.id + ' fetchTicker supports BTC/JPY only')
      end
      ticker = self.publicGetTicker(params)
      timestamp = ticker['timestamp'] * 1000
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'volume'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(self.safe_string(trade, 'created_at'))
      id = self.safe_string(trade, 'id')
      price = self.safe_float(trade, 'rate')
      marketId = self.safe_string(trade, 'pair')
      market = self.safe_value(self.markets_by_id, marketId, market)
      symbol = nil
      baseId = nil
      quoteId = nil
      if marketId != nil
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
          baseId = market['baseId']
          quoteId = market['quoteId']
          symbol = market['symbol']
        else
          ids = marketId.split('_')
          baseId = ids[0]
          quoteId = ids[1]
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
      end
      if symbol.nil?
        if market != nil
          symbol = market['symbol']
        end
      end
      takerOrMaker = nil
      amount = nil
      cost = nil
      side = nil
      fee = nil
      orderId = nil
      if trade.include?('liquidity')
        if self.safe_string(trade, 'liquidity') == 'T'
          takerOrMaker = 'taker'
        elsif self.safe_string(trade, 'liquidity') == 'M'
          takerOrMaker = 'maker'
        end
        funds = self.safe_value(trade, 'funds', {})
        amount = self.safe_float(funds, baseId)
        cost = self.safe_float(funds, quoteId)
        fee = {
          'currency' => self.safe_string(trade, 'fee_currency'),
          'cost' => self.safe_float(trade, 'fee')
        }
        side = self.safe_string(trade, 'side')
        orderId = self.safe_string(trade, 'order_id')
      else
        amount = self.safe_float(trade, 'amount')
        side = self.safe_string(trade, 'order_type')
      end
      if cost.nil?
        if amount != nil
          if price != nil
            cost = amount * price
          end
        end
      end
      return {
        'id' => id,
        'info' => trade,
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'symbol' => symbol,
        'type' => nil,
        'side' => side,
        'order' => orderId,
        'takerOrMaker' => takerOrMaker,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.privateGetExchangeOrdersTransactions(self.shallow_extend({}, params))
      transactions = self.safe_value(response, 'transactions', [])
      return self.parse_trades(transactions, market, since, limit)
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      if symbol != 'BTC/JPY'
        raise(NotSupported, self.id + ' fetchTrades supports BTC/JPY only')
      end
      market = self.market(symbol)
      request = {
        'pair' => market['id']
      }
      if limit != nil
        request['limit'] = limit
      end
      response = self.publicGetTrades(self.shallow_extend(request, params))
      data = self.safe_value(response, 'data', [])
      return self.parse_trades(data, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      order = {
        'pair' => self.market_id(symbol)
      }
      if type == 'market'
        order_type = type + '_' + side
        order['order_type'] = order_type
        prefix = (side == 'buy') ?(order_type + '_') : ''
        order[prefix + 'amount'] = amount
      else
        order['order_type'] = side
        order['rate'] = price
        order['amount'] = amount
      end
      response = self.privatePostExchangeOrders(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privateDeleteExchangeOrdersId({ 'id' => id })
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        queryString = ''
        if method == 'GET'
          if query
            url += '?' + self.urlencode(self.keysort(query))
          end
        else
          if query
            body = self.urlencode(self.keysort(query))
            queryString = body
          end
        end
        auth = nonce + url + queryString
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'ACCESS-KEY' => self.apiKey,
          'ACCESS-NONCE' => nonce,
          'ACCESS-SIGNATURE' => self.hmac(self.encode(auth), self.encode(self.secret))
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if api == 'public'
        return response
      end
      if response.include?('success')
        if response['success']
          return response
        end
      end
      raise(ExchangeError, self.id + ' ' + self.json(response))
    end
  end
end
