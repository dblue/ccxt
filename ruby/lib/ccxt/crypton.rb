# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Crypton < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'crypton',
        'name' => 'Crypton',
        'countries' => ['EU'],
        'rateLimit' => 500,
        'version' => '1',
        'has' => {
          'fetchDepositAddress' => true,
          'fetchMyTrades' => true,
          'fetchOpenOrders' => true,
          'fetchOrder' => true,
          'fetchTicker' => false,
          'fetchTickers' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/41334251-905b5a78-6eed-11e8-91b9-f3aa435078a1.jpg',
          'api' => 'https://api.cryptonbtc.com',
          'www' => 'https://cryptonbtc.com',
          'doc' => 'https://cryptonbtc.docs.apiary.io/',
          'fees' => 'https://help.cryptonbtc.com/hc/en-us/articles/360004089872-Fees'
        },
        'api' => {
          'public' => {
            'get' => [
              'currencies',
              'markets',
              'markets/{id}',
              'markets/{id}/orderbook',
              'markets/{id}/trades',
              'tickers'
            ]
          },
          'private' => {
            'get' => [
              'balances',
              'orders',
              'orders/{id}',
              'fills',
              'deposit_address/{currency}',
              'deposits'
            ],
            'post' => [
              'orders'
            ],
            'delete' => [
              'orders/{id}'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.0020,
            'taker' => 0.0020
          }
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetMarkets
      markets = response['result']
      result = []
      keys = markets.keys
      for i in (0...keys.length)
        id = keys[i]
        market = markets[id]
        baseId = market['base']
        quoteId = market['quote']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => 8,
          'price' => self.precision_from_string(self.safe_string(market, 'priceStep'))
        }
        active = market['enabled']
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'info' => market,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => self.safe_float(market, 'minSize'),
              'max' => nil
            },
            'price' => {
              'min' => self.safe_float(market, 'priceStep'),
              'max' => nil
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privateGetBalances(params)
      result = { 'info' => balances }
      keys = balances.keys
      for i in (0...keys.length)
        id = keys[i]
        currency = self.common_currency_code(id)
        account = self.account
        balance = balances[id]
        total = parse_float(balance['total'])
        free = parse_float(balance['free'])
        used = parse_float(balance['locked'])
        account['total'] = total
        account['free'] = free
        account['used'] = used
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetMarketsIdOrderbook(self.shallow_extend({
        'id' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook)
    end

    def parse_ticker(ticker, market = nil)
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      relativeChange = self.safe_float(ticker, 'change24h', 0.0)
      return {
        'symbol' => symbol,
        'timestamp' => nil,
        'datetime' => nil,
        'high' => nil,
        'low' => nil,
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => relativeChange * 100,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'volume24h'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetTickers(params)
      tickers = response['result']
      keys = tickers.keys
      result = {}
      for i in (0...keys.length)
        id = keys[i]
        ticker = tickers[id]
        market = nil
        symbol = id
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        else
          symbol = self.parse_symbol(id)
        end
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(trade['time'])
      symbol = nil
      if trade.include?('market')
        marketId = trade['market']
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        else
          symbol = self.parse_symbol(marketId)
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      fee = nil
      if trade.include?('fee')
        fee = {
          'cost' => self.safe_float(trade, 'fee'),
          'currency' => self.common_currency_code(trade['feeCurrency'])
        }
      end
      return {
        'id' => trade['id'].to_s,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => nil,
        'side' => trade['side'],
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'size'),
        'order' => self.safe_string(trade, 'orderId'),
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'id' => market['id']
      }
      if limit != nil
        request['limit'] = limit
      end
      response = self.publicGetMarketsIdTrades(self.shallow_extend(request, params))
      return self.parse_trades(response['result'], market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {}
      if limit != nil
        request['limit'] = limit
      end
      response = self.privateGetFills(self.shallow_extend(request, params))
      trades = self.parse_trades(response['result'], market, since, limit)
      return self.filter_by_symbol(trades, symbol)
    end

    def parse_order(order, market = nil)
      id = order['id'].to_s
      status = order['status']
      side = order['side']
      type = order['type']
      symbol = nil
      marketId = order['market']
      if self.markets_by_id.include?(marketId)
        market = self.markets_by_id[marketId]
        symbol = market['symbol']
      else
        symbol = self.parse_symbol(marketId)
      end
      timestamp = self.parse8601(order['createdAt'])
      fee = nil
      if order.include?('fee')
        fee = {
          'cost' => parse_float(order['fee']),
          'currency' => self.common_currency_code(order['feeCurrency'])
        }
      end
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'size')
      filled = self.safe_float(order, 'filledSize')
      remaining = amount - filled
      cost = filled * price
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee
      }
      return result
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'id' => id
      }
      response = self.privateGetOrdersId(self.shallow_extend(request, params))
      return self.parse_order(response['result'])
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      market = nil
      if symbol != nil
        request['market'] = self.market_id(symbol)
      end
      response = self.privateGetOrders(self.shallow_extend(request, params))
      return self.parse_orders(response['result'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      order = {
        'market' => self.market_id(symbol),
        'side' => side,
        'type' => type,
        'size' => self.amount_to_precision(symbol, amount),
        'price' => self.price_to_precision(symbol, price)
      }
      response = self.privatePostOrders(self.shallow_extend(order, params))
      return self.parse_order(response['result'])
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'id' => id
      }
      response = self.privateDeleteOrdersId(self.shallow_extend(request, params))
      return self.parse_order(response['result'])
    end

    def parse_symbol(id)
      base, quote = id.split('-')
      base = self.common_currency_code(base)
      quote = self.common_currency_code(quote)
      return base + '/' + quote
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privateGetDepositAddressCurrency(self.shallow_extend({
        'currency' => currency['id']
      }, params))
      result = response['result']
      address = self.safe_string(result, 'address')
      tag = self.safe_string(result, 'tag')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if method == 'GET'
        if query
          request += '?' + self.urlencode(query)
        end
      end
      url = self.urls['api'] + request
      if api == 'private'
        self.check_required_credentials
        timestamp = self.milliseconds.to_s
        payload = ''
        if method != 'GET'
          if query
            body = self.json(query)
            payload = body
          end
        end
        what = timestamp + method + request + payload
        signature = self.hmac(self.encode(what), self.encode(self.secret), 'sha256')
        headers = {
          'CRYPTON-APIKEY' => self.apiKey,
          'CRYPTON-SIGNATURE' => signature,
          'CRYPTON-TIMESTAMP' => timestamp,
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if body[0] == '{'
        success = self.safe_value(response, 'success')
        if !success
          raise(ExchangeError, self.id + ' ' + body)
        end
      end
    end
  end
end
