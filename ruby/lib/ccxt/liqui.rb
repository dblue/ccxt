# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Liqui < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'liqui',
        'name' => 'Liqui',
        'countries' => ['UA'],
        'rateLimit' => 3000,
        'version' => '3',
        'userAgent' => self.userAgents['chrome'],
        'has' => {
          'CORS' => false,
          'createMarketOrder' => false,
          'fetchOrderBooks' => true,
          'fetchOrder' => true,
          'fetchOrders' => 'emulated',
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => 'emulated',
          'fetchTickers' => true,
          'fetchMyTrades' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27982022-75aea828-63a0-11e7-9511-ca584a8edd74.jpg',
          'api' => {
            'public' => 'https://api.liqui.io/api',
            'private' => 'https://api.liqui.io/tapi'
          },
          'www' => 'https://liqui.io',
          'doc' => 'https://liqui.io/api',
          'fees' => 'https://liqui.io/fee'
        },
        'api' => {
          'public' => {
            'get' => [
              'info',
              'ticker/{pair}',
              'depth/{pair}',
              'trades/{pair}'
            ]
          },
          'private' => {
            'post' => [
              'getInfo',
              'Trade',
              'ActiveOrders',
              'OrderInfo',
              'CancelOrder',
              'TradeHistory',
              'CoinDepositAddress',
              'WithdrawCoin',
              'CreateCoupon',
              'RedeemCoupon'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.001,
            'taker' => 0.0025
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {},
            'deposit' => {}
          }
        },
        'commonCurrencies' => {
          'DSH' => 'DASH'
        },
        'exceptions' => {
          'exact' => {
            '803' => InvalidOrder, # "Count could not be less than 0.001."(selling below minAmount)
            '804' => InvalidOrder, # "Count could not be more than 10000."(buying above maxAmount)
            '805' => InvalidOrder, # "price could not be less than X."(minPrice violation on buy & sell)
            '806' => InvalidOrder, # "price could not be more than X."(maxPrice violation on buy & sell)
            '807' => InvalidOrder, # "cost could not be less than X."(minCost violation on buy & sell)
            '831' => InsufficientFunds, # "Not enougth X to create buy order."(buying with balance.quote < order.cost)
            '832' => InsufficientFunds, # "Not enougth X to create sell order."(selling with balance.base < order.amount)
            '833' => OrderNotFound, # "Order with id X was not found."(cancelling non-existent, closed and cancelled order)
          },
          'broad' => {
            'Invalid pair name' => ExchangeError, # {"success":0,"error":"Invalid pair name => btc_eth"}
            'invalid api key' => AuthenticationError,
            'invalid sign' => AuthenticationError,
            'api key dont have trade permission' => AuthenticationError,
            'invalid parameter' => InvalidOrder,
            'invalid order' => InvalidOrder,
            'Requests too often' => DDoSProtection,
            'not available' => ExchangeNotAvailable,
            'data unavailable' => ExchangeNotAvailable,
            'external service unavailable' => ExchangeNotAvailable
          }
        },
        'options' => {
          'fetchOrderMethod' => 'privatePostOrderInfo',
          'fetchMyTradesMethod' => 'privatePostTradeHistory',
          'cancelOrderMethod' => 'privatePostCancelOrder',
          'fetchTickersMaxLength' => 2048
        }
      })
    end

    def calculate_fee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {})
      market = self.markets[symbol]
      key = 'quote'
      rate = market[takerOrMaker]
      cost = parse_float(self.cost_to_precision(symbol, amount * rate))
      if side == 'sell'
        cost *= price
      else
        key = 'base'
      end
      return {
        'type' => takerOrMaker,
        'currency' => market[key],
        'rate' => rate,
        'cost' => cost
      }
    end

    def fetch_markets(params = {})
      response = self.publicGetInfo
      markets = response['pairs']
      keys = markets.keys
      result = []
      for i in (0...keys.length)
        id = keys[i]
        market = markets[id]
        baseId, quoteId = id.split('_')
        base = baseId.upcase
        quote = quoteId.upcase
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        precision = {
          'amount' => self.safe_integer(market, 'decimal_places'),
          'price' => self.safe_integer(market, 'decimal_places')
        }
        amountLimits = {
          'min' => self.safe_float(market, 'min_amount'),
          'max' => self.safe_float(market, 'max_amount')
        }
        priceLimits = {
          'min' => self.safe_float(market, 'min_price'),
          'max' => self.safe_float(market, 'max_price')
        }
        costLimits = {
          'min' => self.safe_float(market, 'min_total')
        }
        limits = {
          'amount' => amountLimits,
          'price' => priceLimits,
          'cost' => costLimits
        }
        hidden = self.safe_integer(market, 'hidden')
        active = (hidden == 0)
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'taker' => market['fee'] / 100,
          'precision' => precision,
          'limits' => limits,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostGetInfo
      balances = response['return']
      result = { 'info' => balances }
      funds = balances['funds']
      currencies = funds.keys
      for c in (0...currencies.length)
        currency = currencies[c]
        uppercase = currency.upcase
        uppercase = self.common_currency_code(uppercase)
        total = nil
        used = nil
        if balances['open_orders'] == 0
          total = funds[currency]
          used = 0.0
        end
        account = {
          'free' => funds[currency],
          'used' => used,
          'total' => total
        }
        result[uppercase] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'pair' => market['id']
      }
      if limit != nil
        request['limit'] = limit # default = 150, max = 2000
      end
      response = self.publicGetDepthPair(self.shallow_extend(request, params))
      market_id_in_reponse = (response.include?(market['id']))
      if !market_id_in_reponse
        raise(ExchangeError, self.id + ' ' + market['symbol'] + ' order book is empty or not available')
      end
      orderbook = response[market['id']]
      return self.parse_order_book(orderbook)
    end

    def fetch_order_books(symbols = nil, params = {})
      self.load_markets
      ids = nil
      if symbols.nil?
        ids = self.ids.join('-')
        # max URL length is 2083 symbols, including http schema, hostname, tld, etc...
        if ids.length > 2048
          numIds = self.ids.length
          raise(ExchangeError, self.id + ' has ' + numIds.to_s + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks')
        end
      else
        ids = self.market_ids(symbols)
        ids = ids.join('-')
      end
      response = self.publicGetDepthPair(self.shallow_extend({
        'pair' => ids
      }, params))
      result = {}
      ids = response.keys
      for i in (0...ids.length)
        id = ids[i]
        symbol = id
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        end
        result[symbol] = self.parse_order_book(response[id])
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      #
      #   {    high => 0.03497582,
      #         low => 0.03248474,
      #         avg => 0.03373028,
      #         vol => 120.11485715062999,
      #     vol_cur => 3572.24914074,
      #        last => 0.0337611,
      #         buy => 0.0337442,
      #        sell => 0.03377798,
      #     updated => 1537522009          }
      #
      timestamp = ticker['updated'] * 1000
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => self.safe_float(ticker, 'avg'),
        'baseVolume' => self.safe_float(ticker, 'vol_cur'),
        'quoteVolume' => self.safe_float(ticker, 'vol'),
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      ids = self.ids
      if symbols.nil?
        numIds = ids.length
        ids = ids.join('-')
        maxLength = self.safe_integer(self.options, 'fetchTickersMaxLength', 2048)
        # max URL length is 2048 symbols, including http schema, hostname, tld, etc...
        if ids.length > self.options['fetchTickersMaxLength']
          raise(ArgumentsRequired, self.id + ' has ' + numIds.to_s + ' markets exceeding max URL length for self endpoint(' + maxLength.to_s + ' characters), please, specify a list of symbols of interest in the first argument to fetchTickers')
        end
      else
        ids = self.market_ids(symbols)
        ids = ids.join('-')
      end
      tickers = self.publicGetTickerPair(self.shallow_extend({
        'pair' => ids
      }, params))
      result = {}
      keys = tickers.keys
      for k in (0...keys.length)
        id = keys[k]
        ticker = tickers[id]
        symbol = id
        market = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        end
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      tickers = self.fetch_tickers([symbol], params)
      return tickers[symbol]
    end

    def parse_trade(trade, market = nil)
      timestamp = self.safe_integer(trade, 'timestamp')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      side = self.safe_string(trade, 'type')
      if side == 'ask'
        side = 'sell'
      elsif side == 'bid'
        side = 'buy'
      end
      price = self.safe_float_2(trade, 'rate', 'price')
      id = self.safe_string_2(trade, 'trade_id', 'tid')
      order = self.safe_string(trade, self.get_order_id_key)
      if trade.include?('pair')
        marketId = self.safe_string(trade, 'pair')
        market = self.safe_value(self.markets_by_id, marketId, market)
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      amount = self.safe_float(trade, 'amount')
      type = 'limit' # all trades are still limit trades
      takerOrMaker = nil
      fee = nil
      feeCost = self.safe_float(trade, 'commission')
      if feeCost != nil
        feeCurrencyId = self.safe_string(trade, 'commissionCurrency')
        feeCurrencyId = feeCurrencyId.upcase
        feeCurrency = self.safe_value(self.currencies_by_id, feeCurrencyId)
        feeCurrencyCode = nil
        if feeCurrency != nil
          feeCurrencyCode = feeCurrency['code']
        else
          feeCurrencyCode = self.common_currency_code(feeCurrencyId)
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrencyCode
        }
      end
      isYourOrder = self.safe_value(trade, 'is_your_order')
      if isYourOrder != nil
        takerOrMaker = 'taker'
        if isYourOrder
          takerOrMaker = 'maker'
        end
        if fee.nil?
          fee = self.calculate_fee(symbol, type, side, amount, price, takerOrMaker)
        end
      end
      return {
        'id' => id,
        'order' => order,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'takerOrMaker' => takerOrMaker,
        'price' => price,
        'amount' => amount,
        'fee' => fee,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'pair' => market['id']
      }
      if limit != nil
        request['limit'] = limit
      end
      response = self.publicGetTradesPair(self.shallow_extend(request, params))
      if response.is_a?(Array)
        numElements = response.length
        if numElements == 0
          return []
        end
      end
      return self.parse_trades(response[market['id']], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'pair' => market['id'],
        'type' => side,
        'amount' => self.amount_to_precision(symbol, amount),
        'rate' => self.price_to_precision(symbol, price)
      }
      price = parse_float(price)
      amount = parse_float(amount)
      response = self.privatePostTrade(self.shallow_extend(request, params))
      id = nil
      status = 'open'
      filled = 0.0
      remaining = amount
      if response.include?('return')
        id = self.safe_string(response['return'], self.get_order_id_key)
        if id == '0'
          id = self.safe_string(response['return'], 'init_order_id')
          status = 'closed'
        end
        filled = self.safe_float(response['return'], 'received', 0.0)
        remaining = self.safe_float(response['return'], 'remains', amount)
      end
      timestamp = self.milliseconds
      order = {
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => price * filled,
        'amount' => amount,
        'remaining' => remaining,
        'filled' => filled,
        'fee' => nil,
        # 'trades' => self.parse_trades(order['trades'], market)
      }
      self.orders[id] = order
      return self.shallow_extend({ 'info' => response }, order)
    end

    def get_order_id_key
      return 'order_id'
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      request = {}
      idKey = self.get_order_id_key
      request[idKey] = id
      method = self.options['cancelOrderMethod']
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      if self.orders.include?(id)
        self.orders[id]['status'] = 'canceled'
      end
      return response
    end

    def parse_order_status(status)
      statuses = {
        '0' => 'open',
        '1' => 'closed',
        '2' => 'canceled',
        '3' => 'canceled', # or partially-filled and still open? https://github.com/ccxt/ccxt/issues/1594
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      id = order['id'].to_s
      status = self.parse_order_status(self.safe_string(order, 'status'))
      timestamp = parse_int(order['timestamp_created']) * 1000
      symbol = nil
      if market.nil?
        market = self.markets_by_id[order['pair']]
      end
      if market != nil
        symbol = market['symbol']
      end
      remaining = nil
      amount = nil
      price = self.safe_float(order, 'rate')
      filled = nil
      cost = nil
      if order.include?('start_amount')
        amount = self.safe_float(order, 'start_amount')
        remaining = self.safe_float(order, 'amount')
      else
        remaining = self.safe_float(order, 'amount')
        if self.orders.include?(id)
          amount = self.orders[id]['amount']
        end
      end
      if amount != nil
        if remaining != nil
          filled = amount - remaining
          cost = price * filled
        end
      end
      fee = nil
      result = {
        'info' => order,
        'id' => id,
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'type' => 'limit',
        'side' => order['type'],
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'remaining' => remaining,
        'filled' => filled,
        'status' => status,
        'fee' => fee
      }
      return result
    end

    def parse_orders(orders, market = nil, since = nil, limit = nil)
      ids = orders.keys
      result = []
      for i in (0...ids.length)
        id = ids[i]
        order = orders[id]
        extended = self.shallow_extend(order, { 'id' => id })
        result.push(self.parse_order(extended, market))
      end
      return self.filter_by_since_limit(result, since, limit)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = {}
      idKey = self.get_order_id_key
      request[idKey] = parse_int(id)
      method = self.options['fetchOrderMethod']
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      id = id.to_s
      newOrder = self.parse_order(self.shallow_extend({ 'id' => id }, response['return'][id]))
      oldOrder = (self.orders.include?(id)) ? self.orders[id] : {}
      self.orders[id] = self.shallow_extend(oldOrder, newOrder)
      return self.orders[id]
    end

    def update_cached_orders(openOrders, symbol)
      # update local cache with open orders
      # self will add unseen orders and overwrite existing ones
      for j in (0...openOrders.length)
        id = openOrders[j]['id']
        self.orders[id] = openOrders[j]
      end
      openOrdersIndexedById = self.index_by(openOrders, 'id')
      cachedOrderIds = self.orders.keys
      for k in (0...cachedOrderIds.length)
        # match each cached order to an order in the open orders array
        # possible reasons why a cached order may be missing in the open orders array:
        # - order was closed or canceled -> update cache
        # - symbol mismatch(e.g. cached BTC/USDT, fetched ETH/USDT) -> skip
        cachedOrderId = cachedOrderIds[k]
        cachedOrder = self.orders[cachedOrderId]
        if openOrdersIndexedById.include?(!(cachedOrderId))
          # cached order is not in open orders array
          # if we fetched orders by symbol and it doesn't match the cached order -> won't update the cached order
          if symbol != nil && symbol != cachedOrder['symbol']
            next
          end
          # cached order is absent from the list of open orders -> mark the cached order as closed
          if cachedOrder['status'] == 'open'
            cachedOrder = self.shallow_extend(cachedOrder, {
              'status' => 'closed', # likewise it might have been canceled externally(unnoticed by "us")
              'cost' => nil,
              'filled' => cachedOrder['amount'],
              'remaining' => 0.0
            })
            if cachedOrder['cost'].nil?
              if cachedOrder['filled'] != nil
                cachedOrder['cost'] = cachedOrder['filled'] * cachedOrder['price']
              end
            end
            self.orders[cachedOrderId] = cachedOrder
          end
        end
      end
      return self.to_array(self.orders)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      if self.options.include?('fetchOrdersRequiresSymbol')
        if self.options['fetchOrdersRequiresSymbol']
          if symbol.nil?
            raise(ArgumentsRequired, self.id + ' fetchOrders requires a symbol argument')
          end
        end
      end
      self.load_markets
      request = {}
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['pair'] = market['id']
      end
      response = self.privatePostActiveOrders(self.shallow_extend(request, params))
      # liqui etc can only return 'open' orders(i.e. no way to fetch 'closed' orders)
      openOrders = []
      if response.include?('return')
        openOrders = self.parse_orders(response['return'], market)
      end
      allOrders = self.update_cached_orders(openOrders, symbol)
      result = self.filter_by_symbol(allOrders, symbol)
      return self.filter_by_since_limit(result, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, params)
      return self.filter_by(orders, 'status', 'open')
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, params)
      return self.filter_by(orders, 'status', 'closed')
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      # some derived classes use camelcase notation for request fields
      request = {
        # 'from' => 123456789, # trade ID, from which the display starts numerical 0(test result => liqui ignores self field)
        # 'count' => 1000, # the number of trades for display numerical, default = 1000
        # 'from_id' => trade ID, from which the display starts numerical 0
        # 'end_id' => trade ID on which the display ends numerical ∞
        # 'order' => 'ASC', # sorting, default = DESC(test result => liqui ignores self field, most recent trade always goes last)
        # 'since' => 1234567890, # UTC start time, default = 0(test result => liqui ignores self field)
        # 'end' => 1234567890, # UTC end time, default = ∞(test result => liqui ignores self field)
        # 'pair' => 'eth_btc', # default = all markets
      }
      if symbol != nil
        market = self.market(symbol)
        request['pair'] = market['id']
      end
      if limit != nil
        request['count'] = parse_int(limit)
      end
      if since != nil
        request['since'] = parse_int(since / 1000)
      end
      method = self.options['fetchMyTradesMethod']
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      trades = []
      if response.include?('return')
        trades = response['return']
      end
      return self.parse_trades(trades, market, since, limit)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      request = {
        'coinName' => currency['id'],
        'amount' => parse_float(amount),
        'address' => address
      }
      # no docs on the tag, yet...
      if tag != nil
        raise(ExchangeError, self.id + ' withdraw does not support the tag argument yet due to a lack of docs on withdrawing with tag/memo on behalf of the exchange.')
      end
      response = self.privatePostWithdrawCoin(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => response['return']['tId']
      }
    end

    def sign_body_with_secret(body)
      return self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
    end

    def get_version_string
      return '/' + self.version
    end

    def get_private_path(path, params)
      return ''
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api]
      query = self.omit(params, self.extract_params(path))
      if api == 'private'
        url += self.get_private_path(path, params)
        self.check_required_credentials
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({
          'nonce' => nonce,
          'method' => path
        }, query))
        signature = self.sign_body_with_secret(body)
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Key' => self.apiKey,
          'Sign' => signature
        }
      elsif api == 'public'
        url += self.get_version_string + '/' + self.implode_params(path, params)
        if query
          url += '?' + self.urlencode(query)
        end
      else
        url += '/' + self.implode_params(path, params)
        if method == 'GET'
          if query
            url += '?' + self.urlencode(query)
          end
        else
          if query
            body = self.json(query)
            headers = {
              'Content-Type' => 'application/json'
            }
          end
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !self.is_json_encoded_object(body)
        return
      end # fallback to default error handler
      if response.include?('success')
        #
        # 1 - Liqui only returns the integer 'success' key from their private API
        #
        #     { "success" => 1, ... } httpCode == 200
        #     { "success" => 0, ... } httpCode == 200
        #
        # 2 - However, exchanges derived from Liqui, can return non-integers
        #
        #     It can be a numeric string
        #     { "sucesss" => "1", ... }
        #     { "sucesss" => "0", ... }, httpCode >= 200(can be 403, 502, etc)
        #
        #     Or just a string
        #     { "success" => "true", ... }
        #     { "success" => "false", ... }, httpCode >= 200
        #
        #     Or a boolean
        #     { "success" => true, ... }
        #     { "success" => false, ... }, httpCode >= 200
        #
        # 3 - Oversimplified, Python PEP8 forbids comparison operator(==) of different types
        #
        # 4 - We do not want to copy-paste and duplicate the code of self handler to other exchanges derived from Liqui
        #
        # To cover points 1, 2, 3 and 4 combined self handler should work like self:
        #
        success = self.safe_value(response, 'success', false)
        if success.is_a?(String)
          if (success == 'true') || (success == '1')
            success = true
          else
            success = false
          end
        end
        if !success
          code = self.safe_string(response, 'code')
          message = self.safe_string(response, 'error')
          feedback = self.id + ' ' + self.json(response)
          exact = self.exceptions['exact']
          if exact.include?(code)
            raise(exact[code], feedback)
          elsif exact.include?(message)
            raise(exact[message], feedback)
          end
          broad = self.exceptions['broad']
          broadKey = self.findBroadlyMatchedKey(broad, message)
          if broadKey != nil
            raise(broad[broadKey], feedback)
          end
          raise(ExchangeError, feedback) # unknown message
        end
      end
    end
  end
end
