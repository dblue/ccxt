# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coinegg < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coinegg',
        'name' => 'CoinEgg',
        'countries' => ['CN', 'UK'],
        'has' => {
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => 'emulated',
          'fetchMyTrades' => true,
          'fetchTickers' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/36770310-adfa764e-1c5a-11e8-8e09-449daac3d2fb.jpg',
          'api' => {
            'web' => 'https://trade.coinegg.com/web',
            'rest' => 'https://api.coinegg.com/api/v1'
          },
          'www' => 'https://www.coinegg.com',
          'doc' => 'https://www.coinegg.com/explain.api.html',
          'fees' => 'https://www.coinegg.com/fee.html',
          'referral' => 'http://www.coinegg.com/user/register?invite=523218'
        },
        'api' => {
          'web' => {
            'get' => [
              'symbol/ticker?right_coin={quote}',
              '{quote}/trends',
              '{quote}/{base}/order',
              '{quote}/{base}/trades',
              '{quote}/{base}/depth.js'
            ]
          },
          'public' => {
            'get' => [
              'ticker/region/{quote}',
              'depth/region/{quote}',
              'orders/region/{quote}'
            ]
          },
          'private' => {
            'post' => [
              'balance',
              'trade_add/region/{quote}',
              'trade_cancel/region/{quote}',
              'trade_view/region/{quote}',
              'trade_list/region/{quote}'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.1 / 100,
            'taker' => 0.1 / 100
          },
          'funding' => {
            'withdraw' => {
              'BTC' => 0.008,
              'BCH' => 0.002,
              'LTC' => 0.001,
              'ETH' => 0.01,
              'ETC' => 0.01,
              'NEO' => 0,
              'QTUM' => '1%',
              'XRP' => '1%',
              'DOGE' => '1%',
              'LSK' => '1%',
              'XAS' => '1%',
              'BTS' => '1%',
              'GAME' => '1%',
              'GOOC' => '1%',
              'NXT' => '1%',
              'IFC' => '1%',
              'DNC' => '1%',
              'BLK' => '1%',
              'VRC' => '1%',
              'XPM' => '1%',
              'VTC' => '1%',
              'TFC' => '1%',
              'PLC' => '1%',
              'EAC' => '1%',
              'PPC' => '1%',
              'FZ' => '1%',
              'ZET' => '1%',
              'RSS' => '1%',
              'PGC' => '1%',
              'SKT' => '1%',
              'JBC' => '1%',
              'RIO' => '1%',
              'LKC' => '1%',
              'ZCC' => '1%',
              'MCC' => '1%',
              'QEC' => '1%',
              'MET' => '1%',
              'YTC' => '1%',
              'HLB' => '1%',
              'MRYC' => '1%',
              'MTC' => '1%',
              'KTC' => 0
            }
          }
        },
        'exceptions' => {
          '103' => AuthenticationError,
          '104' => AuthenticationError,
          '105' => AuthenticationError,
          '106' => InvalidNonce,
          '200' => InsufficientFunds,
          '201' => InvalidOrder,
          '202' => InvalidOrder,
          '203' => OrderNotFound,
          '402' => DDoSProtection
        },
        'errorMessages' => {
          '100' => 'Required parameters can not be empty',
          '101' => 'Illegal parameter',
          '102' => 'coin does not exist',
          '103' => 'Key does not exist',
          '104' => 'Signature does not match',
          '105' => 'Insufficient permissions',
          '106' => 'Request expired(nonce error)',
          '200' => 'Lack of balance',
          '201' => 'Too small for the number of trading',
          '202' => 'Price must be in 0 - 1000000',
          '203' => 'Order does not exist',
          '204' => 'Pending order amount must be above 0.001 BTC',
          '205' => 'Restrict pending order prices',
          '206' => 'Decimal place error',
          '401' => 'System error',
          '402' => 'Requests are too frequent',
          '403' => 'Non-open API',
          '404' => 'IP restriction does not request the resource',
          '405' => 'Currency transactions are temporarily closed'
        },
        'options' => {
          'quoteIds' => ['btc', 'eth', 'usc', 'usdt']
        },
        'commonCurrencies' => {
          'JBC' => 'JubaoCoin'
        }
      })
    end

    def fetch_markets(params = {})
      quoteIds = self.options['quoteIds']
      result = []
      for b in (0...quoteIds.length)
        quoteId = quoteIds[b]
        response = self.webGetSymbolTickerRightCoinQuote({
          'quote' => quoteId
        })
        tickers = self.safe_value(response, 'data', [])
        for i in (0...tickers.length)
          ticker = tickers[i]
          id = ticker['symbol']
          baseId = id.split('_')[0]
          base = baseId.upcase
          quote = quoteId.upcase
          base = self.common_currency_code(base)
          quote = self.common_currency_code(quote)
          symbol = base + '/' + quote
          precision = {
            'amount' => 8,
            'price' => 8
          }
          result.push({
            'id' => id,
            'symbol' => symbol,
            'base' => base,
            'quote' => quote,
            'baseId' => baseId,
            'quoteId' => quoteId,
            'active' => true,
            'precision' => precision,
            'limits' => {
              'amount' => {
                'min' => 10**-precision['amount'],
                'max' => 10**precision['amount']
              },
              'price' => {
                'min' => 10**-precision['price'],
                'max' => 10**precision['price']
              },
              'cost' => {
                'min' => nil,
                'max' => nil
              }
            },
            'info' => ticker
          })
        end
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      symbol = market['symbol']
      timestamp = self.milliseconds
      last = self.safe_float(ticker, 'last')
      percentage = self.safe_float(ticker, 'change')
      open = nil
      change = nil
      average = nil
      if percentage != nil
        relativeChange = percentage / 100
        open = last / self.sum(1, relativeChange)
        change = last - open
        average = self.sum(last, open) / 2
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => open,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => percentage,
        'average' => average,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => self.safe_float(ticker, 'quoteVol'),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetTickerRegionQuote(self.shallow_extend({
        'coin' => market['baseId'],
        'quote' => market['quoteId']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      orderbook = self.publicGetDepthRegionQuote(self.shallow_extend({
        'coin' => market['baseId'],
        'quote' => market['quoteId']
      }, params))
      return self.parse_order_book(orderbook)
    end

    def parse_trade(trade, market = nil)
      timestamp = parse_int(trade['date']) * 1000
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      symbol = market['symbol']
      cost = self.cost_to_precision(symbol, price * amount)
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => self.safe_string(trade, 'tid'),
        'order' => nil,
        'type' => 'limit',
        'side' => trade['type'],
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      trades = self.publicGetOrdersRegionQuote(self.shallow_extend({
        'coin' => market['baseId'],
        'quote' => market['quoteId']
      }, params))
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostBalance(params)
      result = {}
      balances = self.omit(response['data'], 'uid')
      keys = balances.keys
      for i in (0...keys.length)
        key = keys[i]
        currencyId, accountType = key.split('_')
        code = currencyId
        if self.currencies_by_id.include?(currencyId)
          code = self.currencies_by_id[currencyId]['code']
        end
        if result.include?(!(code))
          result[code] = {
            'free' => nil,
            'used' => nil,
            'total' => nil
          }
        end
        accountType = (accountType == 'lock') ? 'used' : 'free'
        result[code][accountType] = parse_float(balances[key])
      end
      currencies = result.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        result[currency]['total'] = self.sum(result[currency]['free'], result[currency]['used'])
      end
      return self.parse_balance(self.shallow_extend({ 'info' => response }, result))
    end

    def parse_order(order, market = nil)
      symbol = market['symbol']
      timestamp = self.parse8601(order['datetime'])
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'amount_original')
      remaining = self.safe_float(order, 'amount_outstanding')
      filled = amount - remaining
      status = self.safe_string(order, 'status')
      if status == 'cancelled'
        status = 'canceled'
      else
        status = remaining ? 'open' : 'closed'
      end
      info = self.safe_value(order, 'info', order)
      return {
        'id' => self.safe_string(order, 'id'),
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => order['type'],
        'price' => price,
        'cost' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => nil,
        'info' => info
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostTradeAddRegionQuote(self.shallow_extend({
        'coin' => market['baseId'],
        'quote' => market['quoteId'],
        'type' => side,
        'amount' => amount,
        'price' => price
      }, params))
      id = response['id'].to_s
      order = self.parse_order({
        'id' => id,
        'datetime' => self.ymdhms(self.milliseconds),
        'amount_original' => amount,
        'amount_outstanding' => amount,
        'price' => price,
        'type' => side,
        'info' => response
      }, market)
      self.orders[id] = order
      return order
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostTradeCancelRegionQuote(self.shallow_extend({
        'id' => id,
        'coin' => market['baseId'],
        'quote' => market['quoteId']
      }, params))
      return response
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostTradeViewRegionQuote(self.shallow_extend({
        'id' => id,
        'coin' => market['baseId'],
        'quote' => market['quoteId']
      }, params))
      return self.parse_order(response['data'], market)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'coin' => market['baseId'],
        'quote' => market['quoteId']
      }
      if since != nil
        request['since'] = since / 1000
      end
      orders = self.privatePostTradeListRegionQuote(self.shallow_extend(request, params))
      return self.parse_orders(orders['data'], market, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      result = self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'type' => 'open'
      }, params))
      return result
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      apiType = 'rest'
      if api == 'web'
        apiType = api
      end
      url = self.urls['api'][apiType] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public' || api == 'web'
        if query.size > 0
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        query = self.urlencode(self.shallow_extend({
          'key' => self.apiKey,
          'nonce' => self.nonce
        }, query))
        secret = self.hash(self.encode(self.secret))
        signature = self.hmac(self.encode(query), self.encode(secret))
        query += '&' + 'signature=' + signature
        if method == 'GET'
          url += '?' + query
        else
          headers = {
            'Content-type' => 'application/x-www-form-urlencoded'
          }
          body = query
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      # checks against error codes
      if !body.is_a?(String)
        return
      end
      if body.length == 0
        return
      end
      if body[0] != '{'
        return
      end
      # private endpoints return the following structure:
      # {"result":true,"data":{...}} - success
      # {"result":false,"code":"103"} - failure
      # {"code":0,"msg":"Suceess","data":{"uid":"2716039","btc_balance":"0.00000000","btc_lock":"0.00000000","xrp_balance":"0.00000000","xrp_lock":"0.00000000"}}
      result = self.safe_value(response, 'result')
      if result.nil?
      # public endpoint ← self comment left here by the contributor, in fact a missing result does not necessarily mean a public endpoint...
      # we should just check the code and don't rely on the result at all here...
        return
      end
      if result == true
      # success
        return
      end
      errorCode = self.safe_string(response, 'code')
      errorMessages = self.errorMessages
      message = self.safe_string(errorMessages, errorCode, 'Unknown Error')
      if self.exceptions.include?(errorCode)
        raise(self.exceptions[errorCode], self.id + ' ' + message)
      else
        raise(ExchangeError, self.id + ' ' + message)
      end
    end
  end
end
