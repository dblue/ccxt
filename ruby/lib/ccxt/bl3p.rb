# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bl3p < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bl3p',
        'name' => 'BL3P',
        'countries' => ['NL', 'EU'], # Netherlands, EU
        'rateLimit' => 1000,
        'version' => '1',
        'comment' => 'An exchange market by BitonicNL',
        'has' => {
          'CORS' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg',
          'api' => 'https://api.bl3p.eu',
          'www' => [
            'https://bl3p.eu',
            'https://bitonic.nl'
          ],
          'doc' => [
            'https://github.com/BitonicNL/bl3p-api/tree/master/docs',
            'https://bl3p.eu/api',
            'https://bitonic.nl/en/api'
          ]
        },
        'api' => {
          'public' => {
            'get' => [
              '{market}/ticker',
              '{market}/orderbook',
              '{market}/trades'
            ]
          },
          'private' => {
            'post' => [
              '{market}/money/depth/full',
              '{market}/money/order/add',
              '{market}/money/order/cancel',
              '{market}/money/order/result',
              '{market}/money/orders',
              '{market}/money/orders/history',
              '{market}/money/trades/fetch',
              'GENMKT/money/info',
              'GENMKT/money/deposit_address',
              'GENMKT/money/new_deposit_address',
              'GENMKT/money/wallet/history',
              'GENMKT/money/withdraw'
            ]
          }
        },
        'markets' => {
          'BTC/EUR' => { 'id' => 'BTCEUR', 'symbol' => 'BTC/EUR', 'base' => 'BTC', 'quote' => 'EUR', 'maker' => 0.0025, 'taker' => 0.0025 },
          'LTC/EUR' => { 'id' => 'LTCEUR', 'symbol' => 'LTC/EUR', 'base' => 'LTC', 'quote' => 'EUR', 'maker' => 0.0025, 'taker' => 0.0025 }
        }
      })
    end

    def fetch_balance(params = {})
      response = self.privatePostGENMKTMoneyInfo
      data = response['data']
      balance = data['wallets']
      result = { 'info' => data }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        account = self.account
        if balance.include?(currency)
          if balance[currency].include?('available')
            account['free'] = parse_float(balance[currency]['available']['value'])
          end
        end
        if balance.include?(currency)
          if balance[currency].include?('balance')
            account['total'] = parse_float(balance[currency]['balance']['value'])
          end
        end
        if account['total']
          if account['free']
            account['used'] = account['total'] - account['free']
          end
        end
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def parse_bid_ask(bidask, priceKey = 0, amountKey = 0)
      return [
        bidask[priceKey] / 100000.0,
        bidask[amountKey] / 100000000.0
      ]
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetMarketOrderbook(self.shallow_extend({
        'market' => market['id']
      }, params))
      orderbook = response['data']
      return self.parse_order_book(orderbook, nil, 'bids', 'asks', 'price_int', 'amount_int')
    end

    def fetch_ticker(symbol, params = {})
      ticker = self.publicGetMarketTicker(self.shallow_extend({
        'market' => self.market_id(symbol)
      }, params))
      timestamp = ticker['timestamp'] * 1000
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => parse_float(ticker['volume']['24h']),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def parse_trade(trade, market)
      return {
        'id' => trade['trade_id'].to_s,
        'timestamp' => trade['date'],
        'datetime' => self.iso8601(trade['date']),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => nil,
        'price' => trade['price_int'] / 100000.0,
        'amount' => trade['amount_int'] / 100000000.0,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetMarketTrades(self.shallow_extend({
        'market' => market['id']
      }, params))
      result = self.parse_trades(response['data']['trades'], market, since, limit)
      return result
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      market = self.market(symbol)
      order = {
        'market' => market['id'],
        'amount_int' => parse_int(amount * 100000000),
        'fee_currency' => market['quote'],
        'type' => (side == 'buy') ? 'bid' : 'ask'
      }
      if type == 'limit'
        order['price_int'] = parse_int(price * 100000.0)
      end
      response = self.privatePostMarketMoneyOrderAdd(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['data']['order_id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostMarketMoneyOrderCancel({ 'order_id' => id })
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = self.implode_params(path, params)
      url = self.urls['api'] + '/' + self.version + '/' + request
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({ 'nonce' => nonce }, query))
        secret = Base64.decode64(self.secret)
        # eslint-disable-next-line quotes
        auth = request + "\0" + body
        signature = self.hmac(self.encode(auth), secret, 'sha512', 'base64')
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Rest-Key' => self.apiKey,
          'Rest-Sign' => self.decode(signature)
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
