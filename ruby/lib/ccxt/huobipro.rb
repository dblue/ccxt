# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Huobipro < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'huobipro',
        'name' => 'Huobi Pro',
        'countries' => ['CN'],
        'rateLimit' => 2000,
        'userAgent' => self.userAgents['chrome39'],
        'version' => 'v1',
        'accounts' => nil,
        'accountsById' => nil,
        'hostname' => 'api.huobi.pro',
        'has' => {
          'CORS' => false,
          'fetchTickers' => true,
          'fetchDepositAddress' => true,
          'fetchOHLCV' => true,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchTradingLimits' => true,
          'fetchMyTrades' => true,
          'withdraw' => true,
          'fetchCurrencies' => true,
          'fetchDeposits' => true,
          'fetchWithdrawals' => true
        },
        'timeframes' => {
          '1m' => '1min',
          '5m' => '5min',
          '15m' => '15min',
          '30m' => '30min',
          '1h' => '60min',
          '1d' => '1day',
          '1w' => '1week',
          '1M' => '1mon',
          '1y' => '1year'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
          'api' => {
            'market' => 'https://api.huobi.pro',
            'public' => 'https://api.huobi.pro',
            'private' => 'https://api.huobi.pro',
            'zendesk' => 'https://huobiglobal.zendesk.com/hc/en-us/articles'
          },
          'www' => 'https://www.huobi.pro',
          'referral' => 'https://www.huobi.br.com/en-us/topic/invited/?invite_code=rwrd3',
          'doc' => 'https://github.com/huobiapi/API_Docs/wiki/REST_api_reference',
          'fees' => 'https://www.huobi.pro/about/fee/'
        },
        'api' => {
          'zendesk' => {
            'get' => [
              '360000400491-Trade-Limits'
            ]
          },
          'market' => {
            'get' => [
              'history/kline', # 获取K线数据
              'detail/merged', # 获取聚合行情(Ticker)
              'depth', # 获取 Market Depth 数据
              'trade', # 获取 Trade Detail 数据
              'history/trade', # 批量获取最近的交易记录
              'detail', # 获取 Market Detail 24小时成交量数据
              'tickers'
            ]
          },
          'public' => {
            'get' => [
              'common/symbols', # 查询系统支持的所有交易对
              'common/currencys', # 查询系统支持的所有币种
              'common/timestamp', # 查询系统当前时间
              'common/exchange', # order limits
              'settings/currencys', # ?language=en-US
            ]
          },
          'private' => {
            'get' => [
              'account/accounts', # 查询当前用户的所有账户(即account-id)
              'account/accounts/{id}/balance', # 查询指定账户的余额
              'order/orders/{id}', # 查询某个订单详情
              'order/orders/{id}/matchresults', # 查询某个订单的成交明细
              'order/orders', # 查询当前委托、历史委托
              'order/matchresults', # 查询当前成交、历史成交
              'dw/withdraw-virtual/addresses', # 查询虚拟币提现地址
              'dw/deposit-virtual/addresses',
              'dw/deposit-virtual/sharedAddressWithTag', # https://github.com/ccxt/ccxt/issues/4851
              'query/deposit-withdraw',
              'margin/loan-orders', # 借贷订单
              'margin/accounts/balance', # 借贷账户详情
              'points/actions',
              'points/orders',
              'subuser/aggregate-balance'
            ],
            'post' => [
              'order/orders/place', # 创建并执行一个新订单(一步下单， 推荐使用)
              'order/orders', # 创建一个新的订单请求 （仅创建订单，不执行下单）
              'order/orders/{id}/place', # 执行一个订单 （仅执行已创建的订单）
              'order/orders/{id}/submitcancel', # 申请撤销一个订单请求
              'order/orders/batchcancel', # 批量撤销订单
              'dw/balance/transfer', # 资产划转
              'dw/withdraw/api/create', # 申请提现虚拟币
              'dw/withdraw-virtual/create', # 申请提现虚拟币
              'dw/withdraw-virtual/{id}/place', # 确认申请虚拟币提现
              'dw/withdraw-virtual/{id}/cancel', # 申请取消提现虚拟币
              'dw/transfer-in/margin', # 现货账户划入至借贷账户
              'dw/transfer-out/margin', # 借贷账户划出至现货账户
              'margin/orders', # 申请借贷
              'margin/orders/{id}/repay', # 归还借贷
              'subuser/transfer'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.002,
            'taker' => 0.002
          }
        },
        'exceptions' => {
          'gateway-internal-error' => ExchangeNotAvailable, # {"status":"error","err-code":"gateway-internal-error","err-msg":"Failed to load data. Try again later.","data":null}
          'account-frozen-balance-insufficient-error' => InsufficientFunds, # {"status":"error","err-code":"account-frozen-balance-insufficient-error","err-msg":"trade account balance is not enough, left => `0.0027`","data":null}
          'invalid-amount' => InvalidOrder, # eg "Paramemter `amount` is invalid."
          'order-limitorder-amount-min-error' => InvalidOrder, # limit order amount error, min => `0.001`
          'order-marketorder-amount-min-error' => InvalidOrder, # market order amount error, min => `0.01`
          'order-limitorder-price-min-error' => InvalidOrder, # limit order price error
          'order-limitorder-price-max-error' => InvalidOrder, # limit order price error
          'order-orderstate-error' => OrderNotFound, # canceling an already canceled order
          'order-queryorder-invalid' => OrderNotFound, # querying a non-existent order
          'order-update-error' => ExchangeNotAvailable, # undocumented error
          'api-signature-check-failed' => AuthenticationError,
          'api-signature-not-valid' => AuthenticationError, # {"status":"error","err-code":"api-signature-not-valid","err-msg":"Signature not valid => Incorrect Access key [Access key错误]","data":null}
        },
        'options' => {
          'createMarketBuyOrderRequiresPrice' => true,
          'fetchMarketsMethod' => 'publicGetCommonSymbols',
          'fetchBalanceMethod' => 'privateGetAccountAccountsIdBalance',
          'createOrderMethod' => 'privatePostOrderOrdersPlace',
          'language' => 'en-US'
        },
        'commonCurrencies' => {
          'HOT' => 'Hydro Protocol', # conflict with HOT(Holo) https://github.com/ccxt/ccxt/issues/4929
        }
      })
    end

    def fetch_trading_limits(symbols = nil, params = {})
      # self method should not be called directly, use loadTradingLimits instead
      #  by default it will try load withdrawal fees of all currencies(with separate requests)
      #  however if you define symbols = ['ETH/BTC', 'LTC/BTC'] in args it will only load those
      self.load_markets
      if symbols.nil?
        symbols = self.symbols
      end
      result = {}
      for i in (0...symbols.length)
        symbol = symbols[i]
        result[symbol] = self.fetch_trading_limits_by_id(self.market_id(symbol), params)
      end
      return result
    end

    def fetch_trading_limits_by_id(id, params = {})
      request = {
        'symbol' => id
      }
      response = self.publicGetCommonExchange(self.shallow_extend(request, params))
      #
      #     { status =>   "ok",
      #         data => {                                  symbol => "aidocbtc",
      #                              'buy-limit-must-less-than' =>  1.1,
      #                          'sell-limit-must-greater-than' =>  0.9,
      #                         'limit-order-must-greater-than' =>  1,
      #                            'limit-order-must-less-than' =>  5000000,
      #                    'market-buy-order-must-greater-than' =>  0.0001,
      #                       'market-buy-order-must-less-than' =>  100,
      #                   'market-sell-order-must-greater-than' =>  1,
      #                      'market-sell-order-must-less-than' =>  500000,
      #                       'circuit-break-when-greater-than' =>  10000,
      #                          'circuit-break-when-less-than' =>  10,
      #                 'market-sell-order-rate-must-less-than' =>  0.1,
      #                  'market-buy-order-rate-must-less-than' =>  0.1        } }
      #
      return self.parse_trading_limits(self.safe_value(response, 'data', {}))
    end

    def parse_trading_limits(limits, symbol = nil, params = {})
      #
      #   {                                  symbol => "aidocbtc",
      #                  'buy-limit-must-less-than' =>  1.1,
      #              'sell-limit-must-greater-than' =>  0.9,
      #             'limit-order-must-greater-than' =>  1,
      #                'limit-order-must-less-than' =>  5000000,
      #        'market-buy-order-must-greater-than' =>  0.0001,
      #           'market-buy-order-must-less-than' =>  100,
      #       'market-sell-order-must-greater-than' =>  1,
      #          'market-sell-order-must-less-than' =>  500000,
      #           'circuit-break-when-greater-than' =>  10000,
      #              'circuit-break-when-less-than' =>  10,
      #     'market-sell-order-rate-must-less-than' =>  0.1,
      #      'market-buy-order-rate-must-less-than' =>  0.1        }
      #
      return {
        'info' => limits,
        'limits' => {
          'amount' => {
            'min' => self.safe_float(limits, 'limit-order-must-greater-than'),
            'max' => self.safe_float(limits, 'limit-order-must-less-than')
          }
        }
      }
    end

    def fetch_markets(params = {})
      method = self.options['fetchMarketsMethod']
      response = self.send_wrapper(method)
      markets = response['data']
      numMarkets = markets.length
      if numMarkets < 1
        raise(ExchangeError, self.id + ' publicGetCommonSymbols returned empty response => ' + self.json(markets))
      end
      result = []
      for i in (0...markets.length)
        market = markets[i]
        baseId = market['base-currency']
        quoteId = market['quote-currency']
        base = baseId.upcase
        quote = quoteId.upcase
        id = baseId + quoteId
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        precision = {
          'amount' => market['amount-precision'],
          'price' => market['price-precision']
        }
        maker = (base == 'OMG') ? 0 : 0.2 / 100
        taker = (base == 'OMG') ? 0 : 0.2 / 100
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'taker' => taker,
          'maker' => maker,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => nil
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            },
            'cost' => {
              'min' => 0,
              'max' => nil
            }
          },
          'info' => market
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(ticker, 'ts')
      bid = nil
      ask = nil
      bidVolume = nil
      askVolume = nil
      if ticker.include?('bid')
        if ticker['bid'].is_a?(Array)
          bid = self.safe_float(ticker['bid'], 0)
          bidVolume = self.safe_float(ticker['bid'], 1)
        end
      end
      if ticker.include?('ask')
        if ticker['ask'].is_a?(Array)
          ask = self.safe_float(ticker['ask'], 0)
          askVolume = self.safe_float(ticker['ask'], 1)
        end
      end
      open = self.safe_float(ticker, 'open')
      close = self.safe_float(ticker, 'close')
      change = nil
      percentage = nil
      average = nil
      if (open != nil) && (close != nil)
        change = close - open
        average = self.sum(open, close) / 2
        if (close != nil) && (close > 0)
          percentage = (change / open) * 100
        end
      end
      baseVolume = self.safe_float(ticker, 'amount')
      quoteVolume = self.safe_float(ticker, 'vol')
      vwap = nil
      if baseVolume != nil && quoteVolume != nil && baseVolume > 0
        vwap = quoteVolume / baseVolume
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => bid,
        'bidVolume' => bidVolume,
        'ask' => ask,
        'askVolume' => askVolume,
        'vwap' => vwap,
        'open' => open,
        'close' => close,
        'last' => close,
        'previousClose' => nil,
        'change' => change,
        'percentage' => percentage,
        'average' => average,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.marketGetDepth(self.shallow_extend({
        'symbol' => market['id'],
        'type' => 'step0'
      }, params))
      if response.include?('tick')
        if !response['tick']
          raise(ExchangeError, self.id + ' fetchOrderBook returned empty response => ' + self.json(response))
        end
        orderbook = response['tick']
        result = self.parse_order_book(orderbook, orderbook['ts'])
        result['nonce'] = orderbook['version']
        return result
      end
      raise(ExchangeError, self.id + ' fetchOrderBook returned unrecognized response => ' + self.json(response))
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.marketGetDetailMerged(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_ticker(response['tick'], market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.marketGetTickers(params)
      tickers = response['data']
      timestamp = self.safe_integer(response, 'ts')
      result = {}
      for i in (0...tickers.length)
        marketId = self.safe_string(tickers[i], 'symbol')
        market = self.safe_value(self.markets_by_id, marketId)
        symbol = marketId
        if market != nil
          symbol = market['symbol']
          ticker = self.parse_ticker(tickers[i], market)
          ticker['timestamp'] = timestamp
          ticker['datetime'] = self.iso8601(timestamp)
          result[symbol] = ticker
        end
      end
      return result
    end

    def parse_trade(trade, market = nil)
      symbol = nil
      if market.nil?
        marketId = self.safe_string(trade, 'symbol')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer_2(trade, 'ts', 'created-at')
      order = self.safe_string(trade, 'order-id')
      side = self.safe_string(trade, 'direction')
      type = self.safe_string(trade, 'type')
      if type != nil
        typeParts = type.split('-')
        side = typeParts[0]
        type = typeParts[1]
      end
      price = self.safe_float(trade, 'price')
      amount = self.safe_float_2(trade, 'filled-amount', 'amount')
      cost = nil
      if price != nil
        if amount != nil
          cost = amount * price
        end
      end
      fee = nil
      feeCost = self.safe_float(trade, 'filled-fees')
      feeCurrency = nil
      if market != nil
        feeCurrency = (side == 'buy') ? market['base'] : market['quote']
      end
      filledPoints = self.safe_float(trade, 'filled-points')
      if filledPoints != nil
        if (feeCost.nil?) || (feeCost == 0.0)
          feeCost = filledPoints
          feeCurrency = self.common_currency_code('HBPOINT')
        end
      end
      if feeCost != nil
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      return {
        'info' => trade,
        'id' => self.safe_string(trade, 'id'),
        'order' => order,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      response = self.privateGetOrderMatchresults(params)
      trades = self.parse_trades(response['data'], nil, since, limit)
      if symbol != nil
        market = self.market(symbol)
        trades = self.filter_by_symbol(trades, market['symbol'])
      end
      return trades
    end

    def fetch_trades(symbol, since = nil, limit = 1000, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id']
      }
      if limit != nil
        request['size'] = limit
      end
      response = self.marketGetHistoryTrade(self.shallow_extend(request, params))
      data = response['data']
      result = []
      for i in (0...data.length)
        trades = data[i]['data']
        for j in (0...trades.length)
          trade = self.parse_trade(trades[j], market)
          result.push(trade)
        end
      end
      result = self.sort_by(result, 'timestamp')
      return self.filter_by_symbol_since_limit(result, symbol, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv['id'] * 1000,
        ohlcv['open'],
        ohlcv['high'],
        ohlcv['low'],
        ohlcv['close'],
        ohlcv['amount']
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = 1000, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'period' => self.timeframes[timeframe]
      }
      if limit != nil
        request['size'] = limit
      end
      response = self.marketGetHistoryKline(self.shallow_extend(request, params))
      return self.parse_ohlcvs(response['data'], market, timeframe, since, limit)
    end

    def fetch_accounts(params = {})
      self.load_markets
      response = self.privateGetAccountAccounts(params)
      return response['data']
    end

    def fetch_currencies(params = {})
      response = self.publicGetSettingsCurrencys(self.shallow_extend({
        'language' => self.options['language']
      }, params))
      currencies = response['data']
      result = {}
      for i in (0...currencies.length)
        currency = currencies[i]
        #
        #  {                     name => "ctxc",
        #              'display-name' => "CTXC",
        #        'withdraw-precision' =>  8,
        #             'currency-type' => "eth",
        #        'currency-partition' => "pro",
        #             'support-sites' =>  null,
        #                'otc-enable' =>  0,
        #        'deposit-min-amount' => "2",
        #       'withdraw-min-amount' => "4",
        #            'show-precision' => "8",
        #                      weight => "2988",
        #                     visible =>  true,
        #              'deposit-desc' => "Please don’t deposit any other digital assets except CTXC t…",
        #             'withdraw-desc' => "Minimum withdrawal amount => 4 CTXC. !>_<!For security reason…",
        #           'deposit-enabled' =>  true,
        #          'withdraw-enabled' =>  true,
        #    'currency-addr-with-tag' =>  false,
        #             'fast-confirms' =>  15,
        #             'safe-confirms' =>  30                                                             }
        #
        id = self.safe_value(currency, 'name')
        precision = self.safe_integer(currency, 'withdraw-precision')
        code = self.common_currency_code(id.upcase)
        active = currency['visible'] && currency['deposit-enabled'] && currency['withdraw-enabled']
        result[code] = {
          'id' => id,
          'code' => code,
          'type' => 'crypto',
          # 'payin' => currency['deposit-enabled'],
          # 'payout' => currency['withdraw-enabled'],
          # 'transfer' => nil,
          'name' => currency['display-name'],
          'active' => active,
          'fee' => nil, # todo need to fetch from fee endpoint
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'deposit' => {
              'min' => self.safe_float(currency, 'deposit-min-amount'),
              'max' => 10**precision
            },
            'withdraw' => {
              'min' => self.safe_float(currency, 'withdraw-min-amount'),
              'max' => 10**precision
            }
          },
          'info' => currency
        }
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      self.loadAccounts
      method = self.options['fetchBalanceMethod']
      response = self.send_wrapper(method, self.shallow_extend({
        'id' => self.accounts[0]['id']
      }, params))
      balances = response['data']['list']
      result = { 'info' => response }
      for i in (0...balances.length)
        balance = balances[i]
        uppercase = balance['currency'].upcase
        currency = self.common_currency_code(uppercase)
        account = nil
        if result.include?(currency)
          account = result[currency]
        else
          account = self.account
        end
        if balance['type'] == 'trade'
          account['free'] = parse_float(balance['balance'])
        end
        if balance['type'] == 'frozen'
          account['used'] = parse_float(balance['balance'])
        end
        account['total'] = self.sum(account['free'], account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_orders_by_states(states, symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {
        'states' => states
      }
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['symbol'] = market['id']
      end
      response = self.privateGetOrderOrders(self.shallow_extend(request, params))
      #
      #     { status =>   "ok",
      #         data => [{                  id =>  13997833014,
      #                                symbol => "ethbtc",
      #                          'account-id' =>  3398321,
      #                                amount => "0.045000000000000000",
      #                                 price => "0.034014000000000000",
      #                          'created-at' =>  1545836976871,
      #                                  type => "sell-limit",
      #                        'field-amount' => "0.045000000000000000",
      #                   'field-cash-amount' => "0.001530630000000000",
      #                          'field-fees' => "0.000003061260000000",
      #                         'finished-at' =>  1545837948214,
      #                                source => "spot-api",
      #                                 state => "filled",
      #                         'canceled-at' =>  0                      }  ] }
      #
      return self.parse_orders(response['data'], market, since, limit)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_states('pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled', symbol, since, limit, params)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_states('pre-submitted,submitted,partial-filled', symbol, since, limit, params)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_states('filled,partial-canceled,canceled', symbol, since, limit, params)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'id' => id
      }
      response = self.privateGetOrderOrdersId(self.shallow_extend(request, params))
      order = self.safe_value(response, 'data')
      return self.parse_order(order)
    end

    def parse_order_status(status)
      statuses = {
        'partial-filled' => 'open',
        'partial-canceled' => 'canceled',
        'filled' => 'closed',
        'canceled' => 'canceled',
        'submitted' => 'open'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      #
      #     {                  id =>  13997833014,
      #                    symbol => "ethbtc",
      #              'account-id' =>  3398321,
      #                    amount => "0.045000000000000000",
      #                     price => "0.034014000000000000",
      #              'created-at' =>  1545836976871,
      #                      type => "sell-limit",
      #            'field-amount' => "0.045000000000000000",
      #       'field-cash-amount' => "0.001530630000000000",
      #              'field-fees' => "0.000003061260000000",
      #             'finished-at' =>  1545837948214,
      #                    source => "spot-api",
      #                     state => "filled",
      #             'canceled-at' =>  0                      }
      #
      #     {                  id =>  20395337822,
      #                    symbol => "ethbtc",
      #              'account-id' =>  5685075,
      #                    amount => "0.001000000000000000",
      #                     price => "0.0",
      #              'created-at' =>  1545831584023,
      #                      type => "buy-market",
      #            'field-amount' => "0.029100000000000000",
      #       'field-cash-amount' => "0.000999788700000000",
      #              'field-fees' => "0.000058200000000000",
      #             'finished-at' =>  1545831584181,
      #                    source => "spot-api",
      #                     state => "filled",
      #             'canceled-at' =>  0                      }
      #
      id = self.safe_string(order, 'id')
      side = nil
      type = nil
      status = nil
      if order.include?('type')
        orderType = order['type'].split('-')
        side = orderType[0]
        type = orderType[1]
        status = self.parse_order_status(self.safe_string(order, 'state'))
      end
      symbol = nil
      if market.nil?
        if order.include?('symbol')
          if self.markets_by_id.include?(order['symbol'])
            marketId = order['symbol']
            market = self.markets_by_id[marketId]
          end
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'created-at')
      amount = self.safe_float(order, 'amount')
      filled = self.safe_float(order, 'field-amount') # typo in their API, filled amount
      if (type == 'market') && (side == 'buy')
        amount = (status == 'closed') ? filled : nil
      end
      price = self.safe_float(order, 'price')
      if price == 0.0
        price = nil
      end
      cost = self.safe_float(order, 'field-cash-amount') # same typo
      remaining = nil
      average = nil
      if filled != nil
        if amount != nil
          remaining = amount - filled
        end
        # if cost is defined and filled is not zero
        if (cost != nil) && (filled > 0)
          average = cost / filled
        end
      end
      feeCost = self.safe_float(order, 'field-fees') # typo in their API, filled fees
      fee = nil
      if feeCost != nil
        feeCurrency = nil
        if market != nil
          feeCurrency = (side == 'sell') ? market['quote'] : market['base']
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'average' => average,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee
      }
      return result
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      self.loadAccounts
      market = self.market(symbol)
      request = {
        'account-id' => self.accounts[0]['id'],
        'amount' => self.amount_to_precision(symbol, amount),
        'symbol' => market['id'],
        'type' => side + '-' + type
      }
      if self.options['createMarketBuyOrderRequiresPrice']
        if (type == 'market') && (side == 'buy')
          if price.nil?
            raise(InvalidOrder, self.id + " market buy order requires price argument to calculate cost(total amount of quote currency to spend for buying, amount * price). To switch off self warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.")
          else
            # despite that cost = amount * price is in quote currency and should have quote precision
            # the exchange API requires the cost supplied in 'amount' to be of base precision
            # more about it here => https://github.com/ccxt/ccxt/pull/4395
            # we use priceToPrecision instead of amountToPrecision here
            # because in self case the amount is in the quote currency
            request['amount'] = self.price_to_precision(symbol, parse_float(amount) * parse_float(price))
          end
        end
      end
      if type == 'limit' || type == 'ioc' || type == 'limit-maker'
        request['price'] = self.price_to_precision(symbol, price)
      end
      method = self.options['createOrderMethod']
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      timestamp = self.milliseconds
      return {
        'info' => response,
        'id' => response['data'],
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => nil,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'filled' => nil,
        'remaining' => nil,
        'cost' => nil,
        'trades' => nil,
        'fee' => nil
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      response = self.privatePostOrderOrdersIdSubmitcancel({ 'id' => id })
      #
      #     response = {
      #         'status' => 'ok',
      #         'data' => '10138899000',
      #     }
      #
      return self.shallow_extend(self.parse_order(response), {
        'id' => id,
        'status' => 'canceled'
      })
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      # if code == 'EOS':
      #     res = huobi.request('/dw/deposit-virtual/sharedAddressWithTag', 'private', 'GET', {'currency' => 'eos', 'chain' => 'eos1'})
      #     address_info = res['data']
      # else:
      #     address_info = self.broker.fetch_deposit_address(code)
      request = {
        'currency' => currency['id'].downcase
      }
      # https://github.com/ccxt/ccxt/issues/4851
      info = self.safe_value(currency, 'info', {})
      currencyAddressWithTag = self.safe_value(info, 'currency-addr-with-tag')
      method = 'privateGetDwDepositVirtualAddresses'
      if currencyAddressWithTag
        method = 'privateGetDwDepositVirtualSharedAddressWithTag'
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      #
      # privateGetDwDepositVirtualSharedAddressWithTag
      #
      #     {
      #         "status" => "ok",
      #         "data" => {
      #             "address" => "huobideposit",
      #             "tag" => "1937002"
      #         }
      #     }
      #
      # privateGetDwDepositVirtualAddresses
      #
      #     {
      #         "status" => "ok",
      #         "data" => "0xd7842ec9ba2bc20354e12f0e925a4e285a64187b"
      #     }
      #
      data = self.safe_value(response, 'data')
      address = nil
      tag = nil
      if currencyAddressWithTag
        address = self.safe_string(data, 'address')
        tag = self.safe_string(data, 'tag')
      else
        address = self.safe_string(response, 'data')
      end
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def currency_to_precision(currency, fee)
      return self.decimal_to_precision(fee, 0, self.currencies[currency]['precision'])
    end

    def calculate_fee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {})
      market = self.markets[symbol]
      rate = market[takerOrMaker]
      cost = amount * rate
      key = 'quote'
      if side == 'sell'
        cost *= price
      else
        key = 'base'
      end
      return {
        'type' => takerOrMaker,
        'currency' => market[key],
        'rate' => rate,
        'cost' => parse_float(self.currency_to_precision(market[key], cost))
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.load_markets
      self.check_address(address)
      currency = self.currency(code)
      request = {
        'address' => address, # only supports existing addresses in your withdraw address list
        'amount' => amount,
        'currency' => currency['id'].downcase
      }
      if tag != nil
        request['addr-tag'] = tag # only for XRP?
      end
      response = self.privatePostDwWithdrawApiCreate(self.shallow_extend(request, params))
      id = nil
      if response.include?('data')
        id = response['data']
      end
      return {
        'info' => response,
        'id' => id
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = '/'
      if api == 'market'
        url += api
      elsif (api == 'public') || (api == 'private')
        url += self.version
      end
      url += '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'private'
        self.check_required_credentials
        timestamp = self.ymdhms(self.milliseconds, 'T')
        request = self.keysort(self.shallow_extend({
          'SignatureMethod' => 'HmacSHA256',
          'SignatureVersion' => '2',
          'AccessKeyId' => self.apiKey,
          'Timestamp' => timestamp
        }, query))
        auth = self.urlencode(request)
        # unfortunately, PHP demands double quotes for the escaped newline symbol
        # eslint-disable-next-line quotes
        payload = "\n".join([method, self.hostname, url, auth])
        signature = self.hmac(self.encode(payload), self.encode(self.secret), 'sha256', 'base64')
        auth += '&' + self.urlencode({ 'Signature' => signature })
        url += '?' + auth
        if method == 'POST'
          body = self.json(query)
          headers = {
            'Content-Type' => 'application/json'
          }
        else
          headers = {
            'Content-Type' => 'application/x-www-form-urlencoded'
          }
        end
      else
        if params.size > 0
          url += '?' + self.urlencode(params)
        end
      end
      url = self.urls['api'][api] + url
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        if response.include?('status')
          #
          #     {"status":"error","err-code":"order-limitorder-amount-min-error","err-msg":"limit order amount error, min => `0.001`","data":null}
          #
          status = self.safe_string(response, 'status')
          if status == 'error'
            code = self.safe_string(response, 'err-code')
            feedback = self.id + ' ' + self.json(response)
            exceptions = self.exceptions
            if exceptions.include?(code)
              raise(exceptions[code], feedback)
            end
            raise(ExchangeError, feedback)
          end
        end
      end
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      if code.nil?
        raise(ArgumentsRequired, self.id + ' fetchDeposits requires a code argument')
      end
      if limit.nil? || limit > 100
        limit = 100
      end
      self.load_markets
      request = {}
      currency = self.currency(code)
      request['currency'] = currency['id']
      request['type'] = 'deposit'
      request['from'] = 0 # From 'id' ... if you want to get results after a particular transaction id, pass the id in params.from
      request['size'] = limit # Maximum transfers that can be fetched is 100
      response = self.privateGetQueryDepositWithdraw(self.shallow_extend(request, params))
      # return response
      return self.parseTransactions(response['data'], currency, since, limit)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      if code.nil?
        raise(ArgumentsRequired, self.id + ' fetchWithdrawals requires a code argument')
      end
      if limit.nil? || limit > 100
        limit = 100
      end
      self.load_markets
      request = {}
      currency = self.currency(code)
      request['currency'] = currency['id']
      request['type'] = 'withdraw' # Huobi uses withdraw for withdrawals
      request['from'] = 0 # From 'id' ... if you want to get results after a particular Transaction id, pass the id in params.from
      request['size'] = limit # Maximum transfers that can be fetched is 100
      response = self.privateGetQueryDepositWithdraw(self.shallow_extend(request, params))
      # return response
      return self.parseTransactions(response['data'], currency, since, limit)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchDeposits
      #
      #     {
      #         'id' => 8211029,
      #         'type' => 'deposit',
      #         'currency' => 'eth',
      #         'chain' => 'eth',
      #         'tx-hash' => 'bd315....',
      #         'amount' => 0.81162421,
      #         'address' => '4b8b....',
      #         'address-tag' => '',
      #         'fee' => 0,
      #         'state' => 'safe',
      #         'created-at' => 1542180380965,
      #         'updated-at' => 1542180788077
      #     }
      #
      # fetchWithdrawals
      #
      #     {
      #         'id' => 6908275,
      #         'type' => 'withdraw',
      #         'currency' => 'btc',
      #         'chain' => 'btc',
      #         'tx-hash' => 'c1a1a....',
      #         'amount' => 0.80257005,
      #         'address' => '1QR....',
      #         'address-tag' => '',
      #         'fee' => 0.0005,
      #         'state' => 'confirmed',
      #         'created-at' => 1552107295685,
      #         'updated-at' => 1552108032859
      #     }
      #
      timestamp = self.safe_integer(transaction, 'created-at')
      updated = self.safe_integer(transaction, 'updated-at')
      code = self.safe_currency_code(transaction, 'currency')
      type = self.safe_string(transaction, 'type')
      if type == 'withdraw'
        type = 'withdrawal'
      end
      status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
      tag = self.safe_string(transaction, 'address-tag')
      feeCost = self.safe_float(transaction, 'fee')
      if feeCost != nil
        feeCost = feeCost.abs
      end
      return {
        'info' => transaction,
        'id' => self.safe_string(transaction, 'id'),
        'txid' => self.safe_string(transaction, 'tx-hash'),
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => self.safe_string(transaction, 'address'),
        'tag' => tag,
        'type' => type,
        'amount' => self.safe_float(transaction, 'amount'),
        'currency' => code,
        'status' => status,
        'updated' => updated,
        'fee' => {
          'currency' => code,
          'cost' => feeCost,
          'rate' => nil
        }
      }
    end

    def parse_transaction_status(status)
      statuses = {
        # deposit statuses
        'unknown' => 'failed',
        'confirming' => 'pending',
        'confirmed' => 'ok',
        'safe' => 'ok',
        'orphan' => 'failed',
        # withdrawal statuses
        'submitted' => 'pending',
        'canceled' => 'canceled',
        'reexamine' => 'pending',
        'reject' => 'failed',
        'pass' => 'pending',
        'wallet-reject' => 'failed',
        # 'confirmed' => 'ok', # present in deposit statuses
        'confirm-error' => 'failed',
        'repealed' => 'failed',
        'wallet-transfer' => 'pending',
        'pre-transfer' => 'pending'
      }
      return self.safe_string(statuses, status, status)
    end
  end
end
