# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Cobinhood < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'cobinhood',
        'name' => 'COBINHOOD',
        'countries' => ['TW'],
        'rateLimit' => 1000 / 10,
        'version' => 'v1',
        'has' => {
          'fetchCurrencies' => true,
          'fetchTickers' => true,
          'fetchOHLCV' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchOrderTrades' => true,
          'fetchOrder' => true,
          'fetchDepositAddress' => true,
          'createDepositAddress' => true,
          'fetchDeposits' => true,
          'fetchWithdrawals' => true,
          'withdraw' => true,
          'fetchMyTrades' => true,
          'editOrder' => true
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => false
        },
        'timeframes' => {
          # the first two don't seem to work at all
          '1m' => '1m',
          '5m' => '5m',
          '15m' => '15m',
          '30m' => '30m',
          '1h' => '1h',
          '3h' => '3h',
          '6h' => '6h',
          '12h' => '12h',
          '1d' => '1D',
          '1w' => '7D',
          '2w' => '14D',
          '1M' => '1M'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/35755576-dee02e5c-0878-11e8-989f-1595d80ba47f.jpg',
          'api' => 'https://api.cobinhood.com',
          'www' => 'https://cobinhood.com',
          'doc' => 'https://cobinhood.github.io/api-public'
        },
        'api' => {
          'system' => {
            'get' => [
              'info',
              'time',
              'messages',
              'messages/{message_id}'
            ]
          },
          'admin' => {
            'get' => [
              'system/messages',
              'system/messages/{message_id}'
            ],
            'post' => [
              'system/messages'
            ],
            'patch' => [
              'system/messages/{message_id}'
            ],
            'delete' => [
              'system/messages/{message_id}'
            ]
          },
          'public' => {
            'get' => [
              'market/fundingbook/precisions/{currency_id}',
              'market/fundingbooks/{currency_id}',
              'market/tickers',
              'market/currencies',
              'market/quote_currencies',
              'market/trading_pairs',
              'market/orderbook/precisions/{trading_pair_id}',
              'market/orderbooks/{trading_pair_id}',
              'market/stats',
              'market/tickers', # fetchTickers
              'market/tickers/{trading_pair_id}',
              'market/trades/{trading_pair_id}',
              'market/trades_history/{trading_pair_id}',
              'market/trading_pairs',
              'chart/candles/{trading_pair_id}',
              'system/time'
            ]
          },
          'private' => {
            'get' => [
              'funding/auto_offerings',
              'funding/auto_offerings/{currency_id}',
              'funding/funding_history',
              'funding/fundings',
              'funding/loans',
              'funding/loans/{loan_id}',
              'trading/orders/{order_id}',
              'trading/orders/{order_id}/trades',
              'trading/orders',
              'trading/order_history',
              'trading/positions',
              'trading/positions/{trading_pair_id}',
              'trading/positions/{trading_pair_id}/claimable_size',
              'trading/trades',
              'trading/trades/{trade_id}',
              'trading/volume',
              'wallet/balances',
              'wallet/ledger',
              'wallet/limits/withdrawal',
              'wallet/generic_deposits',
              'wallet/generic_deposits/{generic_deposit_id}',
              'wallet/generic_withdrawals',
              'wallet/generic_withdrawals/{generic_withdrawal_id}',
              # older endpoints
              'wallet/deposit_addresses',
              'wallet/deposit_addresses/iota',
              'wallet/withdrawal_addresses',
              'wallet/withdrawal_frozen',
              'wallet/withdrawals/{withdrawal_id}',
              'wallet/withdrawals',
              'wallet/deposits/{deposit_id}',
              'wallet/deposits'
            ],
            'patch' => [
              'trading/positions/{trading_pair_id}'
            ],
            'post' => [
              'funding/auto_offerings',
              'funding/fundings',
              'trading/check_order',
              'trading/orders',
              # older endpoints
              'wallet/deposit_addresses',
              'wallet/transfer',
              'wallet/withdrawal_addresses',
              'wallet/withdrawals',
              'wallet/withdrawals/fee'
            ],
            'put' => [
              'funding/fundings/{funding_id}',
              'trading/orders/{order_id}'
            ],
            'delete' => [
              'funding/auto_offerings/{currency_id}',
              'funding/fundings/{funding_id}',
              'funding/loans/{loan_id}',
              'trading/orders/{order_id}',
              'trading/positions/{trading_pair_id}',
              'wallet/generic_withdrawals/{generic_withdrawal_id}',
              'wallet/withdrawal_addresses/{wallet_id}'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.0,
            'taker' => 0.0
          }
        },
        'precision' => {
          'amount' => 8,
          'price' => 8
        },
        'exceptions' => {
          'insufficient_balance' => InsufficientFunds,
          'invalid_order_size' => InvalidOrder,
          'invalid_nonce' => InvalidNonce,
          'unauthorized_scope' => PermissionDenied,
          'invalid_address' => InvalidAddress,
          'parameter_error' => OrderNotFound
        },
        'commonCurrencies' => {
          'SMT' => 'SocialMedia.Market',
          'MTN' => 'Motion Token'
        }
      })
    end

    def fetch_currencies(params = {})
      response = self.publicGetMarketCurrencies(params)
      currencies = response['result']['currencies']
      result = {}
      for i in (0...currencies.length)
        currency = currencies[i]
        id = currency['currency']
        code = self.common_currency_code(id)
        minUnit = self.safe_float(currency, 'min_unit')
        result[code] = {
          'id' => id,
          'code' => code,
          'name' => currency['name'],
          'active' => true,
          'fiat' => false,
          'precision' => self.precision_from_string(currency['min_unit']),
          'limits' => {
            'amount' => {
              'min' => minUnit,
              'max' => nil
            },
            'price' => {
              'min' => minUnit,
              'max' => nil
            },
            'deposit' => {
              'min' => minUnit,
              'max' => nil
            },
            'withdraw' => {
              'min' => minUnit,
              'max' => nil
            }
          },
          'funding' => {
            'withdraw' => {
              'fee' => self.safe_float(currency, 'withdrawal_fee')
            },
            'deposit' => {
              'fee' => self.safe_float(currency, 'deposit_fee')
            }
          },
          'info' => currency
        }
      end
      return result
    end

    def fetch_markets(params = {})
      response = self.publicGetMarketTradingPairs
      markets = response['result']['trading_pairs']
      result = []
      for i in (0...markets.length)
        market = markets[i]
        id = market['id']
        baseId, quoteId = id.split('-')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => 8,
          'price' => self.precision_from_string(market['quote_increment'])
        }
        active = self.safe_value(market, 'is_active', true)
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => self.safe_float(market, 'base_min_size'),
              'max' => self.safe_float(market, 'base_max_size')
            },
            'price' => {
              'min' => nil,
              'max' => nil
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => market
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      symbol = nil
      if market.nil?
        marketId = self.safe_string(ticker, 'trading_pair_id')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        else
          baseId, quoteId = marketId.split('-')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(ticker, 'timestamp')
      last = self.safe_float(ticker, 'last_trade_price')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, '24h_high'),
        'low' => self.safe_float(ticker, '24h_low'),
        'bid' => self.safe_float(ticker, 'highest_bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'lowest_ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => self.safe_float(ticker, 'percentChanged24hr'),
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, '24h_volume'),
        'quoteVolume' => self.safe_float(ticker, 'quote_volume'),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketTickersTradingPairId(self.shallow_extend({
        'trading_pair_id' => market['id']
      }, params))
      ticker = response['result']['ticker']
      return self.parse_ticker(ticker, market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetMarketTickers(params)
      tickers = response['result']['tickers']
      result = []
      for i in (0...tickers.length)
        result.push(self.parse_ticker(tickers[i]))
      end
      return self.index_by(result, 'symbol')
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'trading_pair_id' => self.market_id(symbol)
      }
      if limit != nil
        request['limit'] = limit
      end # 100
      response = self.publicGetMarketOrderbooksTradingPairId(self.shallow_extend(request, params))
      return self.parse_order_book(response['result']['orderbook'], nil, 'bids', 'asks', 0, 2)
    end

    def parse_trade(trade, market = nil)
      symbol = nil
      if market
        symbol = market['symbol']
      end
      timestamp = trade['timestamp']
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'size')
      cost = price * amount
      # you can't determine your side from maker/taker side and vice versa
      # you can't determine if your order/trade was a maker or a taker based
      # on just the side of your order/trade
      # https://github.com/ccxt/ccxt/issues/4300
      # side = (trade['maker_side'] == 'bid') ? 'sell' : 'buy'
      side = nil
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => trade['id'],
        'order' => nil,
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil
      }
    end

    def fetch_trades(symbol, since = nil, limit = 50, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketTradesTradingPairId(self.shallow_extend({
        'trading_pair_id' => market['id'],
        'limit' => limit, # default 20, but that seems too little
      }, params))
      trades = response['result']['trades']
      return self.parse_trades(trades, market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '5m', since = nil, limit = nil)
      return [
        # they say that timestamps are Unix Timestamps in seconds, but in fact those are milliseconds
        ohlcv['timestamp'],
        parse_float(ohlcv['open']),
        parse_float(ohlcv['high']),
        parse_float(ohlcv['low']),
        parse_float(ohlcv['close']),
        parse_float(ohlcv['volume'])
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      #
      # they say in their docs that end_time defaults to current server time
      # but if you don't specify it, their range limits does not allow you to query anything
      #
      # they also say that start_time defaults to 0,
      # but most calls fail if you do not specify any of end_time
      #
      # to make things worse, their docs say it should be a Unix Timestamp
      # but with seconds it fails, so we set milliseconds(somehow it works that way)
      #
      endTime = self.milliseconds
      request = {
        'trading_pair_id' => market['id'],
        'timeframe' => self.timeframes[timeframe],
        'end_time' => endTime
      }
      if since != nil
        request['start_time'] = since
      end
      response = self.publicGetChartCandlesTradingPairId(self.shallow_extend(request, params))
      ohlcv = response['result']['candles']
      return self.parse_ohlcvs(ohlcv, market, timeframe, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetWalletBalances(params)
      result = { 'info' => response }
      balances = response['result']['balances']
      for i in (0...balances.length)
        balance = balances[i]
        currency = balance['currency']
        if self.currencies_by_id.include?(currency)
          currency = self.currencies_by_id[currency]['code']
        end
        account = {
          'used' => parse_float(balance['on_order']),
          'total' => parse_float(balance['total'])
        }
        account['free'] = parse_float(account['total'] - account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def parse_order_status(status)
      statuses = {
        'filled' => 'closed',
        'rejected' => 'closed',
        'partially_filled' => 'open',
        'pending_cancellation' => 'open',
        'pending_modification' => 'open',
        'open' => 'open',
        'new' => 'open',
        'queued' => 'open',
        'cancelled' => 'canceled',
        'triggered' => 'triggered'
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      #
      #     {
      #         'completed_at' => None,
      #         'eq_price' => '0',
      #         'filled' => '0',
      #         'id' => '88426800-beae-4407-b4a1-f65cef693542',
      #         'price' => '0.00000507',
      #         'side' => 'bid',
      #         'size' => '3503.6489',
      #         'source' => 'exchange',
      #         'state' => 'open',
      #         'timestamp' => 1535258403597,
      #         'trading_pair_id' => 'ACT-BTC',
      #         'type' => 'limit',
      #     }
      #
      symbol = nil
      if market.nil?
        marketId = self.safe_string_2(order, 'trading_pair', 'trading_pair_id')
        market = self.safe_value(self.markets_by_id, marketId)
      end
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'timestamp')
      price = self.safe_float(order, 'price')
      average = self.safe_float(order, 'eq_price')
      amount = self.safe_float(order, 'size')
      filled = self.safe_float(order, 'filled')
      remaining = nil
      cost = nil
      if filled != nil && average != nil
        cost = average * filled
      elsif average != nil
        cost = average * amount
      end
      if amount != nil
        if filled != nil
          remaining = amount - filled
        end
      end
      status = self.parse_order_status(self.safe_string(order, 'state'))
      side = self.safe_string(order, 'side')
      if side == 'bid'
        side = 'buy'
      elsif side == 'ask'
        side = 'sell'
      end
      return {
        'id' => self.safe_string(order, 'id'),
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => self.safe_string(order, 'type'), # market, limit, stop, stop_limit, trailing_stop, fill_or_kill
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => average,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => nil,
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      side = (side == 'sell') ? 'ask' : 'bid'
      request = {
        'trading_pair_id' => market['id'],
        'type' => type, # market, limit, stop, stop_limit
        'side' => side,
        'size' => self.amount_to_precision(symbol, amount)
      }
      if type != 'market'
        request['price'] = self.price_to_precision(symbol, price)
      end
      response = self.privatePostTradingOrders(self.shallow_extend(request, params))
      order = self.parse_order(response['result']['order'], market)
      id = order['id']
      self.orders[id] = order
      return order
    end

    def edit_order(id, symbol, type, side, amount, price, params = {})
      self.load_markets
      response = self.privatePutTradingOrdersOrderId(self.shallow_extend({
        'order_id' => id,
        'price' => self.price_to_precision(symbol, price),
        'size' => self.amount_to_precision(symbol, amount)
      }, params))
      return self.parse_order(self.shallow_extend(response, {
        'id' => id
      }))
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privateDeleteTradingOrdersOrderId(self.shallow_extend({
        'order_id' => id
      }, params))
      return self.parse_order(self.shallow_extend(response, {
        'id' => id
      }))
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privateGetTradingOrdersOrderId(self.shallow_extend({
        'order_id' => id.to_s
      }, params))
      return self.parse_order(response['result']['order'])
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      result = self.privateGetTradingOrders(params)
      orders = self.parse_orders(result['result']['orders'], nil, since, limit)
      if symbol != nil
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit)
      end
      return self.filter_by_since_limit(orders, since, limit)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['trading_pair_id'] = market['id']
      end
      if limit != nil
        request['limit'] = limit # default 50, max 100
      end
      result = self.privateGetTradingOrderHistory(self.shallow_extend(request, params))
      orders = self.parse_orders(result['result']['orders'], market, since, limit)
      if symbol != nil
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit)
      end
      return self.filter_by_since_limit(orders, since, limit)
    end

    def fetch_order_trades(id, symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      response = self.privateGetTradingOrdersOrderIdTrades(self.shallow_extend({
        'order_id' => id
      }, params))
      market = (symbol.nil?) ? nil : self.market(symbol)
      return self.parse_trades(response['result']['trades'], market)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {}
      if symbol != nil
        request['trading_pair_id'] = market['id']
      end
      response = self.privateGetTradingTrades(self.shallow_extend(request, params))
      return self.parse_trades(response['result']['trades'], market, since, limit)
    end

    def create_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      # 'ledger_type' is required, see => https://cobinhood.github.io/api-public/#create-new-deposit-address
      ledgerType = self.safe_string(params, 'ledger_type', 'exchange')
      request = {
        'currency' => currency['id'],
        'ledger_type' => ledgerType
      }
      response = self.privatePostWalletDepositAddresses(self.shallow_extend(request, params))
      address = self.safe_string(response['result']['deposit_address'], 'address')
      tag = self.safe_string(response['result']['deposit_address'], 'memo')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privateGetWalletDepositAddresses(self.shallow_extend({
        'currency' => currency['id']
      }, params))
      #
      #     { success =>    true,
      #        result => { deposit_addresses => [{       address => "abcdefg",
      #                                         blockchain_id => "eosio",
      #                                            created_at =>  1536768050235,
      #                                              currency => "EOS",
      #                                                  memo => "12345678",
      #                                                  type => "exchange"      }] } }
      #
      addresses = self.safe_value(response['result'], 'deposit_addresses', [])
      address = nil
      tag = nil
      if addresses.length > 0
        address = self.safe_string(addresses[0], 'address')
        tag = self.safe_string_2(addresses[0], 'memo', 'tag')
      end
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'amount' => amount,
        'address' => address
      }
      if tag != nil
        request['memo'] = tag
      end
      response = self.privatePostWalletWithdrawals(self.shallow_extend(request, params))
      return {
        'id' => nil,
        'info' => response
      }
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if code.nil?
        raise(ExchangeError, self.id + ' fetchDeposits requires a currency code argument')
      end
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = self.privateGetWalletDeposits(self.shallow_extend(request, params))
      return self.parseTransactions(response['result']['deposits'], currency)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if code.nil?
        raise(ExchangeError, self.id + ' fetchWithdrawals requires a currency code argument')
      end
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = self.privateGetWalletWithdrawals(self.shallow_extend(request, params))
      return self.parseTransactions(response['result']['withdrawals'], currency)
    end

    def parse_transaction_status(status)
      statuses = {
        'tx_pending_two_factor_auth' => 'pending',
        'tx_pending_email_auth' => 'pending',
        'tx_pending_approval' => 'pending',
        'tx_approved' => 'pending',
        'tx_processing' => 'pending',
        'tx_pending' => 'pending',
        'tx_sent' => 'pending',
        'tx_cancelled' => 'canceled',
        'tx_timeout' => 'failed',
        'tx_invalid' => 'failed',
        'tx_rejected' => 'failed',
        'tx_confirmed' => 'ok'
      }
      return(statuses.include?(status)) ? statuses[status] : status
    end

    def parse_transaction(transaction, currency = nil)
      timestamp = self.safe_integer(transaction, 'created_at')
      code = nil
      if currency.nil?
        currencyId = self.safe_string(transaction, 'currency')
        if self.currencies_by_id.include?(currencyId)
          currency = self.currencies_by_id[currencyId]
        else
          code = self.common_currency_code(currencyId)
        end
      end
      if currency != nil
        code = currency['code']
      end
      id = nil
      withdrawalId = self.safe_string(transaction, 'withdrawal_id')
      depositId = self.safe_string(transaction, 'deposit_id')
      type = nil
      address = nil
      if withdrawalId != nil
        type = 'withdrawal'
        id = withdrawalId
        address = self.safe_string(transaction, 'to_address')
      elsif depositId != nil
        type = 'deposit'
        id = depositId
        address = self.safe_string(transaction, 'from_address')
      end
      additionalInfo = self.safe_value(transaction, 'additional_info', {})
      tag = self.safe_string(additionalInfo, 'memo')
      return {
        'info' => transaction,
        'id' => id,
        'txid' => self.safe_string(transaction, 'txhash'),
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => address,
        'tag' => tag, # refix it properly
        'type' => type,
        'amount' => self.safe_float(transaction, 'amount'),
        'currency' => code,
        'status' => self.parse_transaction_status(transaction['status']),
        'updated' => nil,
        'fee' => {
          'cost' => self.safe_float(transaction, 'fee'),
          'rate' => nil
        }
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      headers = {}
      if api == 'private'
        self.check_required_credentials
        # headers['device_id'] = self.apiKey
        headers['nonce'] = self.nonce.to_s
        headers['Authorization'] = self.apiKey
      end
      if method == 'GET'
        query = self.urlencode(query)
        if query.length
          url += '?' + query
        end
      else
        headers['Content-type'] = 'application/json charset=UTF-8'
        body = self.json(query)
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if code < 400 || code >= 600
        return
      end
      if body[0] != '{'
        raise(ExchangeError, self.id + ' ' + body)
      end
      feedback = self.id + ' ' + self.json(response)
      errorCode = self.safe_value(response['error'], 'error_code')
      if method == 'DELETE' || method == 'GET'
        if errorCode == 'parameter_error'
          if url.include?('trading/orders/')
            # Cobinhood returns vague "parameter_error" on fetchOrder and cancelOrder calls
            # for invalid order IDs as well as orders that are not "open"
            raise(InvalidOrder, feedback)
          end
        end
      end
      exceptions = self.exceptions
      if exceptions.include?(errorCode)
        raise(exceptions[errorCode], feedback)
      end
      raise(ExchangeError, feedback)
    end

    def nonce
      return self.milliseconds
    end
  end
end
