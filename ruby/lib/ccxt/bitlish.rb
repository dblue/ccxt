# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bitlish < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bitlish',
        'name' => 'Bitlish',
        'countries' => ['GB', 'EU', 'RU'],
        'rateLimit' => 1500,
        'version' => 'v1',
        'has' => {
          'CORS' => false,
          'fetchTickers' => true,
          'fetchOHLCV' => true,
          'withdraw' => true
        },
        'timeframes' => {
          '1h' => 3600
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766275-dcfc6c30-5ed3-11e7-839d-00a846385d0b.jpg',
          'api' => 'https://bitlish.com/api',
          'www' => 'https://bitlish.com',
          'doc' => 'https://bitlish.com/api'
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => false
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'taker' => 0.3 / 100, # anonymous 0.3%, verified 0.2%
            'maker' => 0
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {
              'BTC' => 0.001,
              'LTC' => 0.001,
              'DOGE' => 0.001,
              'ETH' => 0.001,
              'XMR' => 0,
              'ZEC' => 0.001,
              'DASH' => 0.0001,
              'EUR' => 50
            },
            'deposit' => {
              'BTC' => 0,
              'LTC' => 0,
              'DOGE' => 0,
              'ETH' => 0,
              'XMR' => 0,
              'ZEC' => 0,
              'DASH' => 0,
              'EUR' => 0
            }
          }
        },
        'api' => {
          'public' => {
            'get' => [
              'instruments',
              'ohlcv',
              'pairs',
              'tickers',
              'trades_depth',
              'trades_history'
            ],
            'post' => [
              'instruments',
              'ohlcv',
              'pairs',
              'tickers',
              'trades_depth',
              'trades_history'
            ]
          },
          'private' => {
            'post' => [
              'accounts_operations',
              'balance',
              'cancel_trade',
              'cancel_trades_by_ids',
              'cancel_all_trades',
              'create_bcode',
              'create_template_wallet',
              'create_trade',
              'deposit',
              'list_accounts_operations_from_ts',
              'list_active_trades',
              'list_bcodes',
              'list_my_matches_from_ts',
              'list_my_trades',
              'list_my_trads_from_ts',
              'list_payment_methods',
              'list_payments',
              'redeem_code',
              'resign',
              'signin',
              'signout',
              'trade_details',
              'trade_options',
              'withdraw',
              'withdraw_by_id'
            ]
          }
        },
        'commonCurrencies' => {
          'DSH' => 'DASH',
          'XDG' => 'DOGE'
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetPairs
      result = []
      keys = markets.keys
      for p in (0...keys.length)
        market = markets[keys[p]]
        id = market['id']
        symbol = market['name']
        base, quote = symbol.split('/')
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'info' => market
        })
      end
      return result
    end

    def parse_ticker(ticker, market)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'high' => self.safe_float(ticker, 'max'),
        'low' => self.safe_float(ticker, 'min'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'first'),
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => self.safe_float(ticker, 'prc') * 100,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'sum'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTickers(params)
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        market = self.safe_value(self.markets_by_id, id)
        symbol = nil
        if market != nil
          symbol = market['symbol']
        else
          baseId = id[0...3]
          quoteId = id[3...6]
          base = baseId.upcase
          quote = quoteId.upcase
          base = self.common_currency_code(base)
          quote = self.common_currency_code(quote)
          symbol = base + '/' + quote
        end
        ticker = tickers[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      tickers = self.publicGetTickers(params)
      ticker = tickers[market['id']]
      return self.parse_ticker(ticker, market)
    end

    def fetch_ohlcv(symbol, timeframe = '1h', since = nil, limit = nil, params = {})
      self.load_markets
      # market = self.market(symbol)
      now = self.seconds
      start = now - 86400 * 30 # last 30 days
      if since != nil
        start = parse_int(since / 1000)
      end
      interval = [start.to_s, nil]
      return self.publicPostOhlcv(self.shallow_extend({
        'time_range' => interval
      }, params))
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetTradesDepth(self.shallow_extend({
        'pair_id' => self.market_id(symbol)
      }, params))
      timestamp = nil
      last = self.safe_integer(orderbook, 'last')
      if last
        timestamp = parse_int(last / 1000)
      end
      return self.parse_order_book(orderbook, timestamp, 'bid', 'ask', 'price', 'volume')
    end

    def parse_trade(trade, market = nil)
      side = (trade['dir'] == 'bid') ? 'buy' : 'sell'
      symbol = nil
      if market
        symbol = market['symbol']
      end
      timestamp = parse_int(trade['created'] / 1000)
      return {
        'id' => nil,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => nil,
        'type' => nil,
        'side' => side,
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTradesHistory(self.shallow_extend({
        'pair_id' => market['id']
      }, params))
      return self.parse_trades(response['list'], market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostBalance
      result = { 'info' => response }
      currencies = response.keys
      balance = {}
      for c in (0...currencies.length)
        currency = currencies[c]
        account = response[currency]
        currency = currency.upcase
        # issue #4 bitlish names Dash as DSH, instead of DASH
        if currency == 'DSH'
          currency = 'DASH'
        end
        if currency == 'XDG'
          currency = 'DOGE'
        end
        balance[currency] = account
      end
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        account = self.account
        if balance.include?(currency)
          account['free'] = parse_float(balance[currency]['funds'])
          account['used'] = parse_float(balance[currency]['holded'])
          account['total'] = self.sum(account['free'], account['used'])
        end
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def sign_in(params = {})
      return self.privatePostSignin(self.shallow_extend({
        'login' => self.login,
        'passwd' => self.password
      }, params))
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      order = {
        'pair_id' => self.market_id(symbol),
        'dir' => (side == 'buy') ? 'bid' : 'ask',
        'amount' => amount
      }
      if type == 'limit'
        order['price'] = price
      end
      result = self.privatePostCreateTrade(self.shallow_extend(order, params))
      return {
        'info' => result,
        'id' => result['id']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostCancelTrade({ 'id' => id })
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      if code != 'BTC'
        # they did not document other types...
        raise(NotSupported, self.id + ' currently supports BTC withdrawals only, until they document other currencies...')
      end
      response = self.privatePostWithdraw(self.shallow_extend({
        'currency' => currency.downcase,
        'amount' => parse_float(amount),
        'account' => address,
        'payment_method' => 'bitcoin', # they did not document other types...
      }, params))
      return {
        'info' => response,
        'id' => response['message_id']
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + path
      if api == 'public'
        if method == 'GET'
          if params
            url += '?' + self.urlencode(params)
          end
        else
          body = self.json(params)
          headers = { 'Content-Type' => 'application/json' }
        end
      else
        self.check_required_credentials
        body = self.json(self.shallow_extend({ 'token' => self.apiKey }, params))
        headers = { 'Content-Type' => 'application/json' }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
