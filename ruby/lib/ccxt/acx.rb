# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Acx < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'acx',
        'name' => 'ACX',
        'countries' => ['AU'],
        'rateLimit' => 1000,
        'version' => 'v2',
        'has' => {
          'CORS' => true,
          'fetchTickers' => true,
          'fetchOHLCV' => true,
          'withdraw' => true,
          'fetchOrder' => true
        },
        'timeframes' => {
          '1m' => '1',
          '5m' => '5',
          '15m' => '15',
          '30m' => '30',
          '1h' => '60',
          '2h' => '120',
          '4h' => '240',
          '12h' => '720',
          '1d' => '1440',
          '3d' => '4320',
          '1w' => '10080'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/30247614-1fe61c74-9621-11e7-9e8c-f1a627afa279.jpg',
          'extension' => '.json',
          'api' => 'https://acx.io/api',
          'www' => 'https://acx.io',
          'doc' => 'https://acx.io/documents/api_v2'
        },
        'api' => {
          'public' => {
            'get' => [
              'depth', # Get depth or specified market Both asks and bids are sorted from highest price to lowest.
              'k_with_pending_trades', # Get K data with pending trades, which are the trades not included in K data yet, because there's delay between trade generated and processed by K data generator
              'k', # Get OHLC(k line) of specific market
              'markets', # Get all available markets
              'order_book', # Get the order book of specified market
              'order_book/{market}',
              'tickers', # Get ticker of all markets
              'tickers/{market}', # Get ticker of specific market
              'timestamp', # Get server current time, in seconds since Unix epoch
              'trades', # Get recent trades on market, each trade is included only once Trades are sorted in reverse creation order.
              'trades/{market}'
            ]
          },
          'private' => {
            'get' => [
              'members/me', # Get your profile and accounts info
              'deposits', # Get your deposits history
              'deposit', # Get details of specific deposit
              'deposit_address', # Where to deposit The address field could be empty when a new address is generating(e.g. for bitcoin), you should try again later in that case.
              'orders', # Get your orders, results is paginated
              'order', # Get information of specified order
              'trades/my', # Get your executed trades Trades are sorted in reverse creation order.
              'withdraws', # Get your cryptocurrency withdraws
              'withdraw', # Get your cryptocurrency withdraw
            ],
            'post' => [
              'orders', # Create a Sell/Buy order
              'orders/multi', # Create multiple sell/buy orders
              'orders/clear', # Cancel all my orders
              'order/delete', # Cancel an order
              'withdraw', # Create a withdraw
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.2 / 100,
            'taker' => 0.2 / 100
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => true,
            'withdraw' => {}, # There is only 1% fee on withdrawals to your bank account.
          }
        },
        'exceptions' => {
          '2002' => InsufficientFunds,
          '2003' => OrderNotFound
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetMarkets
      result = []
      for p in (0...markets.length)
        market = markets[p]
        id = market['id']
        symbol = market['name']
        baseId = self.safe_string(market, 'base_unit')
        quoteId = self.safe_string(market, 'quote_unit')
        if (baseId.nil?) || (quoteId.nil?)
          ids = symbol.split('/')
          baseId = ids[0].downcase
          quoteId = ids[1].downcase
        end
        base = baseId.upcase
        quote = quoteId.upcase
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        # todo => find out their undocumented precision and limits
        precision = {
          'amount' => 8,
          'price' => 8
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'precision' => precision,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetMembersMe
      balances = response['accounts']
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency']
        uppercase = currency.upcase
        account = {
          'free' => parse_float(balance['balance']),
          'used' => parse_float(balance['locked']),
          'total' => 0.0
        }
        account['total'] = self.sum(account['free'], account['used'])
        result[uppercase] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'market' => market['id']
      }
      if limit != nil
        request['limit'] = limit
      end # default = 300
      orderbook = self.publicGetDepth(self.shallow_extend(request, params))
      timestamp = orderbook['timestamp'] * 1000
      return self.parse_order_book(orderbook, timestamp)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = ticker['at'] * 1000
      ticker = ticker['ticker']
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'open'),
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTickers(params)
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        market = nil
        symbol = id
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        else
          base = id[0...3]
          quote = id[3...6]
          base = base.upcase
          quote = quote.upcase
          base = self.common_currency_code(base)
          quote = self.common_currency_code(quote)
          symbol = base + '/' + quote
        end
        ticker = tickers[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTickersMarket(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_ticker(response, market)
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(trade['created_at'])
      return {
        'id' => trade['id'].to_s,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => nil,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'volume'),
        'cost' => self.safe_float(trade, 'funds'),
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTrades(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv[0] * 1000,
        ohlcv[1],
        ohlcv[2],
        ohlcv[3],
        ohlcv[4],
        ohlcv[5]
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      if limit.nil?
        limit = 500
      end # default is 30
      request = {
        'market' => market['id'],
        'period' => self.timeframes[timeframe],
        'limit' => limit
      }
      if since != nil
        request['timestamp'] = since
      end
      response = self.publicGetK(self.shallow_extend(request, params))
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    def parse_order(order, market = nil)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      else
        marketId = order['market']
        symbol = self.markets_by_id[marketId]['symbol']
      end
      timestamp = self.parse8601(order['created_at'])
      state = order['state']
      status = nil
      if state == 'done'
        status = 'closed'
      elsif state == 'wait'
        status = 'open'
      elsif state == 'cancel'
        status = 'canceled'
      end
      return {
        'id' => order['id'].to_s,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => order['ord_type'],
        'side' => order['side'],
        'price' => self.safe_float(order, 'price'),
        'amount' => self.safe_float(order, 'volume'),
        'filled' => self.safe_float(order, 'executed_volume'),
        'remaining' => self.safe_float(order, 'remaining_volume'),
        'trades' => nil,
        'fee' => nil,
        'info' => order
      }
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privateGetOrder(self.shallow_extend({
        'id' => parse_int(id)
      }, params))
      return self.parse_order(response)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      order = {
        'market' => self.market_id(symbol),
        'side' => side,
        'volume' => amount.to_s,
        'ord_type' => type
      }
      if type == 'limit'
        order['price'] = price.to_s
      end
      response = self.privatePostOrders(self.shallow_extend(order, params))
      market = self.markets_by_id[response['market']]
      return self.parse_order(response, market)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      result = self.privatePostOrderDelete({ 'id' => id })
      order = self.parse_order(result)
      status = order['status']
      if status == 'closed' || status == 'canceled'
        raise(OrderNotFound, self.id + ' ' + self.json(order))
      end
      return order
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      # they have XRP but no docs on memo/tag
      request = {
        'currency' => currency['id'],
        'sum' => amount,
        'address' => address
      }
      result = self.privatePostWithdraw(self.shallow_extend(request, params))
      # withdrawal response is undocumented
      return {
        'info' => result,
        'id' => nil
      }
    end

    def nonce
      return self.milliseconds
    end

    def encode_params(params)
      if params.include?('orders')
        orders = params['orders']
        query = self.urlencode(self.keysort(self.omit(params, 'orders')))
        for i in (0...orders.length)
          order = orders[i]
          keys = order.keys
          for k in (0...keys.length)
            key = keys[k]
            value = order[key]
            query += '&orders%5B%5D%5B' + key + '%5D=' + value.to_s
          end
        end
        return query
      end
      return self.urlencode(self.keysort(params))
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = '/api/' + self.version + '/' + self.implode_params(path, params)
      if self.urls.include?('extension')
        request += self.urls['extension']
      end
      query = self.omit(params, self.extract_params(path))
      url = self.urls['api'] + request
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        query = self.encode_params(self.shallow_extend({
          'access_key' => self.apiKey,
          'tonce' => nonce
        }, params))
        auth = method + '|' + request + '|' + query
        signed = self.hmac(self.encode(auth), self.encode(self.secret))
        suffix = query + '&signature=' + signed
        if method == 'GET'
          url += '?' + suffix
        else
          body = suffix
          headers = { 'Content-Type' => 'application/x-www-form-urlencoded' }
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if code == 400
        error = self.safe_value(response, 'error')
        errorCode = self.safe_string(error, 'code')
        feedback = self.id + ' ' + self.json(response)
        exceptions = self.exceptions
        if exceptions.include?(errorCode)
          raise(exceptions[errorCode], feedback)
        end
        # fallback to default error handler
      end
    end
  end
end
