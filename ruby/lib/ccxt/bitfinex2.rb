# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

require_relative 'bitfinex'

module Ccxt
  class Bitfinex2 < Bitfinex
    def describe
      return self.deep_extend(super, {
        'id' => 'bitfinex2',
        'name' => 'Bitfinex',
        'countries' => ['VG'],
        'version' => 'v2',
        'certified' => false,
        # new metainfo interface
        'has' => {
          'CORS' => true,
          'createLimitOrder' => false,
          'createMarketOrder' => false,
          'createOrder' => false,
          'deposit' => false,
          'editOrder' => false,
          'fetchDepositAddress' => false,
          'fetchClosedOrders' => false,
          'fetchFundingFees' => false,
          'fetchMyTrades' => false, # has to be false https://github.com/ccxt/ccxt/issues/4971
          'fetchOHLCV' => true,
          'fetchOpenOrders' => false,
          'fetchOrder' => true,
          'fetchTickers' => true,
          'fetchTradingFee' => false,
          'fetchTradingFees' => false,
          'withdraw' => true
        },
        'timeframes' => {
          '1m' => '1m',
          '5m' => '5m',
          '15m' => '15m',
          '30m' => '30m',
          '1h' => '1h',
          '3h' => '3h',
          '6h' => '6h',
          '12h' => '12h',
          '1d' => '1D',
          '1w' => '7D',
          '2w' => '14D',
          '1M' => '1M'
        },
        'rateLimit' => 1500,
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
          'api' => 'https://api.bitfinex.com',
          'www' => 'https://www.bitfinex.com',
          'doc' => [
            'https://docs.bitfinex.com/v2/docs/',
            'https://github.com/bitfinexcom/bitfinex-api-node'
          ],
          'fees' => 'https://www.bitfinex.com/fees'
        },
        'api' => {
          'v1' => {
            'get' => [
              'symbols',
              'symbols_details'
            ]
          },
          'public' => {
            'get' => [
              'platform/status',
              'tickers',
              'ticker/{symbol}',
              'trades/{symbol}/hist',
              'book/{symbol}/{precision}',
              'book/{symbol}/P0',
              'book/{symbol}/P1',
              'book/{symbol}/P2',
              'book/{symbol}/P3',
              'book/{symbol}/R0',
              'stats1/{key}:{size}:{symbol}:{side}/{section}',
              'stats1/{key}:{size}:{symbol}/{section}',
              'stats1/{key}:{size}:{symbol}:long/last',
              'stats1/{key}:{size}:{symbol}:long/hist',
              'stats1/{key}:{size}:{symbol}:short/last',
              'stats1/{key}:{size}:{symbol}:short/hist',
              'candles/trade:{timeframe}:{symbol}/{section}',
              'candles/trade:{timeframe}:{symbol}/last',
              'candles/trade:{timeframe}:{symbol}/hist'
            ],
            'post' => [
              'calc/trade/avg',
              'calc/fx'
            ]
          },
          'private' => {
            'post' => [
              'auth/r/wallets',
              'auth/r/orders/{symbol}',
              'auth/r/orders/{symbol}/new',
              'auth/r/orders/{symbol}/hist',
              'auth/r/order/{symbol}:{id}/trades',
              'auth/r/trades/hist',
              'auth/r/trades/{symbol}/hist',
              'auth/r/positions',
              'auth/r/positions/hist',
              'auth/r/funding/offers/{symbol}',
              'auth/r/funding/offers/{symbol}/hist',
              'auth/r/funding/loans/{symbol}',
              'auth/r/funding/loans/{symbol}/hist',
              'auth/r/funding/credits/{symbol}',
              'auth/r/funding/credits/{symbol}/hist',
              'auth/r/funding/trades/{symbol}/hist',
              'auth/r/info/margin/{key}',
              'auth/r/info/funding/{key}',
              'auth/r/ledgers/hist',
              'auth/r/movements/hist',
              'auth/r/movements/{currency}/hist',
              'auth/r/stats/perf:{timeframe}/hist',
              'auth/r/alerts',
              'auth/w/alert/set',
              'auth/w/alert/{type}:{symbol}:{price}/del',
              'auth/calc/order/avail',
              'auth/r/ledgers/{symbol}/hist',
              'auth/r/settings',
              'auth/w/settings/set',
              'auth/w/settings/del',
              'auth/r/info/user'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.1 / 100,
            'taker' => 0.2 / 100
          },
          'funding' => {
            'withdraw' => {
              'BTC' => 0.0004,
              'BCH' => 0.0001,
              'ETH' => 0.00135,
              'EOS' => 0.0,
              'LTC' => 0.001,
              'OMG' => 0.15097,
              'IOT' => 0.0,
              'NEO' => 0.0,
              'ETC' => 0.01,
              'XRP' => 0.02,
              'ETP' => 0.01,
              'ZEC' => 0.001,
              'BTG' => 0.0,
              'DASH' => 0.01,
              'XMR' => 0.0001,
              'QTM' => 0.01,
              'EDO' => 0.23687,
              'DAT' => 9.8858,
              'AVT' => 1.1251,
              'SAN' => 0.35977,
              'USDT' => 5.0,
              'SPK' => 16.971,
              'BAT' => 1.1209,
              'GNT' => 2.8789,
              'SNT' => 9.0848,
              'QASH' => 1.726,
              'YYW' => 7.9464
            }
          }
        },
        'options' => {
          'orderTypes' => {
            'MARKET' => nil,
            'EXCHANGE MARKET' => 'market',
            'LIMIT' => nil,
            'EXCHANGE LIMIT' => 'limit',
            'STOP' => nil,
            'EXCHANGE STOP' => 'stopOrLoss',
            'TRAILING STOP' => nil,
            'EXCHANGE TRAILING STOP' => nil,
            'FOK' => nil,
            'EXCHANGE FOK' => 'limit FOK',
            'STOP LIMIT' => nil,
            'EXCHANGE STOP LIMIT' => 'limit stop',
            'IOC' => nil,
            'EXCHANGE IOC' => 'limit ioc'
          },
          'fiat' => {
            'USD' => 'USD',
            'EUR' => 'EUR',
            'JPY' => 'JPY',
            'GBP' => 'GBP'
          }
        }
      })
    end

    def is_fiat(code)
      return(self.options['fiat'].include?(code))
    end

    def get_currency_id(code)
      return 'f' + code
    end

    def fetch_markets(params = {})
      markets = self.v1GetSymbolsDetails
      result = []
      for p in (0...markets.length)
        market = markets[p]
        id = market['pair'].upcase
        baseId = id[0...3]
        quoteId = id[3...6]
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        id = 't' + id
        baseId = self.get_currency_id(baseId)
        quoteId = self.get_currency_id(quoteId)
        precision = {
          'price' => market['price_precision'],
          'amount' => market['price_precision']
        }
        limits = {
          'amount' => {
            'min' => self.safe_float(market, 'minimum_order_size'),
            'max' => self.safe_float(market, 'maximum_order_size')
          },
          'price' => {
            'min' => 10**-precision['price'],
            'max' => 10**precision['price']
          }
        }
        limits['cost'] = {
          'min' => limits['amount']['min'] * limits['price']['min'],
          'max' => nil
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => limits,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      # self api call does not return the 'used' amount - use the v1 version instead(which also returns zero balances)
      self.load_markets
      response = self.privatePostAuthRWallets
      balanceType = self.safe_string(params, 'type', 'exchange')
      result = { 'info' => response }
      for b in (0...response.length)
        balance = response[b]
        accountType = balance[0]
        currency = balance[1]
        total = balance[2]
        available = balance[4]
        if accountType == balanceType
          code = currency
          if self.currencies_by_id.include?(currency)
            code = self.currencies_by_id[currency]['code']
          elsif currency[0] == 't'
            currency = currency[1..-1]
            code = currency.upcase
            code = self.common_currency_code(code)
          else
            code = self.common_currency_code(code)
          end
          account = self.account
          account['total'] = total
          if !available
            if available == 0
              account['free'] = 0
              account['used'] = total
            else
              account['free'] = total
            end
          else
            account['free'] = available
            account['used'] = account['total'] - account['free']
          end
          result[code] = account
        end
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetBookSymbolPrecision(self.shallow_extend({
        'symbol' => self.market_id(symbol),
        'precision' => 'R0'
      }, params))
      timestamp = self.milliseconds
      result = {
        'bids' => [],
        'asks' => [],
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'nonce' => nil
      }
      for i in (0...orderbook.length)
        order = orderbook[i]
        price = order[1]
        amount = order[2]
        side = (amount > 0) ? 'bids' : 'asks'
        amount = amount.abs
        result[side].push([price, amount])
      end
      result['bids'] = self.sort_by(result['bids'], 0, true)
      result['asks'] = self.sort_by(result['asks'], 0)
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      length = ticker.length
      last = ticker[length - 4]
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => ticker[length - 2],
        'low' => ticker[length - 1],
        'bid' => ticker[length - 10],
        'bidVolume' => nil,
        'ask' => ticker[length - 8],
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => ticker[length - 6],
        'percentage' => ticker[length - 5] * 100,
        'average' => nil,
        'baseVolume' => ticker[length - 3],
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      request = {}
      if symbols != nil
        ids = self.market_ids(symbols)
        request['symbols'] = ids.join(',')
      else
        request['symbols'] = 'ALL'
      end
      tickers = self.publicGetTickers(self.shallow_extend(request, params))
      result = {}
      for i in (0...tickers.length)
        ticker = tickers[i]
        id = ticker[0]
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
          result[symbol] = self.parse_ticker(ticker, market)
        end
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetTickerSymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #     [
      #         ID,
      #         MTS, # timestamp
      #         AMOUNT,
      #         PRICE
      #     ]
      #
      # fetchMyTrades(private)
      #
      #     [
      #         ID,
      #         PAIR,
      #         MTS_CREATE,
      #         ORDER_ID,
      #         EXEC_AMOUNT,
      #         EXEC_PRICE,
      #         ORDER_TYPE,
      #         ORDER_PRICE,
      #         MAKER,
      #         FEE,
      #         FEE_CURRENCY,
      #         ...
      #     ]
      #
      tradeLength = trade.length
      isPrivate = (tradeLength > 5)
      id = trade[0].to_s
      amountIndex = isPrivate ? 4 : 2
      amount = trade[amountIndex]
      cost = nil
      priceIndex = isPrivate ? 5 : 3
      price = trade[priceIndex]
      side = nil
      orderId = nil
      takerOrMaker = nil
      type = nil
      fee = nil
      symbol = nil
      timestampIndex = isPrivate ? 2 : 1
      timestamp = trade[timestampIndex]
      if isPrivate
        marketId = trade[1]
        if marketId != nil
          if self.markets_by_id.include?(marketId)
            market = self.markets_by_id[marketId]
            symbol = market['symbol']
          else
            symbol = marketId
          end
        end
        orderId = trade[3]
        takerOrMaker = (trade[8] == 1) ? 'maker' : 'taker'
        feeCost = trade[9]
        feeCurrency = self.common_currency_code(trade[10])
        if feeCost != nil
          fee = {
            'cost' => feeCost.abs,
            'currency' => feeCurrency
          }
        end
        orderType = trade[6]
        type = self.safe_string(self.options['orderTypes'], orderType)
      end
      if symbol.nil?
        if market != nil
          symbol = market['symbol']
        end
      end
      if amount != nil
        side = (amount < 0) ? 'sell' : 'buy'
        amount = amount.abs
        if cost.nil?
          if price != nil
            cost = amount * price
          end
        end
      end
      return {
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => orderId,
        'side' => side,
        'type' => type,
        'takerOrMaker' => takerOrMaker,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      sort = '-1'
      request = {
        'symbol' => market['id']
      }
      if since != nil
        request['start'] = since
        sort = '1'
      end
      if limit != nil
        request['limit'] = limit # default 120, max 5000
      end
      request['sort'] = sort
      response = self.publicGetTradesSymbolHist(self.shallow_extend(request, params))
      #
      #     [
      #         [
      #             ID,
      #             MTS, # timestamp
      #             AMOUNT,
      #             PRICE
      #         ]
      #     ]
      #
      trades = self.sort_by(response, 1)
      return self.parse_trades(trades, market, nil, limit)
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = 100, params = {})
      self.load_markets
      market = self.market(symbol)
      if limit.nil?
        limit = 100 # default 100, max 5000
      end
      if since.nil?
        since = self.milliseconds - self.parse_timeframe(timeframe) * limit * 1000
      end
      request = {
        'symbol' => market['id'],
        'timeframe' => self.timeframes[timeframe],
        'sort' => 1,
        'start' => since,
        'limit' => limit
      }
      response = self.publicGetCandlesTradeTimeframeSymbolHist(self.shallow_extend(request, params))
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      raise(NotSupported, self.id + ' createOrder not implemented yet')
    end

    def cancel_order(id, symbol = nil, params = {})
      raise(NotSupported, self.id + ' cancelOrder not implemented yet')
    end

    def fetch_order(id, symbol = nil, params = {})
      raise(NotSupported, self.id + ' fetchOrder not implemented yet')
    end

    def fetch_deposit_address(currency, params = {})
      raise(NotSupported, self.id + ' fetchDepositAddress not implemented yet.')
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      raise(NotSupported, self.id + ' withdraw not implemented yet')
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      # self.has['fetchMyTrades'] is set to false
      # https://github.com/ccxt/ccxt/issues/4971
      self.load_markets
      market = nil
      request = {
        'end' => self.milliseconds
      }
      if since != nil
        request['start'] = since
      end
      if limit != nil
        request['limit'] = limit # default 25, max 1000
      end
      method = 'privatePostAuthRTradesHist'
      if symbol != nil
        market = self.market(symbol)
        request['symbol'] = market['id']
        method = 'privatePostAuthRTradesSymbolHist'
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      #
      #     [
      #         [
      #             ID,
      #             PAIR,
      #             MTS_CREATE,
      #             ORDER_ID,
      #             EXEC_AMOUNT,
      #             EXEC_PRICE,
      #             ORDER_TYPE,
      #             ORDER_PRICE,
      #             MAKER,
      #             FEE,
      #             FEE_CURRENCY,
      #             ...
      #         ],
      #         ...
      #     ]
      #
      return self.parse_trades(response, market, since, limit)
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'v1'
        request = api + request
      else
        request = self.version + request
      end
      url = self.urls['api'] + '/' + request
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      end
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce.to_s
        body = self.json(query)
        auth = '/api/' + request + nonce + body
        signature = self.hmac(self.encode(auth), self.encode(self.secret), 'sha384')
        headers = {
          'bfx-nonce' => nonce,
          'bfx-apikey' => self.apiKey,
          'bfx-signature' => signature,
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response
        if response.include?('message')
          if response['message'].include?('not enough exchange balance')
            raise(InsufficientFunds, self.id + ' ' + self.json(response))
          end
          raise(ExchangeError, self.id + ' ' + self.json(response))
        end
        return response
      elsif response == ''
        raise(ExchangeError, self.id + ' returned empty response')
      end
      return response
    end
  end
end
