# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Liquid < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'liquid',
        'name' => 'Liquid',
        'countries' => ['JP', 'CN', 'TW'],
        'version' => '2',
        'rateLimit' => 1000,
        'has' => {
          'CORS' => false,
          'fetchTickers' => true,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchMyTrades' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/45798859-1a872600-bcb4-11e8-8746-69291ce87b04.jpg',
          'api' => 'https://api.liquid.com',
          'www' => 'https://www.liquid.com',
          'doc' => [
            'https://developers.quoine.com',
            'https://developers.quoine.com/v2'
          ],
          'fees' => 'https://help.liquid.com/getting-started-with-liquid/the-platform/fee-structure',
          'referral' => 'https://www.liquid.com?affiliate=SbzC62lt30976'
        },
        'api' => {
          'public' => {
            'get' => [
              'currencies',
              'products',
              'products/{id}',
              'products/{id}/price_levels',
              'executions',
              'ir_ladders/{currency}'
            ]
          },
          'private' => {
            'get' => [
              'accounts/balance',
              'accounts/main_asset',
              'accounts/{id}',
              'crypto_accounts',
              'executions/me',
              'fiat_accounts',
              'loan_bids',
              'loans',
              'orders',
              'orders/{id}',
              'orders/{id}/trades',
              'orders/{id}/executions',
              'trades',
              'trades/{id}/loans',
              'trading_accounts',
              'trading_accounts/{id}',
              'transactions'
            ],
            'post' => [
              'fiat_accounts',
              'loan_bids',
              'orders'
            ],
            'put' => [
              'loan_bids/{id}/close',
              'loans/{id}',
              'orders/{id}',
              'orders/{id}/cancel',
              'trades/{id}',
              'trades/{id}/close',
              'trades/close_all',
              'trading_accounts/{id}'
            ]
          }
        },
        'skipJsonOnStatusCodes' => [401],
        'exceptions' => {
          'API rate limit exceeded. Please retry after 300s' => DDoSProtection,
          'API Authentication failed' => AuthenticationError,
          'Nonce is too small' => InvalidNonce,
          'Order not found' => OrderNotFound,
          'Can not update partially filled order' => InvalidOrder,
          'Can not update non-live order' => OrderNotFound,
          'not_enough_free_balance' => InsufficientFunds,
          'must_be_positive' => InvalidOrder,
          'less_than_order_size' => InvalidOrder
        },
        'commonCurrencies' => {
          'WIN' => 'WCOIN'
        },
        'options' => {
          'cancelOrderException' => true
        }
      })
    end

    def fetch_currencies(params = {})
      response = self.publicGetCurrencies(params)
      #
      #     [
      #         {
      #             currency_type => 'fiat',
      #             currency => 'USD',
      #             symbol => '$',
      #             assets_precision => 2,
      #             quoting_precision => 5,
      #             minimum_withdrawal => '15.0',
      #             withdrawal_fee => 5,
      #             minimum_fee => null,
      #             minimum_order_quantity => null,
      #             display_precision => 2,
      #             depositable => true,
      #             withdrawable => true,
      #             discount_fee => 0.5,
      #         },
      #     ]
      #
      result = {}
      for i in (0...response.length)
        currency = response[i]
        id = self.safe_string(currency, 'currency')
        code = self.common_currency_code(id)
        active = currency['depositable'] && currency['withdrawable']
        amountPrecision = self.safe_integer(currency, 'display_precision')
        pricePrecision = self.safe_integer(currency, 'quoting_precision')
        precision = maximum_wrapper(amountPrecision, pricePrecision)
        result[code] = {
          'id' => id,
          'code' => code,
          'info' => currency,
          'name' => code,
          'active' => active,
          'fee' => self.safe_float(currency, 'withdrawal_fee'),
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-amountPrecision,
              'max' => 10**amountPrecision
            },
            'price' => {
              'min' => 10**-pricePrecision,
              'max' => 10**pricePrecision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'withdraw' => {
              'min' => self.safe_float(currency, 'minimum_withdrawal'),
              'max' => nil
            }
          }
        }
      end
      return result
    end

    def fetch_markets(params = {})
      markets = self.publicGetProducts
      #
      #     [
      #         {
      #             id => '7',
      #             product_type => 'CurrencyPair',
      #             code => 'CASH',
      #             name => ' CASH Trading',
      #             market_ask => 8865.79147,
      #             market_bid => 8853.95988,
      #             indicator => 1,
      #             currency => 'SGD',
      #             currency_pair_code => 'BTCSGD',
      #             symbol => 'S$',
      #             btc_minimum_withdraw => null,
      #             fiat_minimum_withdraw => null,
      #             pusher_channel => 'product_cash_btcsgd_7',
      #             taker_fee => 0,
      #             maker_fee => 0,
      #             low_market_bid => '8803.25579',
      #             high_market_ask => '8905.0',
      #             volume_24h => '15.85443468',
      #             last_price_24h => '8807.54625',
      #             last_traded_price => '8857.77206',
      #             last_traded_quantity => '0.00590974',
      #             quoted_currency => 'SGD',
      #             base_currency => 'BTC',
      #             disabled => false,
      #         },
      #     ]
      #
      currencies = self.fetch_currencies
      currenciesByCode = self.index_by(currencies, 'code')
      result = []
      for i in (0...markets.length)
        market = markets[i]
        id = market['id'].to_s
        baseId = market['base_currency']
        quoteId = market['quoted_currency']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        maker = self.safe_float(market, 'maker_fee')
        taker = self.safe_float(market, 'taker_fee')
        active = !market['disabled']
        baseCurrency = self.safe_value(currenciesByCode, base)
        quoteCurrency = self.safe_value(currenciesByCode, quote)
        precision = {
          'amount' => 8,
          'price' => 8
        }
        minAmount = nil
        if baseCurrency != nil
          minAmount = self.safe_float(baseCurrency['info'], 'minimum_order_quantity')
          precision['amount'] = self.safe_integer(baseCurrency['info'], 'quoting_precision')
        end
        minPrice = nil
        if quoteCurrency != nil
          precision['price'] = self.safe_integer(quoteCurrency['info'], 'display_precision')
          minPrice = 10**-precision['price']
        end
        minCost = nil
        if minPrice != nil
          if minAmount != nil
            minCost = minPrice * minAmount
          end
        end
        limits = {
          'amount' => {
            'min' => minAmount,
            'max' => nil
          },
          'price' => {
            'min' => minPrice,
            'max' => nil
          },
          'cost' => {
            'min' => minCost,
            'max' => nil
          }
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'maker' => maker,
          'taker' => taker,
          'limits' => limits,
          'precision' => precision,
          'active' => active,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privateGetAccountsBalance(params)
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currencyId = balance['currency']
        code = currencyId
        if self.currencies_by_id.include?(currencyId)
          code = self.currencies_by_id[currencyId]['code']
        end
        total = parse_float(balance['balance'])
        account = {
          'free' => total,
          'used' => nil,
          'total' => total
        }
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetProductsIdPriceLevels(self.shallow_extend({
        'id' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook, nil, 'buy_price_levels', 'sell_price_levels')
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      last = nil
      if ticker.include?('last_traded_price')
        if ticker['last_traded_price']
          length = ticker['last_traded_price'].length
          if length > 0
            last = self.safe_float(ticker, 'last_traded_price')
          end
        end
      end
      symbol = nil
      if market.nil?
        marketId = self.safe_string(ticker, 'id')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        else
          baseId = self.safe_string(ticker, 'base_currency')
          quoteId = self.safe_string(ticker, 'quoted_currency')
          if self.markets.include?(symbol)
            market = self.markets[symbol]
          else
            symbol = self.common_currency_code(baseId) + '/' + self.common_currency_code(quoteId)
          end
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      change = nil
      percentage = nil
      average = nil
      open = self.safe_float(ticker, 'last_price_24h')
      if open != nil && last != nil
        change = last - open
        average = self.sum(last, open) / 2
        if open > 0
          percentage = change / open * 100
        end
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high_market_ask'),
        'low' => self.safe_float(ticker, 'low_market_bid'),
        'bid' => self.safe_float(ticker, 'market_bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'market_ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => open,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => percentage,
        'average' => average,
        'baseVolume' => self.safe_float(ticker, 'volume_24h'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetProducts(params)
      result = {}
      for t in (0...tickers.length)
        ticker = self.parse_ticker(tickers[t])
        symbol = ticker['symbol']
        result[symbol] = ticker
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetProductsId(self.shallow_extend({
        'id' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      # {             id =>  12345,
      #         quantity => "6.789",
      #            price => "98765.4321",
      #       taker_side => "sell",
      #       created_at =>  1512345678,
      #          my_side => "buy"           }
      timestamp = trade['created_at'] * 1000
      orderId = self.safe_string(trade, 'order_id')
      # 'taker_side' gets filled for both fetchTrades and fetchMyTrades
      takerSide = self.safe_string(trade, 'taker_side')
      # 'my_side' gets filled for fetchMyTrades only and may differ from 'taker_side'
      mySide = self.safe_string(trade, 'my_side')
      side = (mySide != nil) ? mySide : takerSide
      takerOrMaker = nil
      if mySide != nil
        takerOrMaker = (takerSide == mySide) ? 'taker' : 'maker'
      end
      cost = nil
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'quantity')
      if price != nil
        if amount != nil
          cost = price * amount
        end
      end
      return {
        'info' => trade,
        'id' => trade['id'].to_s,
        'order' => orderId,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => side,
        'takerOrMaker' => takerOrMaker,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'product_id' => market['id']
      }
      if limit != nil
        request['limit'] = limit
      end
      if since != nil
        # timestamp should be in seconds, whereas we use milliseconds in since and everywhere
        request['timestamp'] = parse_int(since / 1000)
      end
      response = self.publicGetExecutions(self.shallow_extend(request, params))
      result = (since != nil) ? response : response['models']
      return self.parse_trades(result, market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      # the `with_details` param is undocumented - it adds the order_id to the results
      request = {
        'product_id' => market['id'],
        'with_details' => true
      }
      if limit != nil
        request['limit'] = limit
      end
      response = self.privateGetExecutionsMe(self.shallow_extend(request, params))
      return self.parse_trades(response['models'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      order = {
        'order_type' => type,
        'product_id' => self.market_id(symbol),
        'side' => side,
        'quantity' => self.amount_to_precision(symbol, amount)
      }
      if type == 'limit'
        order['price'] = self.price_to_precision(symbol, price)
      end
      response = self.privatePostOrders(self.shallow_extend(order, params))
      return self.parse_order(response)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      result = self.privatePutOrdersIdCancel(self.shallow_extend({
        'id' => id
      }, params))
      order = self.parse_order(result)
      if order['status'] == 'closed'
        if self.options['cancelOrderException']
          raise(OrderNotFound, self.id + ' order closed already => ' + self.json(result))
        end
      end
      return order
    end

    def edit_order(id, symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      if price.nil?
        raise(ArgumentsRequired, self.id + ' editOrder requires the price argument')
      end
      order = {
        'order' => {
          'quantity' => self.amount_to_precision(symbol, amount),
          'price' => self.price_to_precision(symbol, price)
        }
      }
      result = self.privatePutOrdersId(self.shallow_extend({
        'id' => id
      }, order))
      return self.parse_order(result)
    end

    def parse_order_status(status)
      statuses = {
        'live' => 'open',
        'filled' => 'closed',
        'cancelled' => 'canceled'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      orderId = self.safe_string(order, 'id')
      timestamp = self.safe_integer(order, 'created_at')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      marketId = self.safe_string(order, 'product_id')
      market = self.safe_value(self.markets_by_id, marketId)
      status = self.parse_order_status(self.safe_string(order, 'status'))
      amount = self.safe_float(order, 'quantity')
      filled = self.safe_float(order, 'filled_quantity')
      price = self.safe_float(order, 'price')
      symbol = nil
      feeCurrency = nil
      if market != nil
        symbol = market['symbol']
        feeCurrency = market['quote']
      end
      type = order['order_type']
      executedQuantity = 0
      totalValue = 0
      averagePrice = self.safe_float(order, 'average_price')
      trades = nil
      if order.include?('executions')
        trades = self.parse_trades(self.safe_value(order, 'executions', []), market)
        numTrades = trades.length
        for i in (0...numTrades)
          # php copies values upon assignment, but not references them
          # todo rewrite self(shortly)
          trade = trades[i]
          trade['order'] = orderId
          trade['type'] = type
          executedQuantity += trade['amount']
          totalValue += trade['cost']
        end
        if !averagePrice && (numTrades > 0) && (executedQuantity > 0)
          averagePrice = totalValue / executedQuantity
        end
      end
      cost = filled * averagePrice
      return {
        'id' => orderId,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'type' => type,
        'status' => status,
        'symbol' => symbol,
        'side' => order['side'],
        'price' => price,
        'amount' => amount,
        'filled' => filled,
        'cost' => cost,
        'remaining' => amount - filled,
        'trades' => trades,
        'fee' => {
          'currency' => feeCurrency,
          'cost' => self.safe_float(order, 'order_fee')
        },
        'info' => order
      }
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      order = self.privateGetOrdersId(self.shallow_extend({
        'id' => id
      }, params))
      return self.parse_order(order)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      request = {}
      if symbol != nil
        market = self.market(symbol)
        request['product_id'] = market['id']
      end
      status = self.safe_value(params, 'status')
      if status
        params = self.omit(params, 'status')
        if status == 'open'
          request['status'] = 'live'
        elsif status == 'closed'
          request['status'] = 'filled'
        elsif status == 'canceled'
          request['status'] = 'cancelled'
        end
      end
      if limit != nil
        request['limit'] = limit
      end
      result = self.privateGetOrders(self.shallow_extend(request, params))
      orders = result['models']
      return self.parse_orders(orders, market, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders(symbol, since, limit, self.shallow_extend({ 'status' => 'open' }, params))
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders(symbol, since, limit, self.shallow_extend({ 'status' => 'closed' }, params))
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      headers = {
        'X-Quoine-API-Version' => self.version,
        'Content-Type' => 'application/json'
      }
      if api == 'private'
        self.check_required_credentials
        if method == 'GET'
          if query
            url += '?' + self.urlencode(query)
          end
        elsif query
          body = self.json(query)
        end
        nonce = self.nonce
        request = {
          'path' => url,
          'nonce' => nonce,
          'token_id' => self.apiKey,
          'iat' => nonce / 1000.floor, # issued at
        }
        headers['X-Quoine-Auth'] = self.jwt(request, self.secret)
      else
        if query
          url += '?' + self.urlencode(query)
        end
      end
      url = self.urls['api'] + url
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if code >= 200 && code < 300
        return
      end
      exceptions = self.exceptions
      if code == 401
        # expected non-json response
        if exceptions.include?(body)
          raise(exceptions[body], self.id + ' ' + body)
        else
          return
        end
      end
      if code == 429
        raise(DDoSProtection, self.id + ' ' + body)
      end
      if response.nil?
        return
      end
      feedback = self.id + ' ' + body
      message = self.safe_string(response, 'message')
      errors = self.safe_value(response, 'errors')
      if message != nil
        #
        #  { "message" => "Order not found" }
        #
        if exceptions.include?(message)
          raise(exceptions[message], feedback)
        end
      elsif errors != nil
        #
        #  { "errors" => { "user" => ["not_enough_free_balance"] }}
        #  { "errors" => { "quantity" => ["less_than_order_size"] }}
        #  { "errors" => { "order" => ["Can not update partially filled order"] }}
        #
        types = errors.keys
        for i in (0...types.length)
          type = types[i]
          errorMessages = errors[type]
          for j in (0...errorMessages.length)
            message = errorMessages[j]
            if exceptions.include?(message)
              raise(exceptions[message], feedback)
            end
          end
        end
      else
        raise(ExchangeError, feedback)
      end
    end
  end
end
