# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Poloniex < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'poloniex',
        'name' => 'Poloniex',
        'countries' => ['US'],
        'rateLimit' => 1000, # up to 6 calls per second
        'has' => {
          'CORS' => false,
          'createDepositAddress' => true,
          'createMarketOrder' => false,
          'editOrder' => true,
          'fetchClosedOrders' => 'emulated',
          'fetchCurrencies' => true,
          'fetchDepositAddress' => true,
          'fetchDeposits' => 'emulated',
          'fetchMyTrades' => true,
          'fetchOHLCV' => true,
          'fetchOpenOrder' => true, # true endpoint for a single open order
          'fetchOpenOrders' => true, # true endpoint for open orders
          'fetchOrder' => 'emulated', # no endpoint for a single open-or-closed order(just for an open order only)
          'fetchOrderBooks' => true,
          'fetchOrders' => 'emulated', # no endpoint for open-or-closed orders(just for open orders only)
          'fetchOrderStatus' => 'emulated', # no endpoint for status of a single open-or-closed order(just for open orders only)
          'fetchOrderTrades' => true, # true endpoint for trades of a single open or closed order
          'fetchTickers' => true,
          'fetchTradingFee' => true,
          'fetchTradingFees' => true,
          'fetchTransactions' => true,
          'fetchWithdrawals' => 'emulated', # but almost true )
          'withdraw' => true
        },
        'timeframes' => {
          '5m' => 300,
          '15m' => 900,
          '30m' => 1800,
          '2h' => 7200,
          '4h' => 14400,
          '1d' => 86400
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg',
          'api' => {
            'public' => 'https://poloniex.com/public',
            'private' => 'https://poloniex.com/tradingApi'
          },
          'www' => 'https://poloniex.com',
          'doc' => 'https://docs.poloniex.com',
          'fees' => 'https://poloniex.com/fees'
        },
        'api' => {
          'public' => {
            'get' => [
              'return24hVolume',
              'returnChartData',
              'returnCurrencies',
              'returnLoanOrders',
              'returnOrderBook',
              'returnTicker',
              'returnTradeHistory'
            ]
          },
          'private' => {
            'post' => [
              'buy',
              'cancelLoanOffer',
              'cancelOrder',
              'closeMarginPosition',
              'createLoanOffer',
              'generateNewAddress',
              'getMarginPosition',
              'marginBuy',
              'marginSell',
              'moveOrder',
              'returnActiveLoans',
              'returnAvailableAccountBalances',
              'returnBalances',
              'returnCompleteBalances',
              'returnDepositAddresses',
              'returnDepositsWithdrawals',
              'returnFeeInfo',
              'returnLendingHistory',
              'returnMarginAccountSummary',
              'returnOpenLoanOffers',
              'returnOpenOrders',
              'returnOrderTrades',
              'returnOrderStatus',
              'returnTradableBalances',
              'returnTradeHistory',
              'sell',
              'toggleAutoRenew',
              'transferBalance',
              'withdraw'
            ]
          }
        },
        # Fees are tier-based. More info => https://poloniex.com/fees/
        # Rates below are highest possible.
        'fees' => {
          'trading' => {
            'maker' => 0.001,
            'taker' => 0.002
          },
          'funding' => {}
        },
        'limits' => {
          'amount' => {
            'min' => 0.000001,
            'max' => 1000000000
          },
          'price' => {
            'min' => 0.00000001,
            'max' => 1000000000
          },
          'cost' => {
            'min' => 0.00000000,
            'max' => 1000000000
          }
        },
        'precision' => {
          'amount' => 8,
          'price' => 8
        },
        'commonCurrencies' => {
          'AIR' => 'AirCoin',
          'APH' => 'AphroditeCoin',
          'BCC' => 'BTCtalkcoin',
          'BDG' => 'Badgercoin',
          'BTM' => 'Bitmark',
          'CON' => 'Coino',
          'GOLD' => 'GoldEagles',
          'GPUC' => 'GPU',
          'HOT' => 'Hotcoin',
          'ITC' => 'Information Coin',
          'PLX' => 'ParallaxCoin',
          'KEY' => 'KEYCoin',
          'STR' => 'XLM',
          'SOC' => 'SOCC',
          'XAP' => 'API Coin'
        },
        'options' => {
          'limits' => {
            'cost' => {
              'min' => {
                'BTC' => 0.0001,
                'ETH' => 0.0001,
                'XMR' => 0.0001,
                'USDT' => 1.0
              }
            }
          }
        },
        'exceptions' => {
          'exact' => {
            'You may only place orders that reduce your position.' => InvalidOrder,
            'Invalid order number, or you are not the person who placed the order.' => OrderNotFound,
            'Permission denied' => PermissionDenied,
            'Connection timed out. Please try again.' => RequestTimeout,
            'Internal error. Please try again.' => ExchangeNotAvailable,
            'Order not found, or you are not the person who placed it.' => OrderNotFound,
            'Invalid API key/secret pair.' => AuthenticationError,
            'Please do not make more than 8 API calls per second.' => DDoSProtection,
            'Rate must be greater than zero.' => InvalidOrder, # {"error":"Rate must be greater than zero."}
          },
          'broad' => {
            'Total must be at least' => InvalidOrder, # {"error":"Total must be at least 0.0001."}
            'This account is frozen.' => AccountSuspended,
            'Not enough' => InsufficientFunds,
            'Nonce must be greater' => InvalidNonce,
            'You have already called cancelOrder or moveOrder on self order.' => CancelPending,
            'Amount must be at least' => InvalidOrder, # {"error":"Amount must be at least 0.000001."}
          }
        }
      })
    end

    def calculate_fee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {})
      market = self.markets[symbol]
      key = 'quote'
      rate = market[takerOrMaker]
      cost = self.cost_to_precision(symbol, amount * rate.to_f)
      if side == 'sell'
        cost *= price
      else
        key = 'base'
      end
      return {
        'type' => takerOrMaker,
        'currency' => market[key],
        'rate' => rate,
        'cost' => self.fee_to_precision(symbol, cost.to_f)
      }
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '5m', since = nil, limit = nil)
      return [
        ohlcv['date'] * 1000,
        ohlcv['open'],
        ohlcv['high'],
        ohlcv['low'],
        ohlcv['close'],
        ohlcv['quoteVolume']
      ]
    end

    async def fetch_ohlcv(symbol, timeframe = '5m', since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      if since.nil?
        since = 0
      end
      request = {
        'currencyPair' => market['id'],
        'period' => self.timeframes[timeframe],
        'start' => (since / 1000).to_i
      }
      if limit != nil
        request['end'] = self.sum(request['start'], limit * self.timeframes[timeframe])
      else
        request['end'] = self.sum(self.seconds, 1)
      end
      response = await{ self.publicGetReturnChartData(self.shallow_extend(request, params)) }
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    async def fetch_markets(params = {})
      markets = await{ self.publicGetReturnTicker }
      keys = markets.keys
      result = []
      for p in (0...keys.length)
        id = keys[p]
        market = markets[id]
        quoteId, baseId = id.split('_')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        limits = self.shallow_extend(self.limits, {
          'cost' => {
            'min' => self.safe_value(self.options['limits']['cost']['min'], quote)
          }
        })
        result.push(self.shallow_extend(self.fees['trading'], {
          'id' => id,
          'symbol' => symbol,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'base' => base,
          'quote' => quote,
          'active' => market['isFrozen'] != '1',
          'limits' => limits,
          'info' => market
        }))
      end
      return result
    end

    async def fetch_balance(params = {})
      await{ self.load_markets }
      balances = await{ self.privatePostReturnCompleteBalances(self.shallow_extend({
        'account' => 'all'
      }, params)) }
      result = { 'info' => balances }
      currencies = balances.keys
      for c in (0...currencies.length)
        id = currencies[c]
        balance = balances[id]
        currency = self.common_currency_code(id)
        account = {
          'free' => balance['available'].to_f,
          'used' => balance['onOrders'].to_f,
          'total' => 0.0
        }
        account['total'] = self.sum(account['free'], account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    async def fetch_trading_fees(params = {})
      await{ self.load_markets }
      fees = await{ self.privatePostReturnFeeInfo }
      return {
        'info' => fees,
        'maker' => self.safe_float(fees, 'makerFee'),
        'taker' => self.safe_float(fees, 'takerFee'),
        'withdraw' => {},
        'deposit' => {}
      }
    end

    async def fetch_order_book(symbol, limit = nil, params = {})
      await{ self.load_markets }
      request = {
        'currencyPair' => self.market_id(symbol)
      }
      if limit != nil
        request['depth'] = limit # 100
      end
      response = await{ self.publicGetReturnOrderBook(self.shallow_extend(request, params)) }
      orderbook = self.parse_order_book(response)
      orderbook['nonce'] = self.safe_integer(response, 'seq')
      return orderbook
    end

    async def fetch_order_books(symbols = nil, params = {})
      await{ self.load_markets }
      request = {
        'currencyPair' => 'all'
      }
      #
      #     if limit != nil
      #         request['depth'] = limit # 100
      #     }
      #
      response = await{ self.publicGetReturnOrderBook(self.shallow_extend(request, params)) }
      marketIds = response.keys
      result = {}
      for i in (0...marketIds.length)
        marketId = marketIds[i]
        symbol = nil
        if self.markets_by_id.include?(marketId)
          symbol = self.markets_by_id[marketId]['symbol']
        else
          quoteId, baseId = marketId.split('_')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
        orderbook = self.parse_order_book(response[marketId])
        orderbook['nonce'] = self.safe_integer(response[marketId], 'seq')
        result[symbol] = orderbook
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      open = nil
      change = nil
      average = nil
      last = self.safe_float(ticker, 'last')
      relativeChange = self.safe_float(ticker, 'percentChange')
      if relativeChange != -1
        open = last / self.sum(1, relativeChange)
        change = last - open
        average = self.sum(last, open) / 2
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high24hr'),
        'low' => self.safe_float(ticker, 'low24hr'),
        'bid' => self.safe_float(ticker, 'highestBid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'lowestAsk'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => open,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => relativeChange * 100,
        'average' => average,
        'baseVolume' => self.safe_float(ticker, 'quoteVolume'),
        'quoteVolume' => self.safe_float(ticker, 'baseVolume'),
        'info' => ticker
      }
    end

    async def fetch_tickers(symbols = nil, params = {})
      await{ self.load_markets }
      tickers = await{ self.publicGetReturnTicker(params) }
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        symbol = nil
        market = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        else
          quoteId, baseId = id.split('_')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
          market = { 'symbol' => symbol }
        end
        ticker = tickers[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    async def fetch_currencies(params = {})
      currencies = await{ self.publicGetReturnCurrencies(params) }
      ids = currencies.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        currency = currencies[id]
        # todo => will need to rethink the fees
        # to add support for multiple withdrawal/deposit methods and
        # differentiated fees for each particular method
        precision = 8 # default precision, todo => fix "magic constants"
        code = self.common_currency_code(id)
        active = (currency['delisted'] == 0) && !currency['disabled']
        result[code] = {
          'id' => id,
          'code' => code,
          'info' => currency,
          'name' => currency['name'],
          'active' => active,
          'fee' => self.safe_float(currency, 'txFee'), # todo => redesign
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'withdraw' => {
              'min' => currency['txFee'],
              'max' => 10**precision
            }
          }
        }
      end
      return result
    end

    async def fetch_ticker(symbol, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      tickers = await{ self.publicGetReturnTicker(params) }
      ticker = tickers[market['id']]
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchMyTrades(symbol defined, specific market)
      #
      #     {
      #         globalTradeID => 394698946,
      #         tradeID => 45210255,
      #         date => '2018-10-23 17:28:55',
      #         type => 'sell',
      #         rate => '0.03114126',
      #         amount => '0.00018753',
      #         total => '0.00000583'
      #     }
      #
      # fetchMyTrades(symbol nil, all markets)
      #
      #     {
      #         globalTradeID => 394131412,
      #         tradeID => '5455033',
      #         date => '2018-10-16 18:05:17',
      #         rate => '0.06935244',
      #         amount => '1.40308443',
      #         total => '0.09730732',
      #         fee => '0.00100000',
      #         orderNumber => '104768235081',
      #         type => 'sell',
      #         category => 'exchange'
      #     }
      #
      id = self.safe_string(trade, 'globalTradeID')
      orderId = self.safe_string(trade, 'orderNumber')
      timestamp = self.parse8601(self.safe_string(trade, 'date'))
      symbol = nil
      base = nil
      quote = nil
      if (!market) && (trade.include?('currencyPair'))
        currencyPair = trade['currencyPair']
        if self.markets_by_id.include?(currencyPair)
          market = self.markets_by_id[currencyPair]
        else
          parts = currencyPair.split('_')
          quote = parts[0]
          base = parts[1]
          symbol = base + '/' + quote
        end
      end
      if market != nil
        symbol = market['symbol']
        base = market['base']
        quote = market['quote']
      end
      side = self.safe_string(trade, 'type')
      fee = nil
      price = self.safe_string(trade, 'rate')
      cost = self.safe_float(trade, 'total')
      amount = self.safe_float(trade, 'amount')
      if trade.include?('fee')
        rate = self.safe_float(trade, 'fee')
        feeCost = nil
        currency = nil
        if side == 'buy'
          currency = base
          feeCost = amount * rate
        else
          currency = quote
          if cost != nil
            feeCost = cost * rate
          end
        end
        fee = {
          'type' => nil,
          'rate' => rate,
          'cost' => feeCost,
          'currency' => currency
        }
      end
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => id,
        'order' => orderId,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    async def fetch_trades(symbol, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      request = {
        'currencyPair' => market['id']
      }
      if since != nil
        request['start'] = (since / 1000).to_i
        request['end'] = self.seconds # last 50000 trades by default
      end
      trades = await{ self.publicGetReturnTradeHistory(self.shallow_extend(request, params)) }
      return self.parse_trades(trades, market, since, limit)
    end

    async def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      pair = market ? market['id'] : 'all'
      request = { 'currencyPair' => pair }
      if since != nil
        request['start'] = (since / 1000).to_i
        request['end'] = self.seconds + 1 # adding 1 is a fix for #3411
      end
      # limit is disabled(does not really work as expected)
      if limit != nil
        request['limit'] = (limit).to_i
      end
      response = await{ self.privatePostReturnTradeHistory(self.shallow_extend(request, params)) }
      #
      # specific market(symbol defined)
      #
      #     [
      #         {
      #             globalTradeID => 394700861,
      #             tradeID => 45210354,
      #             date => '2018-10-23 18:01:58',
      #             type => 'buy',
      #             rate => '0.03117266',
      #             amount => '0.00000652',
      #             total => '0.00000020'
      #         },
      #         {
      #             globalTradeID => 394698946,
      #             tradeID => 45210255,
      #             date => '2018-10-23 17:28:55',
      #             type => 'sell',
      #             rate => '0.03114126',
      #             amount => '0.00018753',
      #             total => '0.00000583'
      #         }
      #     ]
      #
      # all markets(symbol nil)
      #
      #     {
      #         BTC_BCH => [{
      #             globalTradeID => 394131412,
      #             tradeID => '5455033',
      #             date => '2018-10-16 18:05:17',
      #             rate => '0.06935244',
      #             amount => '1.40308443',
      #             total => '0.09730732',
      #             fee => '0.00100000',
      #             orderNumber => '104768235081',
      #             type => 'sell',
      #             category => 'exchange'
      #         }, {
      #             globalTradeID => 394126818,
      #             tradeID => '5455007',
      #             date => '2018-10-16 16:55:34',
      #             rate => '0.06935244',
      #             amount => '0.00155709',
      #             total => '0.00010798',
      #             fee => '0.00200000',
      #             orderNumber => '104768179137',
      #             type => 'sell',
      #             category => 'exchange'
      #         }],
      #     }
      #
      result = []
      if market != nil
        result = self.parse_trades(response, market)
      else
        if response
          ids = response.keys
          for i in (0...ids.length)
            id = ids[i]
            market = nil
            if self.markets_by_id.include?(id)
              market = self.markets_by_id[id]
              trades = self.parse_trades(response[id], market)
              for j in (0...trades.length)
                result.push(trades[j])
              end
            else
              quoteId, baseId = id.split('_')
              base = self.common_currency_code(baseId)
              quote = self.common_currency_code(quoteId)
              symbol = base + '/' + quote
              trades = response[id]
              for j in (0...trades.length)
                result.push(self.shallow_extend(self.parse_trade(trades[j]), {
                  'symbol' => symbol
                }))
              end
            end
          end
        end
      end
      return self.filter_by_since_limit(result, since, limit)
    end

    def parse_order_status(status)
      statuses = {
        'Open' => 'open',
        'Partially filled' => 'open'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      #
      # fetchOpenOrder
      #
      #     {
      #         status => 'Open',
      #         rate => '0.40000000',
      #         amount => '1.00000000',
      #         currencyPair => 'BTC_ETH',
      #         date => '2018-10-17 17:04:50',
      #         total => '0.40000000',
      #         type => 'buy',
      #         startingAmount => '1.00000',
      #     }
      #
      # fetchOpenOrders
      #
      #     {
      #         orderNumber => '514514894224',
      #         type => 'buy',
      #         rate => '0.00001000',
      #         startingAmount => '100.00000000',
      #         amount => '100.00000000',
      #         total => '0.00100000',
      #         date => '2018-10-23 17:38:53',
      #         margin => 0,
      #     }
      #
      timestamp = self.safe_integer(order, 'timestamp')
      if !timestamp
        timestamp = self.parse8601(order['date'])
      end
      trades = nil
      if order.include?('resultingTrades')
        trades = self.parse_trades(order['resultingTrades'], market)
      end
      symbol = nil
      marketId = self.safe_string(order, 'currencyPair')
      market = self.safe_value(self.markets_by_id, marketId, market)
      if market != nil
        symbol = market['symbol']
      end
      price = self.safe_float_2(order, 'price', 'rate')
      remaining = self.safe_float(order, 'amount')
      amount = self.safe_float(order, 'startingAmount', remaining)
      filled = nil
      cost = 0
      if amount != nil
        if remaining != nil
          filled = amount - remaining
          if price != nil
            cost = filled * price
          end
        end
      end
      if filled.nil?
        if trades != nil
          filled = 0
          cost = 0
          for i in (0...trades.length)
            trade = trades[i]
            tradeAmount = trade['amount']
            tradePrice = trade['price']
            filled = self.sum(filled, tradeAmount)
            cost += tradePrice * tradeAmount
          end
        end
      end
      status = self.parse_order_status(self.safe_string(order, 'status'))
      type = self.safe_string(order, 'type')
      side = self.safe_string(order, 'side', type)
      if type == side
        type = nil
      end
      return {
        'info' => order,
        'id' => order['orderNumber'],
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => trades,
        'fee' => nil
      }
    end

    def parse_open_orders(orders, market, result)
      for i in (0...orders.length)
        order = orders[i]
        extended = self.shallow_extend(order, {
          'status' => 'open',
          'type' => 'limit',
          'side' => order['type'],
          'price' => order['rate']
        })
        result.push(self.parse_order(extended, market))
      end
      return result
    end

    async def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      pair = market ? market['id'] : 'all'
      response = await{ self.privatePostReturnOpenOrders(self.shallow_extend({
        'currencyPair' => pair
      })) }
      openOrders = []
      if market != nil
        openOrders = self.parse_open_orders(response, market, openOrders)
      else
        marketIds = response.keys
        for i in (0...marketIds.length)
          marketId = marketIds[i]
          orders = response[marketId]
          m = self.markets_by_id[marketId]
          openOrders = self.parse_open_orders(orders, m, openOrders)
        end
      end
      for j in (0...openOrders.length)
        self.orders[openOrders[j]['id']] = openOrders[j]
      end
      openOrdersIndexedById = self.index_by(openOrders, 'id')
      cachedOrderIds = self.orders.keys
      result = []
      for k in (0...cachedOrderIds.length)
        id = cachedOrderIds[k]
        if openOrdersIndexedById.include?(id)
          self.orders[id] = self.shallow_extend(self.orders[id], openOrdersIndexedById[id])
        else
          order = self.orders[id]
          if order['status'] == 'open'
            order = self.shallow_extend(order, {
              'status' => 'closed',
              'cost' => nil,
              'filled' => order['amount'],
              'remaining' => 0.0
            })
            if order['cost'].nil?
              if order['filled'] != nil
                order['cost'] = order['filled'] * order['price']
              end
            end
            self.orders[id] = order
          end
        end
        order = self.orders[id]
        if market != nil
          if order['symbol'] == symbol
            result.push(order)
          end
        else
          result.push(order)
        end
      end
      return self.filter_by_since_limit(result, since, limit)
    end

    async def fetch_order(id, symbol = nil, params = {})
      since = self.safe_value(params, 'since')
      limit = self.safe_value(params, 'limit')
      request = self.omit(params, ['since', 'limit'])
      orders = await{ self.fetch_orders(symbol, since, limit, request) }
      for i in (0...orders.length)
        if orders[i]['id'] == id
          return orders[i]
        end
      end
      raise(OrderNotCached, self.id + ' order id ' + id.to_s + ' is not in "open" state and not found in cache')
    end

    def filter_orders_by_status(orders, status)
      result = []
      for i in (0...orders.length)
        if orders[i]['status'] == status
          result.push(orders[i])
        end
      end
      return result
    end

    async def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = await{ self.fetch_orders(symbol, since, limit, params) }
      return self.filter_orders_by_status(orders, 'open')
    end

    async def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = await{ self.fetch_orders(symbol, since, limit, params) }
      return self.filter_orders_by_status(orders, 'closed')
    end

    async def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      await{ self.load_markets }
      method = 'privatePost' + self.capitalize(side)
      market = self.market(symbol)
      request = {
        'currencyPair' => market['id'],
        'rate' => self.price_to_precision(symbol, price),
        'amount' => self.amount_to_precision(symbol, amount)
      }
      response = await{ self.send_wrapper(method, self.shallow_extend(request, params)) }
      timestamp = self.milliseconds
      order = self.parse_order(self.shallow_extend({
        'timestamp' => timestamp,
        'status' => 'open',
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount
      }, response), market)
      id = order['id']
      self.orders[id] = order
      return self.shallow_extend({ 'info' => response }, order)
    end

    async def edit_order(id, symbol, type, side, amount, price = nil, params = {})
      await{ self.load_markets }
      price = price.to_f
      request = {
        'orderNumber' => id,
        'rate' => self.price_to_precision(symbol, price)
      }
      if amount != nil
        request['amount'] = self.amount_to_precision(symbol, amount)
      end
      response = await{ self.privatePostMoveOrder(self.shallow_extend(request, params)) }
      result = nil
      if self.orders.include?(id)
        self.orders[id]['status'] = 'canceled'
        newid = response['orderNumber']
        self.orders[newid] = self.shallow_extend(self.orders[id], {
          'id' => newid,
          'price' => price,
          'status' => 'open'
        })
        if amount != nil
          self.orders[newid]['amount'] = amount
        end
        result = self.shallow_extend(self.orders[newid], { 'info' => response })
      else
        market = nil
        if symbol != nil
          market = self.market(symbol)
        end
        result = self.parse_order(response, market)
        self.orders[result['id']] = result
      end
      return result
    end

    async def cancel_order(id, symbol = nil, params = {})
      await{ self.load_markets }
      response = nil
      begin
        response = await{ self.privatePostCancelOrder(self.shallow_extend({
          'orderNumber' => id
        }, params)) }
      rescue BaseError => e
        if e.is_a?(CancelPending)
          # A request to cancel the order has been sent already.
          # If we then attempt to cancel the order the second time
          # before the first request is processed the exchange will
          # raise a CancelPending exception. Poloniex won't show the
          # order in the list of active(open) orders and the cached
          # order will be marked as 'closed'(see #1801 for details).
          # To avoid that we proactively mark the order as 'canceled'
          # here. If for some reason the order does not get canceled
          # and still appears in the active list then the order cache
          # will eventually get back in sync on a call to `fetchOrder`.
          if self.orders.include?(id)
            self.orders[id]['status'] = 'canceled'
          end
        end
        raise e
      end
      if self.orders.include?(id)
        self.orders[id]['status'] = 'canceled'
      end
      return response
    end

    async def fetch_open_order(id, symbol = nil, params = {})
      await{ self.load_markets }
      id = id.to_s
      response = await{ self.privatePostReturnOrderStatus(self.shallow_extend({
        'orderNumber' => id
      }, params)) }
      #
      #     {
      #         success => 1,
      #         result => {
      #             '6071071' => {
      #                 status => 'Open',
      #                 rate => '0.40000000',
      #                 amount => '1.00000000',
      #                 currencyPair => 'BTC_ETH',
      #                 date => '2018-10-17 17:04:50',
      #                 total => '0.40000000',
      #                 type => 'buy',
      #                 startingAmount => '1.00000',
      #             },
      #         },
      #     }
      #
      result = self.safe_value(response['result'], id)
      if result.nil?
        raise(OrderNotFound, self.id + ' order id ' + id + ' not found')
      end
      order = self.parse_order(result)
      order['id'] = id
      self.orders[id] = order
      return order
    end

    async def fetch_order_status(id, symbol = nil, params = {})
      await{ self.load_markets }
      orders = await{ self.fetch_open_orders(symbol, nil, nil, params) }
      indexed = self.index_by(orders, 'id')
      return(indexed.include?(id)) ? 'open' : 'closed'
    end

    async def fetch_order_trades(id, symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      trades = await{ self.privatePostReturnOrderTrades(self.shallow_extend({
        'orderNumber' => id
      }, params)) }
      return self.parse_trades(trades)
    end

    async def create_deposit_address(code, params = {})
      await{ self.load_markets }
      currency = self.currency(code)
      response = await{ self.privatePostGenerateNewAddress({
        'currency' => currency['id']
      }) }
      address = nil
      tag = nil
      if response['success'] == 1
        address = self.safe_string(response, 'response')
      end
      self.check_address(address)
      depositAddress = self.safe_string(currency['info'], 'depositAddress')
      if depositAddress != nil
        tag = address
        address = depositAddress
      end
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    async def fetch_deposit_address(code, params = {})
      await{ self.load_markets }
      currency = self.currency(code)
      response = await{ self.privatePostReturnDepositAddresses }
      currencyId = currency['id']
      address = self.safe_string(response, currencyId)
      tag = nil
      self.check_address(address)
      depositAddress = self.safe_string(currency['info'], 'depositAddress')
      if depositAddress != nil
        tag = address
        address = depositAddress
      end
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    async def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      await{ self.load_markets }
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'amount' => amount,
        'address' => address
      }
      if tag
        request['paymentId'] = tag
      end
      result = await{ self.privatePostWithdraw(self.shallow_extend(request, params)) }
      return {
        'info' => result,
        'id' => result['response']
      }
    end

    async def fetch_transactions_helper(code = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      year = 31104000 # 60 * 60 * 24 * 30 * 12 = one year of history, why not
      now = self.seconds
      start = (since != nil) ?(since / 1000).to_i : now - 10 * year
      request = {
        'start' => start, # UNIX timestamp, required
        'end' => now, # UNIX timestamp, required
      }
      if limit != nil
        request['limit'] = limit
      end
      response = await{ self.privatePostReturnDepositsWithdrawals(self.shallow_extend(request, params)) }
      #
      #     {    deposits => [{      currency => "BTC",
      #                              address => "1MEtiqJWru53FhhHrfJPPvd2tC3TPDVcmW",
      #                               amount => "0.01063000",
      #                        confirmations =>  1,
      #                                 txid => "952b0e1888d6d491591facc0d37b5ebec540ac1efb241fdbc22bcc20d1822fb6",
      #                            timestamp =>  1507916888,
      #                               status => "COMPLETE"                                                          },
      #                      {      currency => "ETH",
      #                              address => "0x20108ba20b65c04d82909e91df06618107460197",
      #                               amount => "4.00000000",
      #                        confirmations =>  38,
      #                                 txid => "0x4be260073491fe63935e9e0da42bd71138fdeb803732f41501015a2d46eb479d",
      #                            timestamp =>  1525060430,
      #                               status => "COMPLETE"                                                            }  ],
      #       withdrawals => [{ withdrawalNumber =>  8224394,
      #                                currency => "EMC2",
      #                                 address => "EYEKyCrqTNmVCpdDV8w49XvSKRP9N3EUyF",
      #                                  amount => "63.10796020",
      #                                     fee => "0.01000000",
      #                               timestamp =>  1510819838,
      #                                  status => "COMPLETE => d37354f9d02cb24d98c8c4fc17aa42f475530b5727effdf668ee5a43ce667fd6",
      #                               ipAddress => "5.220.220.200"                                                               },
      #                      { withdrawalNumber =>  9290444,
      #                                currency => "ETH",
      #                                 address => "0x191015ff2e75261d50433fbd05bd57e942336149",
      #                                  amount => "0.15500000",
      #                                     fee => "0.00500000",
      #                               timestamp =>  1514099289,
      #                                  status => "COMPLETE => 0x12d444493b4bca668992021fd9e54b5292b8e71d9927af1f076f554e4bea5b2d",
      #                               ipAddress => "5.228.227.214"                                                                 },
      #                      { withdrawalNumber =>  11518260,
      #                                currency => "BTC",
      #                                 address => "8JoDXAmE1GY2LRK8jD1gmAmgRPq54kXJ4t",
      #                                  amount => "0.20000000",
      #                                     fee => "0.00050000",
      #                               timestamp =>  1527918155,
      #                                  status => "COMPLETE => 1864f4ebb277d90b0b1ff53259b36b97fa1990edc7ad2be47c5e0ab41916b5ff",
      #                               ipAddress => "211.8.195.26"                                                                }    ] }
      #
      return response
    end

    async def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      response = await{ self.fetch_transactions_helper(code, since, limit, params) }
      for i in (0...response['deposits'].length)
        response['deposits'][i]['type'] = 'deposit'
      end
      for i in (0...response['withdrawals'].length)
        response['withdrawals'][i]['type'] = 'withdrawal'
      end
      currency = nil
      if code != nil
        currency = self.currency(code)
      end
      withdrawals = self.parseTransactions(response['withdrawals'], currency, since, limit)
      deposits = self.parseTransactions(response['deposits'], currency, since, limit)
      transactions = self.array_concat(deposits, withdrawals)
      return self.filterByCurrencySinceLimit(self.sort_by(transactions, 'timestamp'), code, since, limit)
    end

    async def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      response = await{ self.fetch_transactions_helper(code, since, limit, params) }
      for i in (0...response['withdrawals'].length)
        response['withdrawals'][i]['type'] = 'withdrawal'
      end
      currency = nil
      if code != nil
        currency = self.currency(code)
      end
      withdrawals = self.parseTransactions(response['withdrawals'], currency, since, limit)
      return self.filterByCurrencySinceLimit(withdrawals, code, since, limit)
    end

    async def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      response = await{ self.fetch_transactions_helper(code, since, limit, params) }
      for i in (0...response['deposits'].length)
        response['deposits'][i]['type'] = 'deposit'
      end
      currency = nil
      if code != nil
        currency = self.currency(code)
      end
      deposits = self.parseTransactions(response['deposits'], currency, since, limit)
      return self.filterByCurrencySinceLimit(deposits, code, since, limit)
    end

    def parse_transaction_status(status)
      statuses = {
        'COMPLETE' => 'ok'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # deposits
      #
      #     {
      #         "txid" => "f49d489616911db44b740612d19464521179c76ebe9021af85b6de1e2f8d68cd",
      #         "type" => "deposit",
      #         "amount" => "49798.01987021",
      #         "status" => "COMPLETE",
      #         "address" => "DJVJZ58tJC8UeUv9Tqcdtn6uhWobouxFLT",
      #         "currency" => "DOGE",
      #         "timestamp" => 1524321838,
      #         "confirmations" => 3371,
      #         "depositNumber" => 134587098
      #     }
      #
      # withdrawals
      #
      #     {
      #         "fee" => "0.00050000",
      #         "type" => "withdrawal",
      #         "amount" => "0.40234387",
      #         "status" => "COMPLETE => fbabb2bf7d81c076f396f3441166d5f60f6cea5fdfe69e02adcc3b27af8c2746",
      #         "address" => "1EdAqY4cqHoJGAgNfUFER7yZpg1Jc9DUa3",
      #         "currency" => "BTC",
      #         "canCancel" => 0,
      #         "ipAddress" => "185.230.101.31",
      #         "paymentID" => null,
      #         "timestamp" => 1523834337,
      #         "canResendEmail" => 0,
      #         "withdrawalNumber" => 11162900
      #     }
      #
      timestamp = self.safe_integer(transaction, 'timestamp')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      code = nil
      currencyId = self.safe_string(transaction, 'currency')
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency.nil?
        code = self.common_currency_code(currencyId)
      end
      if currency != nil
        code = currency['code']
      end
      status = self.safe_string(transaction, 'status', 'pending')
      txid = self.safe_string(transaction, 'txid')
      if status != nil
        parts = status.split(' => ')
        numParts = parts.length
        status = parts[0]
        if (numParts > 1) && (txid.nil?)
          txid = parts[1]
        end
        status = self.parse_transaction_status(status)
      end
      type = self.safe_string(transaction, 'type')
      id = self.safe_string_2(transaction, 'withdrawalNumber', 'depositNumber')
      amount = self.safe_float(transaction, 'amount')
      address = self.safe_string(transaction, 'address')
      feeCost = self.safe_float(transaction, 'fee')
      if feeCost.nil?
        # according to https://poloniex.com/fees/
        feeCost = 0 # FIXME => remove hardcoded value that may change any time
      end
      if type == 'withdrawal'
        # poloniex withdrawal amount includes the fee
        amount = amount - feeCost
      end
      return {
        'info' => transaction,
        'id' => id,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => nil,
        'status' => status,
        'type' => type,
        'updated' => nil,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => {
          'currency' => code,
          'cost' => feeCost
        }
      }
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api]
      query = self.shallow_extend({ 'command' => path }, params)
      if api == 'public'
        url += '?' + self.urlencode(query)
      else
        self.check_required_credentials
        query['nonce'] = self.nonce
        body = self.urlencode(query)
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Key' => self.apiKey,
          'Sign' => self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if response.nil?
        return
      end
      # {"error":"Permission denied."}
      if response.include?('error')
        message = response['error']
        feedback = self.id + ' ' + self.json(response)
        exact = self.exceptions['exact']
        if exact.include?(message)
          raise(exact[message], feedback)
        end
        broad = self.exceptions['broad']
        broadKey = self.findBroadlyMatchedKey(broad, message)
        if broadKey != nil
          raise(broad[broadKey], feedback)
        end
        raise(ExchangeError, feedback) # unknown message
      end
    end
  end
end
