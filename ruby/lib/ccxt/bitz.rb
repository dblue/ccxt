# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bitz < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bitz',
        'name' => 'Bit-Z',
        'countries' => ['HK'],
        'rateLimit' => 2000,
        'version' => 'v2',
        'userAgent' => self.userAgents['chrome'],
        'has' => {
          'fetchTickers' => true,
          'fetchOHLCV' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchOrders' => true,
          'fetchOrder' => true,
          'createMarketOrder' => false
        },
        'timeframes' => {
          '1m' => '1min',
          '5m' => '5min',
          '15m' => '15min',
          '30m' => '30min',
          '1h' => '60min',
          '4h' => '4hour',
          '1d' => '1day',
          '5d' => '5day',
          '1w' => '1week',
          '1M' => '1mon'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/35862606-4f554f14-0b5d-11e8-957d-35058c504b6f.jpg',
          'api' => {
            'market' => 'https://apiv2.bitz.com',
            'trade' => 'https://apiv2.bitz.com',
            'assets' => 'https://apiv2.bitz.com'
          },
          'www' => 'https://www.bit-z.com',
          'doc' => 'https://apidoc.bit-z.com/en/',
          'fees' => 'https://www.bit-z.com/fee?type=1',
          'referral' => 'https://u.bit-z.com/register?invite_code=1429193'
        },
        'api' => {
          'market' => {
            'get' => [
              'ticker',
              'depth',
              'order', # trades
              'tickerall',
              'kline',
              'symbolList',
              'currencyRate',
              'currencyCoinRate',
              'coinRate'
            ]
          },
          'trade' => {
            'post' => [
              'addEntrustSheet',
              'cancelEntrustSheet',
              'cancelAllEntrustSheet',
              'getUserHistoryEntrustSheet', # closed orders
              'getUserNowEntrustSheet', # open orders
              'getEntrustSheetInfo', # order
            ]
          },
          'assets' => {
            'post' => [
              'getUserAssets'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.001,
            'taker' => 0.001
          },
          'funding' => {
            'withdraw' => {
              'BTC' => '0.5%',
              'DKKT' => '0.5%',
              'ETH' => 0.01,
              'USDT' => '0.5%',
              'LTC' => '0.5%',
              'FCT' => '0.5%',
              'LSK' => '0.5%',
              'HXI' => '0.8%',
              'ZEC' => '0.5%',
              'DOGE' => '0.5%',
              'MZC' => '0.5%',
              'ETC' => '0.5%',
              'GXS' => '0.5%',
              'XPM' => '0.5%',
              'PPC' => '0.5%',
              'BLK' => '0.5%',
              'XAS' => '0.5%',
              'HSR' => '0.5%',
              'NULS' => 5.0,
              'VOISE' => 350.0,
              'PAY' => 1.5,
              'EOS' => 0.6,
              'YBCT' => 35.0,
              'OMG' => 0.3,
              'OTN' => 0.4,
              'BTX' => '0.5%',
              'QTUM' => '0.5%',
              'DASH' => '0.5%',
              'GAME' => '0.5%',
              'BCH' => '0.5%',
              'GNT' => 9.0,
              'SSS' => 1500.0,
              'ARK' => '0.5%',
              'PART' => '0.5%',
              'LEO' => '0.5%',
              'DGB' => '0.5%',
              'ZSC' => 130.0,
              'VIU' => 350.0,
              'BTG' => '0.5%',
              'ARN' => 10.0,
              'VTC' => '0.5%',
              'BCD' => '0.5%',
              'TRX' => 200.0,
              'HWC' => '0.5%',
              'UNIT' => '0.5%',
              'OXY' => '0.5%',
              'MCO' => 0.3500,
              'SBTC' => '0.5%',
              'BCX' => '0.5%',
              'ETF' => '0.5%',
              'PYLNT' => 0.4000,
              'XRB' => '0.5%',
              'ETP' => '0.5%'
            }
          }
        },
        'precision' => {
          'amount' => 8,
          'price' => 8
        },
        'options' => {
          'fetchOHLCVVolume' => true,
          'fetchOHLCVWarning' => true,
          'lastNonceTimestamp' => 0
        },
        'commonCurrencies' => {
          # https://github.com/ccxt/ccxt/issues/3881
          # https://support.bit-z.pro/hc/en-us/articles/360007500654-BOX-BOX-Token-
          'BOX' => 'BOX Token',
          'XRB' => 'NANO',
          'PXC' => 'Pixiecoin'
        },
        'exceptions' => {
          # '200' => Success
          '-102' => ExchangeError, # Invalid parameter
          '-103' => AuthenticationError, # Verification failed
          '-104' => ExchangeNotAvailable, # Network Error-1
          '-105' => AuthenticationError, # Invalid api signature
          '-106' => ExchangeNotAvailable, # Network Error-2
          '-109' => AuthenticationError, # Invalid scretKey
          '-110' => DDoSProtection, # The number of access requests exceeded
          '-111' => PermissionDenied, # Current IP is not in the range of trusted IP
          '-112' => ExchangeNotAvailable, # Service is under maintenance
          '-100015' => AuthenticationError, # Trade password error
          '-100044' => ExchangeError, # Fail to request data
          '-100101' => ExchangeError, # Invalid symbol
          '-100201' => ExchangeError, # Invalid symbol
          '-100301' => ExchangeError, # Invalid symbol
          '-100401' => ExchangeError, # Invalid symbol
          '-100302' => ExchangeError, # Type of K-line error
          '-100303' => ExchangeError, # Size of K-line error
          '-200003' => AuthenticationError, # Please set trade password
          '-200005' => PermissionDenied, # This account can not trade
          '-200025' => ExchangeNotAvailable, # Temporary trading halt
          '-200027' => InvalidOrder, # Price Error
          '-200028' => InvalidOrder, # Amount must be greater than 0
          '-200029' => InvalidOrder, # Number must be between %s and %d
          '-200030' => InvalidOrder, # Over price range
          '-200031' => InsufficientFunds, # Insufficient assets
          '-200032' => ExchangeError, # System error. Please contact customer service
          '-200033' => ExchangeError, # Fail to trade
          '-200034' => OrderNotFound, # The order does not exist
          '-200035' => OrderNotFound, # Cancellation error, order filled
          '-200037' => InvalidOrder, # Trade direction error
          '-200038' => ExchangeError, # Trading Market Error
          '-200055' => OrderNotFound, # Order record does not exist
          '-300069' => AuthenticationError, # api_key is illegal
          '-300101' => ExchangeError, # Transaction type error
          '-300102' => InvalidOrder, # Price or number cannot be less than 0
          '-300103' => AuthenticationError, # Trade password error
          '-301001' => ExchangeNotAvailable, # Network Error-3
        }
      })
    end

    def fetch_markets(params = {})
      response = self.marketGetSymbolList
      #
      #     {    status =>    200,
      #             msg =>   "",
      #            data => {   ltc_btc => {          id => "1",
      #                                        name => "ltc_btc",
      #                                    coinFrom => "ltc",
      #                                      coinTo => "btc",
      #                                 numberFloat => "4",
      #                                  priceFloat => "8",
      #                                      status => "1",
      #                                    minTrade => "0.010",
      #                                    maxTrade => "500000000.000" },
      #                    qtum_usdt => {          id => "196",
      #                                        name => "qtum_usdt",
      #                                    coinFrom => "qtum",
      #                                      coinTo => "usdt",
      #                                 numberFloat => "4",
      #                                  priceFloat => "2",
      #                                      status => "1",
      #                                    minTrade => "0.100",
      #                                    maxTrade => "500000000.000" }  },
      #            time =>    1535969146,
      #       microtime =>   "0.66955600 1535969146",
      #          source =>   "api"                                           }
      #
      markets = response['data']
      ids = markets.keys
      result = []
      for i in (0...ids.length)
        id = ids[i]
        market = markets[id]
        numericId = self.safe_string(market, 'id')
        baseId = self.safe_string(market, 'coinFrom')
        quoteId = self.safe_string(market, 'coinTo')
        base = baseId.upcase
        quote = quoteId.upcase
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        precision = {
          'amount' => self.safe_integer(market, 'numberFloat'),
          'price' => self.safe_integer(market, 'priceFloat')
        }
        result.push({
          'info' => market,
          'id' => id,
          'numericId' => numericId,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => self.safe_float(market, 'minTrade'),
              'max' => self.safe_float(market, 'maxTrade')
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.assetsPostGetUserAssets(params)
      #
      #     {
      #         status => 200,
      #         msg => "",
      #         data => {
      #             cny => 0,
      #             usd => 0,
      #             btc_total => 0,
      #             info => [{
      #                 "name" => "zpr",
      #                 "num" => "37.49067275",
      #                 "over" => "37.49067275",
      #                 "lock" => "0.00000000",
      #                 "btc" => "0.00000000",
      #                 "usd" => "0.00000000",
      #                 "cny" => "0.00000000",
      #             }],
      #         },
      #         time => 1535983966,
      #         microtime => "0.70400500 1535983966",
      #         source => "api",
      #     }
      #
      balances = response['data']['info']
      result = { 'info' => response }
      for i in (0...balances.length)
        balance = balances[i]
        currencyId = self.safe_string(balance, 'name')
        code = currencyId.upcase
        if self.markets_by_id.include?(currencyId)
          code = self.currencies_by_id[currencyId]['code']
        else
          code = self.common_currency_code(code)
        end
        account = self.account
        account['used'] = self.safe_float(balance, 'lock')
        account['total'] = self.safe_float(balance, 'num')
        account['free'] = self.safe_float(balance, 'over')
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def parse_ticker(ticker, market = nil)
      #
      #      {          symbol => "eth_btc",
      #            quoteVolume => "3905.72",
      #                 volume => "97058.21",
      #            priceChange => "-1.72",
      #         priceChange24h => "-1.65",
      #               askPrice => "0.03971272",
      #                 askQty => "0.0663",
      #               bidPrice => "0.03961469",
      #                 bidQty => "19.5451",
      #                   open => "0.04036769",
      #                   high => "0.04062988",
      #                    low => "0.03956123",
      #                    now => "0.03970100",
      #                firstId =>  115567767,
      #                 lastId =>  115795316,
      #              dealCount =>  14078,
      #        numberPrecision =>  4,
      #         pricePrecision =>  8,
      #                    cny => "1959.05",
      #                    usd => "287.10",
      #                    krw => "318655.82"   }
      #
      timestamp = nil
      symbol = nil
      if market.nil?
        marketId = self.safe_string(ticker, 'symbol')
        market = self.safe_value(self.markets_by_id, marketId)
      end
      if market != nil
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'now')
      open = self.safe_float(ticker, 'open')
      change = nil
      average = nil
      if last != nil && open != nil
        change = last - open
        average = self.sum(last, open) / 2
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bidPrice'),
        'bidVolume' => self.safe_float(ticker, 'bidQty'),
        'ask' => self.safe_float(ticker, 'askPrice'),
        'askVolume' => self.safe_float(ticker, 'askQty'),
        'vwap' => nil,
        'open' => open,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => self.safe_float(ticker, 'priceChange24h'),
        'average' => average,
        'baseVolume' => self.safe_float(ticker, 'volume'),
        'quoteVolume' => self.safe_float(ticker, 'quoteVolume'),
        'info' => ticker
      }
    end

    def parse_microtime(microtime)
      if microtime.nil?
        return microtime
      end
      parts = microtime.split(' ')
      milliseconds = parse_float(parts[0])
      seconds = parse_int(parts[1])
      total = self.sum(seconds, milliseconds)
      return parse_int(total * 1000)
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.marketGetTicker(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      #
      #     {    status =>    200,
      #             msg =>   "",
      #            data => {          symbol => "eth_btc",
      #                        quoteVolume => "3905.72",
      #                             volume => "97058.21",
      #                        priceChange => "-1.72",
      #                     priceChange24h => "-1.65",
      #                           askPrice => "0.03971272",
      #                             askQty => "0.0663",
      #                           bidPrice => "0.03961469",
      #                             bidQty => "19.5451",
      #                               open => "0.04036769",
      #                               high => "0.04062988",
      #                                low => "0.03956123",
      #                                now => "0.03970100",
      #                            firstId =>  115567767,
      #                             lastId =>  115795316,
      #                          dealCount =>  14078,
      #                    numberPrecision =>  4,
      #                     pricePrecision =>  8,
      #                                cny => "1959.05",
      #                                usd => "287.10",
      #                                krw => "318655.82"   },
      #            time =>    1535970397,
      #       microtime =>   "0.76341900 1535970397",
      #          source =>   "api"                             }
      #
      ticker = self.parse_ticker(response['data'], market)
      timestamp = self.parse_microtime(self.safe_string(response, 'microtime'))
      return self.shallow_extend(ticker, {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp)
      })
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      request = {}
      if symbols != nil
        ids = self.market_ids(symbols)
        request['symbols'] = ids.join(',')
      end
      response = self.marketGetTickerall(self.shallow_extend(request, params))
      #
      #     {    status =>    200,
      #             msg =>   "",
      #            data => {   ela_btc => {          symbol => "ela_btc",
      #                                     quoteVolume => "0.00",
      #                                          volume => "3.28",
      #                                     priceChange => "0.00",
      #                                  priceChange24h => "0.00",
      #                                        askPrice => "0.00147984",
      #                                          askQty => "5.4580",
      #                                        bidPrice => "0.00120230",
      #                                          bidQty => "12.5384",
      #                                            open => "0.00149078",
      #                                            high => "0.00149078",
      #                                             low => "0.00149078",
      #                                             now => "0.00149078",
      #                                         firstId =>  115581219,
      #                                          lastId =>  115581219,
      #                                       dealCount =>  1,
      #                                 numberPrecision =>  4,
      #                                  pricePrecision =>  8,
      #                                             cny => "73.66",
      #                                             usd => "10.79",
      #                                             krw => "11995.03"    }     },
      #            time =>    1535971578,
      #       microtime =>   "0.39854200 1535971578",
      #          source =>   "api"                                                }
      #
      tickers = response['data']
      timestamp = self.parse_microtime(self.safe_string(response, 'microtime'))
      result = {}
      ids = tickers.keys
      for i in (0...ids.length)
        id = ids[i]
        ticker = tickers[id]
        market = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
        end
        ticker = self.parse_ticker(tickers[id], market)
        symbol = ticker['symbol']
        if symbol.nil?
          if market != nil
            symbol = market['symbol']
          else
            baseId, quoteId = id.split('_')
            base = baseId.upcase
            quote = quoteId.upcase
            base = self.common_currency_code(baseId)
            quote = self.common_currency_code(quoteId)
            symbol = base + '/' + quote
          end
        end
        if symbol != nil
          result[symbol] = self.shallow_extend(ticker, {
            'timestamp' => timestamp,
            'datetime' => self.iso8601(timestamp)
          })
        end
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      response = self.marketGetDepth(self.shallow_extend({
        'symbol' => self.market_id(symbol)
      }, params))
      #
      #     {    status =>    200,
      #             msg =>   "",
      #            data => {     asks => [["10.00000000", "0.4426", "4.4260"],
      #                                ["1.00000000", "0.8339", "0.8339"],
      #                                ["0.91700000", "0.0500", "0.0458"],
      #                                ["0.20000000", "0.1000", "0.0200"],
      #                                ["0.03987120", "16.1262", "0.6429"],
      #                                ["0.03986120", "9.7523", "0.3887"]   ],
      #                        bids => [["0.03976145", "0.0359", "0.0014"],
      #                                ["0.03973401", "20.9493", "0.8323"],
      #                                ["0.03967970", "0.0328", "0.0013"],
      #                                ["0.00000002", "10000.0000", "0.0002"],
      #                                ["0.00000001", "231840.7500", "0.0023"]],
      #                    coinPair =>   "eth_btc"                                  },
      #            time =>    1535974778,
      #       microtime =>   "0.04017400 1535974778",
      #          source =>   "api"                                                     }
      #
      orderbook = response['data']
      timestamp = self.parse_microtime(self.safe_string(response, 'microtime'))
      return self.parse_order_book(orderbook, timestamp)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #    { id =>  115807453,
      #       t => "19:36:24",
      #       T =>  1535974584,
      #       p => "0.03983296",
      #       n => "0.1000",
      #       s => "buy"         },
      #
      id = self.safe_string(trade, 'id')
      timestamp = self.safe_integer(trade, 'T')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      price = self.safe_float(trade, 'p')
      amount = self.safe_float(trade, 'n')
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      cost = self.price_to_precision(symbol, amount * price)
      side = self.safe_string(trade, 's')
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => id,
        'order' => nil,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.marketGetOrder(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      #
      #     {    status =>    200,
      #             msg =>   "",
      #            data => [{ id =>  115807453,
      #                       t => "19:36:24",
      #                       T =>  1535974584,
      #                       p => "0.03983296",
      #                       n => "0.1000",
      #                       s => "buy"         },
      #                    { id =>  115806811,
      #                       t => "19:33:19",
      #                       T =>  1535974399,
      #                       p => "0.03981135",
      #                       n => "9.4612",
      #                       s => "sell"        }  ],
      #            time =>    1535974583,
      #       microtime =>   "0.57118100 1535974583",
      #          source =>   "api"                     }
      #
      return self.parse_trades(response['data'], market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      #
      #      {     time => "1535973420000",
      #            open => "0.03975084",
      #            high => "0.03975084",
      #             low => "0.03967700",
      #           close => "0.03967700",
      #          volume => "12.4733",
      #        datetime => "2018-09-03 19:17:00" }
      #
      return [
        self.safe_integer(ohlcv, 'time'),
        self.safe_float(ohlcv, 'open'),
        self.safe_float(ohlcv, 'high'),
        self.safe_float(ohlcv, 'low'),
        self.safe_float(ohlcv, 'close'),
        self.safe_float(ohlcv, 'volume')
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      duration = self.parse_timeframe(timeframe) * 1000
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'resolution' => self.timeframes[timeframe]
      }
      if limit != nil
        request['size'] = minimum_wrapper(limit, 300) # 1-300
        if since != nil
          request['to'] = since + limit * duration * 1000
        end
      else
        if since != nil
          raise(ExchangeError, self.id + ' fetchOHLCV requires a limit argument if the since argument is specified')
        end
      end
      response = self.marketGetKline(self.shallow_extend(request, params))
      #
      #     {    status =>    200,
      #             msg =>   "",
      #            data => {       bars => [{     time => "1535973420000",
      #                                        open => "0.03975084",
      #                                        high => "0.03975084",
      #                                         low => "0.03967700",
      #                                       close => "0.03967700",
      #                                      volume => "12.4733",
      #                                    datetime => "2018-09-03 19:17:00" },
      #                                  {     time => "1535955480000",
      #                                        open => "0.04009900",
      #                                        high => "0.04016745",
      #                                         low => "0.04009900",
      #                                       close => "0.04012074",
      #                                      volume => "74.4803",
      #                                    datetime => "2018-09-03 14:18:00" }  ],
      #                    resolution =>   "1min",
      #                        symbol =>   "eth_btc",
      #                          from =>   "1535973420000",
      #                            to =>   "1535955480000",
      #                          size =>    300                                    },
      #            time =>    1535973435,
      #       microtime =>   "0.56462100 1535973435",
      #          source =>   "api"                                                    }
      #
      return self.parse_ohlcvs(response['data']['bars'], market, timeframe, since, limit)
    end

    def parse_order_status(status)
      statuses = {
        '0' => 'open',
        '1' => 'open', # partially filled
        '2' => 'closed', # filled
        '3' => 'canceled'
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      #
      # createOrder
      #
      #    {
      #         "id" => "693248739",   # order id
      #         "uId" => "2074056",    # uid
      #         "price" => "100",      # price
      #         "number" => "10",      # number
      #         "numberOver" => "10",  # undealed
      #         "flag" => "sale",      # flag
      #         "status" => "0",       # unfilled
      #         "coinFrom" => "vtc",
      #         "coinTo" => "dkkt",
      #         "numberDeal" => "0"    # dealed
      #     }
      #
      id = self.safe_string(order, 'id')
      symbol = nil
      if market.nil?
        baseId = self.safe_string(order, 'coinFrom')
        quoteId = self.safe_string(order, 'coinTo')
        if (baseId != nil) && (quoteId != nil)
          marketId = baseId + '_' + quoteId
          if self.markets_by_id.include?(marketId)
            market = self.safe_value(self.markets_by_id, marketId)
          else
            base = baseId.upcase
            quote = quoteId.upcase
            base = self.common_currency_code(base)
            quote = self.common_currency_code(quote)
            symbol = base + '/' + quote
          end
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      side = self.safe_string(order, 'flag')
      if side != nil
        side = (side == 'sale') ? 'sell' : 'buy'
      end
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'number')
      remaining = self.safe_float(order, 'numberOver')
      filled = self.safe_float(order, 'numberDeal')
      timestamp = self.safe_integer(order, 'timestamp')
      if timestamp.nil?
        timestamp = self.safe_integer(order, 'created')
        if timestamp != nil
          timestamp = timestamp * 1000
        end
      end
      cost = self.safe_float(order, 'orderTotalPrice')
      if price != nil
        if filled != nil
          cost = filled * price
        end
      end
      status = self.parse_order_status(self.safe_string(order, 'status'))
      return {
        'id' => id,
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => nil,
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      if type != 'limit'
        raise(ExchangeError, self.id + ' createOrder allows limit orders only')
      end
      market = self.market(symbol)
      orderType = (side == 'buy') ? '1' : '2'
      if !self.password
        raise(ExchangeError, self.id + ' createOrder requires you to set exchange.password = "YOUR_TRADING_PASSWORD"(a trade password is NOT THE SAME as your login password)')
      end
      request = {
        'symbol' => market['id'],
        'type' => orderType,
        'price' => self.price_to_precision(symbol, price),
        'number' => self.amount_to_precision(symbol, amount),
        'tradePwd' => self.password
      }
      response = self.tradePostAddEntrustSheet(self.shallow_extend(request, params))
      #
      #     {
      #         "status" => 200,
      #         "msg" => "",
      #         "data" => {
      #             "id" => "693248739",   # order id
      #             "uId" => "2074056",    # uid
      #             "price" => "100",      # price
      #             "number" => "10",      # number
      #             "numberOver" => "10",  # undealed
      #             "flag" => "sale",      # flag
      #             "status" => "0",       # unfilled
      #             "coinFrom" => "vtc",
      #             "coinTo" => "dkkt",
      #             "numberDeal" => "0"    # dealed
      #         },
      #         "time" => "1533035297",
      #         "microtime" => "0.41892000 1533035297",
      #         "source" => "api",
      #     }
      #
      timestamp = self.parse_microtime(self.safe_string(response, 'microtime'))
      order = self.shallow_extend({
        'timestamp' => timestamp
      }, response['data'])
      return self.parse_order(order, market)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.tradePostCancelEntrustSheet(self.shallow_extend({
        'entrustSheetId' => id
      }, params))
      #
      #     {
      #         "status":200,
      #         "msg":"",
      #         "data":{
      #             "updateAssetsData":{
      #                 "coin":"bz",
      #                 "over":"1000.00000000",
      #                 "lock":"-1000.00000000"
      #             },
      #             "assetsInfo":{
      #                 "coin":"bz",
      #                 "over":"9999.99999999",
      #                 "lock":"9999.99999999"
      #             }
      #         },
      #         "time":"1535464383",
      #         "microtime":"0.91558000 1535464383",
      #         "source":"api"
      #     }
      #
      return response
    end

    def cancel_orders(ids, symbol = nil, params = {})
      self.load_markets
      response = self.tradePostCancelEntrustSheet(self.shallow_extend({
        'ids' => ids.join(',')
      }, params))
      #
      #     {
      #         "status":200,
      #         "msg":"",
      #         "data":{
      #             "744173808":{
      #                 "updateAssetsData":{
      #                     "coin":"bz",
      #                     "over":"100.00000000",
      #                     "lock":"-100.00000000"
      #                 },
      #                 "assetsInfo":{
      #                     "coin":"bz",
      #                     "over":"899.99999999",
      #                     "lock":"19099.99999999"
      #                 }
      #             },
      #             "744173809":{
      #                 "updateAssetsData":{
      #                     "coin":"bz",
      #                     "over":"100.00000000",
      #                     "lock":"-100.00000000"
      #                 },
      #                 "assetsInfo":{
      #                     "coin":"bz",
      #                     "over":"999.99999999",
      #                     "lock":"18999.99999999"
      #                 }
      #             }
      #         },
      #         "time":"1535525649",
      #         "microtime":"0.05009400 1535525649",
      #         "source":"api"
      #     }
      #
      return response
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'entrustSheetId' => id
      }
      response = self.tradePostGetEntrustSheetInfo(self.shallow_extend(request, params))
      #
      #     {
      #         "status":200,
      #         "msg":"",
      #         "data":{
      #             "id":"708279852",
      #             "uId":"2074056",
      #             "price":"100.00000000",
      #             "number":"10.0000",
      #             "total":"0.00000000",
      #             "numberOver":"10.0000",
      #             "numberDeal":"0.0000",
      #             "flag":"sale",
      #             "status":"0",  #0:unfilled, 1:partial deal, 2:all transactions, 3:already cancelled
      #             "coinFrom":"bz",
      #             "coinTo":"usdt",
      #             "orderTotalPrice":"0",
      #             "created":"1533279876"
      #         },
      #         "time":"1533280294",
      #         "microtime":"0.36859200 1533280294",
      #         "source":"api"
      #     }
      #
      return self.parse_order(response['data'])
    end

    def fetch_orders_with_method(method, symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOpenOrders requires a symbol argument')
      end
      market = self.market(symbol)
      request = {
        'coinFrom' => market['baseId'],
        'coinTo' => market['quoteId'],
        # 'type' => 1, # optional integer, 1 = buy, 2 = sell
        # 'page' => 1, # optional integer
        # 'pageSize' => 100, # optional integer, max 100
        # 'startTime' => 1510235730, # optional integer timestamp in seconds
        # 'endTime' => 1510235730, # optional integer timestamp in seconds
      }
      if limit != nil
        request['page'] = 1
        request['pageSize'] = limit
      end
      if since != nil
        request['startTime'] = parse_int(since / 1000)
        # request['endTime'] = parse_int(since / 1000)
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      #
      #     {
      #         "status" => 200,
      #         "msg" => "",
      #         "data" => {
      #             "data" => [
      #                 {
      #                     "id" => "693248739",
      #                     "uid" => "2074056",
      #                     "price" => "100.00000000",
      #                     "number" => "10.0000",
      #                     "total" => "0.00000000",
      #                     "numberOver" => "0.0000",
      #                     "numberDeal" => "0.0000",
      #                     "flag" => "sale",
      #                     "status" => "3", # 0:unfilled, 1:partial deal, 2:all transactions, 3:already cancelled
      #                     "isNew" => "N",
      #                     "coinFrom" => "vtc",
      #                     "coinTo" => "dkkt",
      #                     "created" => "1533035300",
      #                 },
      #                 {
      #                     "id" => "723086996",
      #                     "uid" => "2074056",
      #                     "price" => "100.00000000",
      #                     "number" => "10.0000",
      #                     "total" => "0.00000000",
      #                     "numberOver" => "0.0000",
      #                     "numberDeal" => "0.0000",
      #                     "flag" => "sale",
      #                     "status" => "3",
      #                     "isNew" => "N",
      #                     "coinFrom" => "bz",
      #                     "coinTo" => "usdt",
      #                     "created" => "1533523568",
      #                 },
      #             ],
      #             "pageInfo" => {
      #                 "limit" => "10",
      #                 "offest" => "0",
      #                 "current_page" => "1",
      #                 "page_size" => "10",
      #                 "total_count" => "17",
      #                 "page_count" => "2",
      #             }
      #         },
      #         "time" => "1533279329",
      #         "microtime" => "0.15305300 1533279329",
      #         "source" => "api"
      #     }
      #
      orders = self.safe_value(response['data'], 'data')
      if orders
        return self.parse_orders(response['data']['data'], nil, since, limit)
      else
        return []
      end
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_with_method('tradePostGetUserHistoryEntrustSheet', symbol, since, limit, params)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_with_method('tradePostGetUserNowEntrustSheet', symbol, since, limit, params)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_with_method('tradePostGetUserHistoryEntrustSheet', symbol, since, limit, params)
    end

    def nonce
      currentTimestamp = self.seconds
      if currentTimestamp > self.options['lastNonceTimestamp']
        self.options['lastNonceTimestamp'] = currentTimestamp
        self.options['lastNonce'] = 100000
      end
      self.options['lastNonce'] = self.sum(self.options['lastNonce'], 1)
      return self.options['lastNonce']
    end

    def sign(path, api = 'market', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + self.capitalize(api) + '/' + path
      query = nil
      if api == 'market'
        query = self.urlencode(params)
        if query.length
          url += '?' + query
        end
      else
        self.check_required_credentials
        body = self.rawencode(self.keysort(self.shallow_extend({
          'apiKey' => self.apiKey,
          'timeStamp' => self.seconds,
          'nonce' => self.nonce
        }, params)))
        body += '&sign=' + self.hash(self.encode(body + self.secret))
        headers = { 'Content-type' => 'application/x-www-form-urlencoded' }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        status = self.safe_string(response, 'status')
        if status != nil
          feedback = self.id + ' ' + body
          exceptions = self.exceptions
          #
          #     {"status":-107,"msg":"","data":"","time":1535968848,"microtime":"0.89092200 1535968848","source":"api"}
          #
          if status == '200'
            #
            #     {"status":200,"msg":"","data":-200031,"time":1535999806,"microtime":"0.85476800 1535999806","source":"api"}
            #
            code = self.safe_integer(response, 'data')
            if code != nil
              if exceptions.include?(code)
                raise(exceptions[code], feedback)
              else
                raise(ExchangeError, feedback)
              end
            else
              return # no error
            end
          end
          if exceptions.include?(status)
            raise(exceptions[status], feedback)
          else
            raise(ExchangeError, feedback)
          end
        end
      end
    end
  end
end
