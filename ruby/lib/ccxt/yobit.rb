# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

require_relative 'liqui'

module Ccxt
  class Yobit < Liqui
    def describe
      return self.deep_extend(super, {
        'id' => 'yobit',
        'name' => 'YoBit',
        'countries' => ['RU'],
        'rateLimit' => 3000, # responses are cached every 2 seconds
        'version' => '3',
        'has' => {
          'createDepositAddress' => true,
          'fetchDepositAddress' => true,
          'fetchDeposits' => false,
          'fetchWithdrawals' => false,
          'fetchTransactions' => false,
          'CORS' => false,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg',
          'api' => {
            'public' => 'https://yobit.net/api',
            'private' => 'https://yobit.net/tapi'
          },
          'www' => 'https://www.yobit.net',
          'doc' => 'https://www.yobit.net/en/api/',
          'fees' => 'https://www.yobit.net/en/fees/'
        },
        'api' => {
          'public' => {
            'get' => [
              'depth/{pair}',
              'info',
              'ticker/{pair}',
              'trades/{pair}'
            ]
          },
          'private' => {
            'post' => [
              'ActiveOrders',
              'CancelOrder',
              'GetDepositAddress',
              'getInfo',
              'OrderInfo',
              'Trade',
              'TradeHistory',
              'WithdrawCoinsToAddress'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.002,
            'taker' => 0.002
          },
          'funding' => {
            'withdraw' => {}
          }
        },
        'commonCurrencies' => {
          'AIR' => 'AirCoin',
          'ANI' => 'ANICoin',
          'ANT' => 'AntsCoin',  # what is self, a coin for ants?
          'ATMCHA' => 'ATM',
          'ASN' => 'Ascension',
          'AST' => 'Astral',
          'ATM' => 'Autumncoin',
          'BCC' => 'BCH',
          'BCS' => 'BitcoinStake',
          'BLN' => 'Bulleon',
          'BOT' => 'BOTcoin',
          'BON' => 'BONES',
          'BPC' => 'BitcoinPremium',
          'BTS' => 'Bitshares2',
          'CAT' => 'BitClave',
          'CMT' => 'CometCoin',
          'COV' => 'Coven Coin',
          'COVX' => 'COV',
          'CPC' => 'Capricoin',
          'CS' => 'CryptoSpots',
          'DCT' => 'Discount',
          'DGD' => 'DarkGoldCoin',
          'DIRT' => 'DIRTY',
          'DROP' => 'FaucetCoin',
          'EKO' => 'EkoCoin',
          'ENTER' => 'ENTRC',
          'EPC' => 'ExperienceCoin',
          'ERT' => 'Eristica Token',
          'ESC' => 'EdwardSnowden',
          'EUROPE' => 'EUROP',
          'EXT' => 'LifeExtension',
          'FUNK' => 'FUNKCoin',
          'GCC' => 'GlobalCryptocurrency',
          'GEN' => 'Genstake',
          'GENE' => 'Genesiscoin',
          'GOLD' => 'GoldMint',
          'GOT' => 'Giotto Coin',
          'HTML5' => 'HTML',
          'HYPERX' => 'HYPER',
          'ICN' => 'iCoin',
          'INSANE' => 'INSN',
          'JNT' => 'JointCoin',
          'JPC' => 'JupiterCoin',
          'KNC' => 'KingN Coin',
          'LBTCX' => 'LiteBitcoin',
          'LIZI' => 'LiZi',
          'LOC' => 'LocoCoin',
          'LOCX' => 'LOC',
          'LUNYR' => 'LUN',
          'LUN' => 'LunarCoin',  # they just change the ticker if it is already taken
          'MDT' => 'Midnight',
          'NAV' => 'NavajoCoin',
          'NBT' => 'NiceBytes',
          'OMG' => 'OMGame',
          'PAC' => '$PAC',
          'PLAY' => 'PlayCoin',
          'PIVX' => 'Darknet',
          'PRS' => 'PRE',
          'PUTIN' => 'PUT',
          'STK' => 'StakeCoin',
          'SUB' => 'Subscriptio',
          'PAY' => 'EPAY',
          'PLC' => 'Platin Coin',
          'RCN' => 'RCoin',
          'REP' => 'Republicoin',
          'RUR' => 'RUB',
          'XIN' => 'XINCoin'
        },
        'options' => {
          'fetchOrdersRequiresSymbol' => true,
          'fetchTickersMaxLength' => 512
        },
        'exceptions' => {
          'broad' => {
            'Total transaction amount' => ExchangeError, # { "success" => 0, "error" => "Total transaction amount is less than minimal total => 0.00010000"}
            'Insufficient funds' => InsufficientFunds,
            'invalid key' => AuthenticationError
          }
        }
      })
    end

    def parse_order_status(status)
      statuses = {
        '0' => 'open',
        '1' => 'closed',
        '2' => 'canceled',
        '3' => 'open', # or partially-filled and closed? https://github.com/ccxt/ccxt/issues/1594
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostGetInfo
      balances = response['return']
      result = { 'info' => balances }
      sides = { 'free' => 'funds', 'total' => 'funds_incl_orders' }
      keys = sides.keys
      for i in (0...keys.length)
        key = keys[i]
        side = sides[key]
        if balances.include?(side)
          currencies = balances[side].keys
          for j in (0...currencies.length)
            lowercase = currencies[j]
            uppercase = lowercase.upcase
            currency = self.common_currency_code(uppercase)
            account = nil
            if result.include?(currency)
              account = result[currency]
            else
              account = self.account
            end
            account[key] = balances[side][lowercase]
            if (account['total'] != nil) && (account['free'] != nil)
              account['used'] = account['total'] - account['free']
            end
            result[currency] = account
          end
        end
      end
      return self.parse_balance(result)
    end

    def create_deposit_address(code, params = {})
      response = self.fetch_deposit_address(code, self.shallow_extend({
        'need_new' => 1
      }, params))
      address = self.safe_string(response, 'address')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => nil,
        'info' => response['info']
      }
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'coinName' => currency['id'],
        'need_new' => 0
      }
      response = self.privatePostGetDepositAddress(self.shallow_extend(request, params))
      address = self.safe_string(response['return'], 'address')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => nil,
        'info' => response
      }
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      # some derived classes use camelcase notation for request fields
      request = {
        # 'from' => 123456789, # trade ID, from which the display starts numerical 0(test result => liqui ignores self field)
        # 'count' => 1000, # the number of trades for display numerical, default = 1000
        # 'from_id' => trade ID, from which the display starts numerical 0
        # 'end_id' => trade ID on which the display ends numerical ∞
        # 'order' => 'ASC', # sorting, default = DESC(test result => liqui ignores self field, most recent trade always goes last)
        # 'since' => 1234567890, # UTC start time, default = 0(test result => liqui ignores self field)
        # 'end' => 1234567890, # UTC end time, default = ∞(test result => liqui ignores self field)
        # 'pair' => 'eth_btc', # default = all markets
      }
      if symbol != nil
        market = self.market(symbol)
        request['pair'] = market['id']
      end
      if limit != nil
        request['count'] = parse_int(limit)
      end
      if since != nil
        request['since'] = parse_int(since / 1000)
      end
      method = self.options['fetchMyTradesMethod']
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      trades = self.safe_value(response, 'return', {})
      ids = trades.keys
      result = []
      for i in (0...ids.length)
        id = ids[i]
        trade = self.parse_trade(self.shallow_extend(trades[id], {
          'trade_id' => id
        }), market)
        result.push(trade)
      end
      return self.filter_by_symbol_since_limit(result, symbol, since, limit)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostWithdrawCoinsToAddress(self.shallow_extend({
        'coinName' => currency['id'],
        'amount' => amount,
        'address' => address
      }, params))
      return {
        'info' => response,
        'id' => nil
      }
    end
  end
end
