# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Btctradeua < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'btctradeua',
        'name' => 'BTC Trade UA',
        'countries' => ['UA'], # Ukraine,
        'rateLimit' => 3000,
        'has' => {
          'CORS' => true,
          'createMarketOrder' => false,
          'fetchOpenOrders' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg',
          'api' => 'https://btc-trade.com.ua/api',
          'www' => 'https://btc-trade.com.ua',
          'doc' => 'https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit'
        },
        'api' => {
          'public' => {
            'get' => [
              'deals/{symbol}',
              'trades/sell/{symbol}',
              'trades/buy/{symbol}',
              'japan_stat/high/{symbol}'
            ]
          },
          'private' => {
            'post' => [
              'auth',
              'ask/{symbol}',
              'balance',
              'bid/{symbol}',
              'buy/{symbol}',
              'my_orders/{symbol}',
              'order/status/{id}',
              'remove/order/{id}',
              'sell/{symbol}'
            ]
          }
        },
        'markets' => {
          'BCH/UAH' => { 'id' => 'bch_uah', 'symbol' => 'BCH/UAH', 'base' => 'BCH', 'quote' => 'UAH' },
          'BTC/UAH' => { 'id' => 'btc_uah', 'symbol' => 'BTC/UAH', 'base' => 'BTC', 'quote' => 'UAH', 'precision' => { 'price' => 1 }, 'limits' => { 'amount' => { 'min' => 0.0000000001 }}},
          'DASH/BTC' => { 'id' => 'dash_btc', 'symbol' => 'DASH/BTC', 'base' => 'DASH', 'quote' => 'BTC' },
          'DASH/UAH' => { 'id' => 'dash_uah', 'symbol' => 'DASH/UAH', 'base' => 'DASH', 'quote' => 'UAH' },
          'DOGE/BTC' => { 'id' => 'doge_btc', 'symbol' => 'DOGE/BTC', 'base' => 'DOGE', 'quote' => 'BTC' },
          'DOGE/UAH' => { 'id' => 'doge_uah', 'symbol' => 'DOGE/UAH', 'base' => 'DOGE', 'quote' => 'UAH' },
          'ETH/UAH' => { 'id' => 'eth_uah', 'symbol' => 'ETH/UAH', 'base' => 'ETH', 'quote' => 'UAH' },
          'ITI/UAH' => { 'id' => 'iti_uah', 'symbol' => 'ITI/UAH', 'base' => 'ITI', 'quote' => 'UAH' },
          'KRB/UAH' => { 'id' => 'krb_uah', 'symbol' => 'KRB/UAH', 'base' => 'KRB', 'quote' => 'UAH' },
          'LTC/BTC' => { 'id' => 'ltc_btc', 'symbol' => 'LTC/BTC', 'base' => 'LTC', 'quote' => 'BTC' },
          'LTC/UAH' => { 'id' => 'ltc_uah', 'symbol' => 'LTC/UAH', 'base' => 'LTC', 'quote' => 'UAH' },
          'NVC/BTC' => { 'id' => 'nvc_btc', 'symbol' => 'NVC/BTC', 'base' => 'NVC', 'quote' => 'BTC' },
          'NVC/UAH' => { 'id' => 'nvc_uah', 'symbol' => 'NVC/UAH', 'base' => 'NVC', 'quote' => 'UAH' },
          'PPC/BTC' => { 'id' => 'ppc_btc', 'symbol' => 'PPC/BTC', 'base' => 'PPC', 'quote' => 'BTC' },
          'SIB/UAH' => { 'id' => 'sib_uah', 'symbol' => 'SIB/UAH', 'base' => 'SIB', 'quote' => 'UAH' },
          'XMR/UAH' => { 'id' => 'xmr_uah', 'symbol' => 'XMR/UAH', 'base' => 'XMR', 'quote' => 'UAH' },
          'ZEC/UAH' => { 'id' => 'zec_uah', 'symbol' => 'ZEC/UAH', 'base' => 'ZEC', 'quote' => 'UAH' }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.1 / 100,
            'taker' => 0.1 / 100
          },
          'funding' => {
            'withdraw' => {
              'BTC' => 0.0006,
              'LTC' => 0.01,
              'NVC' => 0.01,
              'DOGE' => 10
            }
          }
        }
      })
    end

    def sign_in(params = {})
      return self.privatePostAuth(params)
    end

    def fetch_balance(params = {})
      response = self.privatePostBalance
      result = { 'info' => response }
      if response.include?('accounts')
        accounts = response['accounts']
        for b in (0...accounts.length)
          account = accounts[b]
          currency = account['currency']
          balance = parse_float(account['balance'])
          result[currency] = {
            'free' => balance,
            'used' => 0.0,
            'total' => balance
          }
        end
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      market = self.market(symbol)
      bids = self.publicGetTradesBuySymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      asks = self.publicGetTradesSellSymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      orderbook = {
        'bids' => [],
        'asks' => []
      }
      if bids
        if bids.include?('list')
          orderbook['bids'] = bids['list']
        end
      end
      if asks
        if asks.include?('list')
          orderbook['asks'] = asks['list']
        end
      end
      return self.parse_order_book(orderbook, nil, 'bids', 'asks', 'price', 'currency_trade')
    end

    def fetch_ticker(symbol, params = {})
      response = self.publicGetJapanStatHighSymbol(self.shallow_extend({
        'symbol' => self.market_id(symbol)
      }, params))
      ticker = response['trades']
      timestamp = self.milliseconds
      result = {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => nil,
        'bidVolume' => nil,
        'ask' => nil,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => nil,
        'last' => nil,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => nil,
        'quoteVolume' => nil,
        'info' => ticker
      }
      tickerLength = ticker.length
      if tickerLength > 0
        start = maximum_wrapper(tickerLength - 48, 0)
        for t in (start...ticker.length)
          candle = ticker[t]
          if result['open'].nil?
            result['open'] = candle[1]
          end
          if (result['high'].nil?) || (result['high'] < candle[2])
            result['high'] = candle[2]
          end
          if (result['low'].nil?) || (result['low'] > candle[3])
            result['low'] = candle[3]
          end
          if result['baseVolume'].nil?
            result['baseVolume'] = -candle[5]
          else
            result['baseVolume'] -= candle[5]
          end
        end
        last = tickerLength - 1
        result['last'] = ticker[last][4]
        result['close'] = result['last']
        result['baseVolume'] = -1 * result['baseVolume']
      end
      return result
    end

    def convert_cyrillic_month_name_to_string(cyrillic)
      months = {
        'января' => '01',
        'февраля' => '02',
        'марта' => '03',
        'апреля' => '04',
        'мая' => '05',
        'июня' => '06',
        'июля' => '07',
        'августа' => '08',
        'сентября' => '09',
        'октября' => '10',
        'ноября' => '11',
        'декабря' => '12'
      }
      month = nil
      if months.include?(cyrillic)
        month = months[cyrillic]
      end
      return month
    end

    def parse_cyrillic_datetime(cyrillic)
      parts = cyrillic.split(' ')
      day = parts[0]
      month = self.convert_cyrillic_month_name_to_string(parts[1])
      if !month
        raise(ExchangeError, self.id + ' parseTrade nil month name => ' + cyrillic)
      end
      year = parts[2]
      hms = parts[4]
      hmsLength = hms.length
      if hmsLength == 7
        hms = '0' + hms
      end
      if day.length == 1
        day = '0' + day
      end
      ymd = '-'.join([year, month, day])
      ymdhms = ymd + 'T' + hms
      timestamp = self.parse8601(ymdhms)
      # server reports local time, adjust to UTC
      md = ''.join([month, day])
      md = parse_int(md)
      # a special case for DST
      # subtract 2 hours during winter
      if md < 325 || md > 1028
        return timestamp - 7200000
      end
      # subtract 3 hours during summer
      return timestamp - 10800000
    end

    def parse_trade(trade, market)
      timestamp = self.parse_cyrillic_datetime(trade['pub_date'])
      return {
        'id' => trade['id'].to_s,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => 'limit',
        'side' => trade['type'],
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'amnt_trade')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetDealsSymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      # they report each trade twice(once for both of the two sides of the fill)
      # deduplicate trades for that reason
      trades = []
      for i in (0...response.length)
        if response[i]['id'] % 2
          trades.push(response[i])
        end
      end
      return self.parse_trades(trades, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      market = self.market(symbol)
      method = 'privatePost' + self.capitalize(side) + 'Id'
      order = {
        'count' => amount,
        'currency1' => market['quote'],
        'currency' => market['base'],
        'price' => price
      }
      return self.send_wrapper(method, self.shallow_extend(order, params))
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostRemoveOrderId({ 'id' => id })
    end

    def parse_order(trade, market)
      timestamp = self.milliseconds
      return {
        'id' => trade['id'],
        'timestamp' => timestamp, # until they fix their timestamp
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => 'open',
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => trade['type'],
        'price' => trade['price'],
        'amount' => trade['amnt_trade'],
        'filled' => 0,
        'remaining' => trade['amnt_trade'],
        'trades' => nil,
        'info' => trade
      }
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOpenOrders requires a symbol argument')
      end
      market = self.market(symbol)
      response = self.privatePostMyOrdersSymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      orders = response['your_open_orders']
      return self.parse_orders(orders, market, since, limit)
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query.size > 0
          url += self.implode_params(path, query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({
          'out_order_id' => nonce,
          'nonce' => nonce
        }, query))
        auth = body + self.secret
        headers = {
          'public-key' => self.apiKey,
          'api-sign' => self.hash(self.encode(auth), 'sha256'),
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
