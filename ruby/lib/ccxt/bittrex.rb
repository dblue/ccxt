# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bittrex < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bittrex',
        'name' => 'Bittrex',
        'countries' => ['US'],
        'version' => 'v1.1',
        'rateLimit' => 1500,
        'certified' => true,
        # new metainfo interface
        'has' => {
          'CORS' => true,
          'createMarketOrder' => false,
          'fetchDepositAddress' => true,
          'fetchClosedOrders' => true,
          'fetchCurrencies' => true,
          'fetchMyTrades' => 'emulated',
          'fetchOHLCV' => true,
          'fetchOrder' => true,
          'fetchOpenOrders' => true,
          'fetchTickers' => true,
          'withdraw' => true,
          'fetchDeposits' => true,
          'fetchWithdrawals' => true,
          'fetchTransactions' => false
        },
        'timeframes' => {
          '1m' => 'oneMin',
          '5m' => 'fiveMin',
          '30m' => 'thirtyMin',
          '1h' => 'hour',
          '1d' => 'day'
        },
        'hostname' => 'bittrex.com',
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766352-cf0b3c26-5ed5-11e7-82b7-f3826b7a97d8.jpg',
          'api' => {
            'public' => 'https://{hostname}/api',
            'account' => 'https://{hostname}/api',
            'market' => 'https://{hostname}/api',
            'v2' => 'https://{hostname}/api/v2.0/pub'
          },
          'www' => 'https://bittrex.com',
          'doc' => [
            'https://bittrex.github.io/api/',
            'https://www.npmjs.com/package/bittrex-node'
          ],
          'fees' => [
            'https://bittrex.zendesk.com/hc/en-us/articles/115003684371-BITTREX-SERVICE-FEES-AND-WITHDRAWAL-LIMITATIONS',
            'https://bittrex.zendesk.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-'
          ]
        },
        'api' => {
          'v2' => {
            'get' => [
              'currencies/GetBTCPrice',
              'market/GetTicks',
              'market/GetLatestTick',
              'Markets/GetMarketSummaries',
              'market/GetLatestTick'
            ]
          },
          'public' => {
            'get' => [
              'currencies',
              'markethistory',
              'markets',
              'marketsummaries',
              'marketsummary',
              'orderbook',
              'ticker'
            ]
          },
          'account' => {
            'get' => [
              'balance',
              'balances',
              'depositaddress',
              'deposithistory',
              'order',
              'orders',
              'orderhistory',
              'withdrawalhistory',
              'withdraw'
            ]
          },
          'market' => {
            'get' => [
              'buylimit',
              'buymarket',
              'cancel',
              'openorders',
              'selllimit',
              'sellmarket'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.0025,
            'taker' => 0.0025
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {
              'BTC' => 0.0005,
              'LTC' => 0.01,
              'DOGE' => 2,
              'VTC' => 0.02,
              'PPC' => 0.02,
              'FTC' => 0.2,
              'RDD' => 2,
              'NXT' => 2,
              'DASH' => 0.05,
              'POT' => 0.002,
              'BLK' => 0.02,
              'EMC2' => 0.2,
              'XMY' => 0.2,
              'GLD' => 0.0002,
              'SLR' => 0.2,
              'GRS' => 0.2
            },
            'deposit' => {
              'BTC' => 0,
              'LTC' => 0,
              'DOGE' => 0,
              'VTC' => 0,
              'PPC' => 0,
              'FTC' => 0,
              'RDD' => 0,
              'NXT' => 0,
              'DASH' => 0,
              'POT' => 0,
              'BLK' => 0,
              'EMC2' => 0,
              'XMY' => 0,
              'GLD' => 0,
              'SLR' => 0,
              'GRS' => 0
            }
          }
        },
        'exceptions' => {
          # 'Call to Cancel was throttled. Try again in 60 seconds.' => DDoSProtection,
          # 'Call to GetBalances was throttled. Try again in 60 seconds.' => DDoSProtection,
          'APISIGN_NOT_PROVIDED' => AuthenticationError,
          'INVALID_SIGNATURE' => AuthenticationError,
          'INVALID_CURRENCY' => ExchangeError,
          'INVALID_PERMISSION' => AuthenticationError,
          'INSUFFICIENT_FUNDS' => InsufficientFunds,
          'QUANTITY_NOT_PROVIDED' => InvalidOrder,
          'MIN_TRADE_REQUIREMENT_NOT_MET' => InvalidOrder,
          'ORDER_NOT_OPEN' => OrderNotFound,
          'INVALID_ORDER' => InvalidOrder,
          'UUID_INVALID' => OrderNotFound,
          'RATE_NOT_PROVIDED' => InvalidOrder, # createLimitBuyOrder('ETH/BTC', 1, 0)
          'WHITELIST_VIOLATION_IP' => PermissionDenied,
          'DUST_TRADE_DISALLOWED_MIN_VALUE' => InvalidOrder
        },
        'options' => {
          # price precision by quote currency code
          'pricePrecisionByCode' => {
            'USD' => 3
          },
          'parseOrderStatus' => false,
          'hasAlreadyAuthenticatedSuccessfully' => false, # a workaround for APIKEY_INVALID
          'symbolSeparator' => '-',
          # With certain currencies, like
          # AEON, BTS, GXS, NXT, SBD, STEEM, STR, XEM, XLM, XMR, XRP
          # an additional tag / memo / payment id is usually required by exchanges.
          # With Bittrex some currencies imply the "base address + tag" logic.
          # The base address for depositing is stored on self.currencies[code]
          # The base address identifies the exchange as the recipient
          # while the tag identifies the user account within the exchange
          # and the tag is retrieved with fetchDepositAddress.
          'tag' => {
            'NXT' => true, # NXT, BURST
            'CRYPTO_NOTE_PAYMENTID' => true, # AEON, XMR
            'BITSHAREX' => true, # BTS
            'RIPPLE' => true, # XRP
            'NEM' => true, # XEM
            'STELLAR' => true, # XLM
            'STEEM' => true, # SBD, GOLOS
            # https://github.com/ccxt/ccxt/issues/4794
            # 'LISK' => true, # LSK
          }
        },
        'commonCurrencies' => {
          'BITS' => 'SWIFT',
          'CPC' => 'CapriCoin'
        }
      })
    end

    def cost_to_precision(symbol, cost)
      return self.decimal_to_precision(cost, TRUNCATE, self.markets[symbol]['precision']['price'], DECIMAL_PLACES)
    end

    def fee_to_precision(symbol, fee)
      return self.decimal_to_precision(fee, TRUNCATE, self.markets[symbol]['precision']['price'], DECIMAL_PLACES)
    end

    async def fetch_markets(params = {})
      # https://github.com/ccxt/ccxt/commit/866370ba6c9cabaf5995d992c15a82e38b8ca291
      # https://github.com/ccxt/ccxt/pull/4304
      response = await{ self.publicGetMarkets }
      result = []
      markets = self.safe_value(response, 'result')
      for i in (0...markets.length)
        market = markets[i]
        id = market['MarketName']
        baseId = market['MarketCurrency']
        quoteId = market['BaseCurrency']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        pricePrecision = 8
        if self.options['pricePrecisionByCode'].include?(quote)
          pricePrecision = self.options['pricePrecisionByCode'][quote]
        end
        precision = {
          'amount' => 8,
          'price' => pricePrecision
        }
        # bittrex uses boolean values, bleutrade uses strings
        active = self.safe_value(market, 'IsActive', false)
        if (active != 'false') || active
          active = true
        end
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'info' => market,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => market['MinTradeSize'],
              'max' => nil
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            }
          }
        })
      end
      return result
    end

    async def fetch_balance(params = {})
      await{ self.load_markets }
      response = await{ self.accountGetBalances(params) }
      balances = response['result']
      result = { 'info' => balances }
      indexed = self.index_by(balances, 'Currency')
      keys = indexed.keys
      for i in (0...keys.length)
        id = keys[i]
        currency = self.common_currency_code(id)
        account = self.account
        balance = indexed[id]
        free = self.safe_float(balance, 'Available', 0)
        total = self.safe_float(balance, 'Balance', 0)
        used = nil
        if total != nil
          if free != nil
            used = total - free
          end
        end
        account['free'] = free
        account['used'] = used
        account['total'] = total
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    async def fetch_order_book(symbol, limit = nil, params = {})
      await{ self.load_markets }
      response = await{ self.publicGetOrderbook(self.shallow_extend({
        'market' => self.market_id(symbol),
        'type' => 'both'
      }, params)) }
      orderbook = response['result']
      if params.include?('type')
        if params['type'] == 'buy'
          orderbook = {
            'buy' => response['result'],
            'sell' => []
          }
        elsif params['type'] == 'sell'
          orderbook = {
            'buy' => [],
            'sell' => response['result']
          }
        end
      end
      return self.parse_order_book(orderbook, nil, 'buy', 'sell', 'Rate', 'Quantity')
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.safe_string(ticker, 'TimeStamp')
      if timestamp.is_a?(String)
        if timestamp.length > 0
          timestamp = self.parse8601(timestamp)
        end
      end
      symbol = nil
      if market
        symbol = market['symbol']
      end
      previous = self.safe_float(ticker, 'PrevDay')
      last = self.safe_float(ticker, 'Last')
      change = nil
      percentage = nil
      if last != nil
        if previous != nil
          change = last - previous
          if previous > 0
            percentage = (change / previous) * 100
          end
        end
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'High'),
        'low' => self.safe_float(ticker, 'Low'),
        'bid' => self.safe_float(ticker, 'Bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'Ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => previous,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => percentage,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'Volume'),
        'quoteVolume' => self.safe_float(ticker, 'BaseVolume'),
        'info' => ticker
      }
    end

    async def fetch_currencies(params = {})
      response = await{ self.publicGetCurrencies(params) }
      #
      #     {
      #         "success" => true,
      #         "message" => "",
      #         "result" => [
      #             {
      #                 "Currency" => "BTC",
      #                 "CurrencyLong":"Bitcoin",
      #                 "MinConfirmation":2,
      #                 "TxFee":0.00050000,
      #                 "IsActive":true,
      #                 "IsRestricted":false,
      #                 "CoinType":"BITCOIN",
      #                 "BaseAddress":"1N52wHoVR79PMDishab2XmRHsbekCdGquK",
      #                 "Notice":null
      #             },
      #             ...,
      #         ]
      #     }
      #
      currencies = self.safe_value(response, 'result', [])
      result = {}
      for i in (0...currencies.length)
        currency = currencies[i]
        id = self.safe_string(currency, 'Currency')
        # todo => will need to rethink the fees
        # to add support for multiple withdrawal/deposit methods and
        # differentiated fees for each particular method
        code = self.common_currency_code(id)
        precision = 8 # default precision, todo => fix "magic constants"
        address = self.safe_value(currency, 'BaseAddress')
        fee = self.safe_float(currency, 'TxFee') # todo => redesign
        result[code] = {
          'id' => id,
          'code' => code,
          'address' => address,
          'info' => currency,
          'type' => currency['CoinType'],
          'name' => currency['CurrencyLong'],
          'active' => currency['IsActive'],
          'fee' => fee,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'withdraw' => {
              'min' => fee,
              'max' => 10**precision
            }
          }
        }
      end
      return result
    end

    async def fetch_tickers(symbols = nil, params = {})
      await{ self.load_markets }
      response = await{ self.publicGetMarketsummaries(params) }
      tickers = response['result']
      result = {}
      for t in (0...tickers.length)
        ticker = tickers[t]
        id = ticker['MarketName']
        market = nil
        symbol = id
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        else
          symbol = self.parse_symbol(id)
        end
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    async def fetch_ticker(symbol, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      response = await{ self.publicGetMarketsummary(self.shallow_extend({
        'market' => market['id']
      }, params)) }
      ticker = response['result'][0]
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(trade['TimeStamp'] + '+00:00')
      side = nil
      if trade['OrderType'] == 'BUY'
        side = 'buy'
      elsif trade['OrderType'] == 'SELL'
        side = 'sell'
      end
      id = self.safe_string_2(trade, 'Id', 'ID')
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      cost = nil
      price = self.safe_float(trade, 'Price')
      amount = self.safe_float(trade, 'Quantity')
      if amount != nil
        if price != nil
          cost = price * amount
        end
      end
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => id,
        'order' => nil,
        'type' => 'limit',
        'takerOrMaker' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil
      }
    end

    async def fetch_trades(symbol, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      response = await{ self.publicGetMarkethistory(self.shallow_extend({
        'market' => market['id']
      }, params)) }
      if response.include?('result')
        if response['result'] != nil
          return self.parse_trades(response['result'], market, since, limit)
        end
      end
      raise(ExchangeError, self.id + ' fetchTrades returned nil response')
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1d', since = nil, limit = nil)
      timestamp = self.parse8601(ohlcv['T'] + '+00:00')
      return [
        timestamp,
        ohlcv['O'],
        ohlcv['H'],
        ohlcv['L'],
        ohlcv['C'],
        ohlcv['V']
      ]
    end

    async def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      request = {
        'tickInterval' => self.timeframes[timeframe],
        'marketName' => market['id']
      }
      response = await{ self.v2GetMarketGetTicks(self.shallow_extend(request, params)) }
      if response.include?('result')
        if response['result']
          return self.parse_ohlcvs(response['result'], market, timeframe, since, limit)
        end
      end
    end

    async def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      request = {}
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['market'] = market['id']
      end
      response = await{ self.marketGetOpenorders(self.shallow_extend(request, params)) }
      orders = self.parse_orders(response['result'], market, since, limit)
      return self.filter_by_symbol(orders, symbol)
    end

    async def create_order(symbol, type, side, amount, price = nil, params = {})
      if type != 'limit'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      await{ self.load_markets }
      market = self.market(symbol)
      method = 'marketGet' + self.capitalize(side) + type
      order = {
        'market' => market['id'],
        'quantity' => self.amount_to_precision(symbol, amount),
        'rate' => self.price_to_precision(symbol, price)
      }
      # if type == 'limit'
      #     order['rate'] = self.price_to_precision(symbol, price)
      response = await{ self.send_wrapper(method, self.shallow_extend(order, params)) }
      orderIdField = self.get_order_id_field
      result = {
        'info' => response,
        'id' => response['result'][orderIdField],
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'status' => 'open'
      }
      return result
    end

    def get_order_id_field
      return 'uuid'
    end

    async def cancel_order(id, symbol = nil, params = {})
      await{ self.load_markets }
      orderIdField = self.get_order_id_field
      request = {}
      request[orderIdField] = id
      response = await{ self.marketGetCancel(self.shallow_extend(request, params)) }
      return self.shallow_extend(self.parse_order(response), {
        'status' => 'canceled'
      })
    end

    async def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      # https://support.bittrex.com/hc/en-us/articles/115003723911
      request = {}
      currency = nil
      if code != nil
        currency = self.currency(code)
        request['currency'] = currency['id']
      end
      response = await{ self.accountGetDeposithistory(self.shallow_extend(request, params)) }
      #
      #     { success =>    true,
      #       message =>   "",
      #        result => [{            Id =>  22578097,
      #                           Amount =>  0.3,
      #                         Currency => "ETH",
      #                    Confirmations =>  15,
      #                      LastUpdated => "2018-06-10T07:12:10.57",
      #                             TxId => "0xf50b5ba2ca5438b58f93516eaa523eaf35b4420ca0f24061003df1be7…",
      #                    CryptoAddress => "0xb25f281fa51f1635abd4a60b0870a62d2a7fa404"                    }] }
      #
      # we cannot filter by `since` timestamp, as it isn't set by Bittrex
      # see https://github.com/ccxt/ccxt/issues/4067
      # return self.parseTransactions(response['result'], currency, since, limit)
      return self.parseTransactions(response['result'], currency, nil, limit)
    end

    async def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      # https://support.bittrex.com/hc/en-us/articles/115003723911
      request = {}
      currency = nil
      if code != nil
        currency = self.currency(code)
        request['currency'] = currency['id']
      end
      response = await{ self.accountGetWithdrawalhistory(self.shallow_extend(request, params)) }
      #
      #     {
      #         "success" : true,
      #         "message" : "",
      #         "result" : [{
      #                 "PaymentUuid" : "b32c7a5c-90c6-4c6e-835c-e16df12708b1",
      #                 "Currency" : "BTC",
      #                 "Amount" : 17.00000000,
      #                 "Address" : "1DfaaFBdbB5nrHj87x3NHS4onvw1GPNyAu",
      #                 "Opened" : "2014-07-09T04:24:47.217",
      #                 "Authorized" : true,
      #                 "PendingPayment" : false,
      #                 "TxCost" : 0.00020000,
      #                 "TxId" : null,
      #                 "Canceled" : true,
      #                 "InvalidAddress" : false
      #             }, {
      #                 "PaymentUuid" : "d193da98-788c-4188-a8f9-8ec2c33fdfcf",
      #                 "Currency" : "XC",
      #                 "Amount" : 7513.75121715,
      #                 "Address" : "TcnSMgAd7EonF2Dgc4c9K14L12RBaW5S5J",
      #                 "Opened" : "2014-07-08T23:13:31.83",
      #                 "Authorized" : true,
      #                 "PendingPayment" : false,
      #                 "TxCost" : 0.00002000,
      #                 "TxId" : "d8a575c2a71c7e56d02ab8e26bb1ef0a2f6cf2094f6ca2116476a569c1e84f6e",
      #                 "Canceled" : false,
      #                 "InvalidAddress" : false
      #             }
      #         ]
      #     }
      #
      return self.parseTransactions(response['result'], currency, since, limit)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchDeposits
      #
      #      {            Id =>  72578097,
      #               Amount =>  0.3,
      #             Currency => "ETH",
      #        Confirmations =>  15,
      #          LastUpdated => "2018-06-17T07:12:14.57",
      #                 TxId => "0xb31b5ba2ca5438b58f93516eaa523eaf35b4420ca0f24061003df1be7…",
      #        CryptoAddress => "0x2d5f281fa51f1635abd4a60b0870a62d2a7fa404"                    }
      #
      # fetchWithdrawals
      #
      #     {
      #         "PaymentUuid" : "e293da98-788c-4188-a8f9-8ec2c33fdfcf",
      #         "Currency" : "XC",
      #         "Amount" : 7513.75121715,
      #         "Address" : "EVnSMgAd7EonF2Dgc4c9K14L12RBaW5S5J",
      #         "Opened" : "2014-07-08T23:13:31.83",
      #         "Authorized" : true,
      #         "PendingPayment" : false,
      #         "TxCost" : 0.00002000,
      #         "TxId" : "b4a575c2a71c7e56d02ab8e26bb1ef0a2f6cf2094f6ca2116476a569c1e84f6e",
      #         "Canceled" : false,
      #         "InvalidAddress" : false
      #     }
      #
      id = self.safe_string_2(transaction, 'Id', 'PaymentUuid')
      amount = self.safe_float(transaction, 'Amount')
      address = self.safe_string_2(transaction, 'CryptoAddress', 'Address')
      txid = self.safe_string(transaction, 'TxId')
      updated = self.parse8601(self.safe_value(transaction, 'LastUpdated'))
      timestamp = self.parse8601(self.safe_string(transaction, 'Opened', updated))
      type = (timestamp != nil) ? 'withdrawal' : 'deposit'
      code = nil
      currencyId = self.safe_string(transaction, 'Currency')
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency != nil
        code = currency['code']
      else
        code = self.common_currency_code(currencyId)
      end
      status = 'pending'
      if type == 'deposit'
        if currency != nil
          # deposits numConfirmations never reach the minConfirmations number
          # we set all of them to 'ok', otherwise they'd all be 'pending'
          #
          #     numConfirmations = self.safe_integer(transaction, 'Confirmations', 0)
          #     minConfirmations = self.safe_integer(currency['info'], 'MinConfirmation')
          #     if numConfirmations >= minConfirmations
          #         status = 'ok'
          #     }
          #
          status = 'ok'
        end
      else
        authorized = self.safe_value(transaction, 'Authorized', false)
        pendingPayment = self.safe_value(transaction, 'PendingPayment', false)
        canceled = self.safe_value(transaction, 'Canceled', false)
        invalidAddress = self.safe_value(transaction, 'InvalidAddress', false)
        if invalidAddress
          status = 'failed'
        elsif canceled
          status = 'canceled'
        elsif pendingPayment
          status = 'pending'
        elsif authorized && (txid != nil)
          status = 'ok'
        end
      end
      feeCost = self.safe_float(transaction, 'TxCost')
      if feeCost.nil?
        if type == 'deposit'
          # according to https://support.bittrex.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-
          feeCost = 0 # FIXME => remove hardcoded value that may change any time
        elsif type == 'withdrawal'
          raise(ExchangeError, 'Withdrawal without fee detected!')
        end
      end
      return {
        'info' => transaction,
        'id' => id,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => nil,
        'status' => status,
        'type' => type,
        'updated' => updated,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => {
          'currency' => code,
          'cost' => feeCost
        }
      }
    end

    def parse_symbol(id)
      quote, base = id.split(self.options['symbolSeparator'])
      base = self.common_currency_code(base)
      quote = self.common_currency_code(quote)
      return base + '/' + quote
    end

    def parse_order(order, market = nil)
      side = self.safe_string_2(order, 'OrderType', 'Type')
      isBuyOrder = (side == 'LIMIT_BUY') || (side == 'BUY')
      isSellOrder = (side == 'LIMIT_SELL') || (side == 'SELL')
      if isBuyOrder
        side = 'buy'
      end
      if isSellOrder
        side = 'sell'
      end
      # We parse different fields in a very specific order.
      # Order might well be closed and then canceled.
      status = nil
      if order.include?(('Opened')) && order['Opened']
        status = 'open'
      end
      if order.include?(('Closed')) && order['Closed']
        status = 'closed'
      end
      if order.include?(('CancelInitiated')) && order['CancelInitiated']
        status = 'canceled'
      end
      if order.include?(('Status')) && self.options['parseOrderStatus']
        status = self.parse_order_status(self.safe_string(order, 'Status'))
      end
      symbol = nil
      if order.include?('Exchange')
        marketId = order['Exchange']
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
          symbol = market['symbol']
        else
          symbol = self.parse_symbol(marketId)
        end
      else
        if market != nil
          symbol = market['symbol']
        end
      end
      timestamp = nil
      if order.include?('Opened')
        timestamp = self.parse8601(order['Opened'] + '+00:00')
      end
      if order.include?('Created')
        timestamp = self.parse8601(order['Created'] + '+00:00')
      end
      lastTradeTimestamp = nil
      if order.include?(('TimeStamp')) && (order['TimeStamp'] != nil)
        lastTradeTimestamp = self.parse8601(order['TimeStamp'] + '+00:00')
      end
      if order.include?(('Closed')) && (order['Closed'] != nil)
        lastTradeTimestamp = self.parse8601(order['Closed'] + '+00:00')
      end
      if timestamp.nil?
        timestamp = lastTradeTimestamp
      end
      fee = nil
      commission = nil
      if order.include?('Commission')
        commission = 'Commission'
      elsif order.include?('CommissionPaid')
        commission = 'CommissionPaid'
      end
      if commission
        fee = {
          'cost' => order[commission].to_f
        }
        if market != nil
          fee['currency'] = market['quote']
        elsif symbol != nil
          currencyIds = symbol.split('/')
          quoteCurrencyId = currencyIds[1]
          if self.currencies_by_id.include?(quoteCurrencyId)
            fee['currency'] = self.currencies_by_id[quoteCurrencyId]['code']
          else
            fee['currency'] = self.common_currency_code(quoteCurrencyId)
          end
        end
      end
      price = self.safe_float(order, 'Limit')
      cost = self.safe_float(order, 'Price')
      amount = self.safe_float(order, 'Quantity')
      remaining = self.safe_float(order, 'QuantityRemaining')
      filled = nil
      if amount != nil && remaining != nil
        filled = amount - remaining
        if (status == 'closed') && (remaining > 0)
          status = 'canceled'
        end
      end
      if !cost
        if price && filled
          cost = price * filled
        end
      end
      if !price
        if cost && filled
          price = cost / filled
        end
      end
      average = self.safe_float(order, 'PricePerUnit')
      id = self.safe_string_2(order, 'OrderUuid', 'OrderId')
      return {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => average,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee
      }
    end

    async def fetch_order(id, symbol = nil, params = {})
      await{ self.load_markets }
      response = nil
      begin
        orderIdField = self.get_order_id_field
        request = {}
        request[orderIdField] = id
        response = await{ self.accountGetOrder(self.shallow_extend(request, params)) }
      rescue BaseError => e
        if self.last_json_response
          message = self.safe_string(self.last_json_response, 'message')
          if message == 'UUID_INVALID'
            raise(OrderNotFound, self.id + ' fetchOrder error => ' + self.last_http_response)
          end
        end
        raise e
      end
      if !response['result']
        raise(OrderNotFound, self.id + ' order ' + id + ' not found')
      end
      return self.parse_order(response['result'])
    end

    def order_to_trade(order)
      # self entire method should be moved to the base class
      timestamp = self.safe_integer_2(order, 'lastTradeTimestamp', 'timestamp')
      return {
        'id' => self.safe_string(order, 'id'),
        'side' => self.safe_string(order, 'side'),
        'order' => self.safe_string(order, 'id'),
        'price' => self.safe_float(order, 'average'),
        'amount' => self.safe_float(order, 'filled'),
        'cost' => self.safe_float(order, 'cost'),
        'symbol' => self.safe_string(order, 'symbol'),
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => self.safe_value(order, 'fee'),
        'info' => order
      }
    end

    def orders_to_trades(orders)
      # self entire method should be moved to the base class
      result = []
      for i in (0...orders.length)
        result.push(self.order_to_trade(orders[i]))
      end
      return result
    end

    async def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      orders = await{ self.fetch_closed_orders(symbol, since, limit, params) }
      return self.orders_to_trades(orders)
    end

    async def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      request = {}
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['market'] = market['id']
      end
      response = await{ self.accountGetOrderhistory(self.shallow_extend(request, params)) }
      orders = self.parse_orders(response['result'], market, since, limit)
      if symbol != nil
        return self.filter_by_symbol(orders, symbol)
      end
      return orders
    end

    async def fetch_deposit_address(code, params = {})
      await{ self.load_markets }
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = await{ self.accountGetDepositaddress(self.shallow_extend(request, params)) }
      #
      #     { "success" => false, "message" => "ADDRESS_GENERATING", "result" => null }
      #
      #     { success =>    true,
      #       message =>   "",
      #        result => { Currency => "INCNT",
      #                   Address => "3PHvQt9bK21f7eVQVdJzrNPcsMzXabEA5Ha" } } }
      #
      address = self.safe_string(response['result'], 'Address')
      message = self.safe_string(response, 'message')
      if !address || message == 'ADDRESS_GENERATING'
        raise(AddressPending, self.id + ' the address for ' + code + ' is being generated(pending, not ready yet, retry again later)')
      end
      tag = nil
      if self.options['tag'].include?(currency['type'])
        tag = address
        address = currency['address']
      end
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    async def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      await{ self.load_markets }
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'quantity' => amount,
        'address' => address
      }
      if tag
        request['paymentid'] = tag
      end
      response = await{ self.accountGetWithdraw(self.shallow_extend(request, params)) }
      id = nil
      if response.include?('result')
        if response['result'].include?('uuid')
          id = response['result']['uuid']
        end
      end
      return {
        'info' => response,
        'id' => id
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.implode_params(self.urls['api'][api], {
        'hostname' => self.hostname
      }) + '/'
      if api != 'v2'
        url += self.version + '/'
      end
      if api == 'public'
        url += api + '/' + method.downcase + path
        if params
          url += '?' + self.urlencode(params)
        end
      elsif api == 'v2'
        url += path
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        url += api + '/'
        if ((api == 'account') && (path != 'withdraw')) || (path == 'openorders')
          url += method.downcase
        end
        request = {
          'apikey' => self.apiKey
        }
        disableNonce = self.safe_value(self.options, 'disableNonce')
        if (disableNonce.nil?) || !disableNonce
          request['nonce'] = self.nonce
        end
        url += path + '?' + self.urlencode(self.shallow_extend(request, params))
        signature = self.hmac(self.encode(url), self.encode(self.secret), 'sha512')
        headers = { 'apisign' => signature }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if body[0] == '{'
        # { success => false, message => "message" }
        success = self.safe_value(response, 'success')
        if success.nil?
          raise(ExchangeError, self.id + ' => malformed response => ' + self.json(response))
        end
        if success.is_a?(String)
          # bleutrade uses string instead of boolean
          success = (success == 'true') ? true : false
        end
        if !success
          message = self.safe_string(response, 'message')
          feedback = self.id + ' ' + self.json(response)
          exceptions = self.exceptions
          if message == 'APIKEY_INVALID'
            if self.options['hasAlreadyAuthenticatedSuccessfully']
              raise(DDoSProtection, feedback)
            else
              raise(AuthenticationError, feedback)
            end
          end
          # https://github.com/ccxt/ccxt/issues/4932
          # the following two lines are now redundant, see line 171 in describe
          #
          #     if message == 'DUST_TRADE_DISALLOWED_MIN_VALUE_50K_SAT'
          #         raise(InvalidOrder, self.id + ' order cost should be over 50k satoshi ' + self.json(response))
          #
          if message == 'INVALID_ORDER'
            # Bittrex will return an ambiguous INVALID_ORDER message
            # upon canceling already-canceled and closed orders
            # therefore self special case for cancelOrder
            # url = 'https://bittrex.com/api/v1.1/market/cancel?apikey=API_KEY&uuid=ORDER_UUID'
            cancel = 'cancel'
            indexOfCancel = url.include?($2)
            if indexOfCancel >= 0
              parts = url.split('&')
              orderId = nil
              for i in (0...parts.length)
                part = parts[i]
                keyValue = part.split('=')
                if keyValue[0] == 'uuid'
                  orderId = keyValue[1]
                  break
                end
              end
              if orderId != nil
                raise(OrderNotFound, self.id + ' cancelOrder ' + orderId + ' ' + self.json(response))
              else
                raise(OrderNotFound, self.id + ' cancelOrder ' + self.json(response))
              end
            end
          end
          if exceptions.include?(message)
            raise(exceptions[message], feedback)
          end
          if message != nil
            if message.include?('throttled. Try again')
              raise(DDoSProtection, feedback)
            end
            if message.include?('problem')
              raise(ExchangeNotAvailable, feedback)
            end # 'There was a problem processing your request.  If self problem persists, please contact...')
          end
          raise(ExchangeError, feedback)
        end
      end
    end

    def append_timezone_parse8601(x)
      length = x.length
      lastSymbol = x[length - 1]
      if (lastSymbol == 'Z') || (x.include?('+'))
        return self.parse8601(x)
      end
      return self.parse8601(x + 'Z')
    end

    async def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = await{ self.fetch2(path, api, method, params, headers, body) }
      # a workaround for APIKEY_INVALID
      if (api == 'account') || (api == 'market')
        self.options['hasAlreadyAuthenticatedSuccessfully'] = true
      end
      return response
    end
  end
end
