# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Zaif < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'zaif',
        'name' => 'Zaif',
        'countries' => ['JP'],
        'rateLimit' => 2000,
        'version' => '1',
        'has' => {
          'CORS' => false,
          'createMarketOrder' => false,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg',
          'api' => 'https://api.zaif.jp',
          'www' => 'https://zaif.jp',
          'doc' => [
            'https://techbureau-api-document.readthedocs.io/ja/latest/index.html',
            'https://corp.zaif.jp/api-docs',
            'https://corp.zaif.jp/api-docs/api_links',
            'https://www.npmjs.com/package/zaif.jp',
            'https://github.com/you21979/node-zaif'
          ],
          'fees' => 'https://zaif.jp/fee?lang=en'
        },
        'fees' => {
          'trading' => {
            'percentage' => true,
            'taker' => 0.1 / 100,
            'maker' => 0
          }
        },
        'api' => {
          'public' => {
            'get' => [
              'depth/{pair}',
              'currencies/{pair}',
              'currencies/all',
              'currency_pairs/{pair}',
              'currency_pairs/all',
              'last_price/{pair}',
              'ticker/{pair}',
              'trades/{pair}'
            ]
          },
          'private' => {
            'post' => [
              'active_orders',
              'cancel_order',
              'deposit_history',
              'get_id_info',
              'get_info',
              'get_info2',
              'get_personal_info',
              'trade',
              'trade_history',
              'withdraw',
              'withdraw_history'
            ]
          },
          'ecapi' => {
            'post' => [
              'createInvoice',
              'getInvoice',
              'getInvoiceIdsByOrderNumber',
              'cancelInvoice'
            ]
          },
          'tlapi' => {
            'post' => [
              'get_positions',
              'position_history',
              'active_positions',
              'create_position',
              'change_position',
              'cancel_position'
            ]
          },
          'fapi' => {
            'get' => [
              'groups/{group_id}',
              'last_price/{group_id}/{pair}',
              'ticker/{group_id}/{pair}',
              'trades/{group_id}/{pair}',
              'depth/{group_id}/{pair}'
            ]
          }
        },
        'options' => {
          # zaif schedule defines several market-specific fees
          'fees' => {
            'BTC/JPY' => { 'maker' => 0, 'taker' => 0 },
            'BCH/JPY' => { 'maker' => 0, 'taker' => 0.3 / 100 },
            'BCH/BTC' => { 'maker' => 0, 'taker' => 0.3 / 100 },
            'PEPECASH/JPY' => { 'maker' => 0, 'taker' => 0.01 / 100 },
            'PEPECASH/BT' => { 'maker' => 0, 'taker' => 0.01 / 100 }
          }
        },
        'exceptions' => {
          'exact' => {
            'unsupported currency_pair' => BadRequest, # {"error" => "unsupported currency_pair"}
          },
          'broad' => {
          }
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetCurrencyPairsAll
      result = []
      for p in (0...markets.length)
        market = markets[p]
        id = market['currency_pair']
        symbol = market['name']
        base, quote = symbol.split('/')
        precision = {
          'amount' => -Math.log10(market['item_unit_step']),
          'price' => market['aux_unit_point']
        }
        fees = self.safe_value(self.options['fees'], symbol, self.fees['trading'])
        taker = fees['taker']
        maker = fees['maker']
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'active' => true, # can trade or not
          'precision' => precision,
          'taker' => taker,
          'maker' => maker,
          'limits' => {
            'amount' => {
              'min' => self.safe_float(market, 'item_unit_min'),
              'max' => nil
            },
            'price' => {
              'min' => self.safe_float(market, 'aux_unit_min'),
              'max' => nil
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostGetInfo
      balances = response['return']
      result = { 'info' => balances }
      currencies = balances['funds'].keys
      for c in (0...currencies.length)
        currency = currencies[c]
        balance = balances['funds'][currency]
        uppercase = currency.upcase
        account = {
          'free' => balance,
          'used' => 0.0,
          'total' => balance
        }
        if balances.include?('deposit')
          if balances['deposit'].include?(currency)
            account['total'] = balances['deposit'][currency]
            account['used'] = account['total'] - account['free']
          end
        end
        result[uppercase] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetDepthPair(self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook)
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      ticker = self.publicGetTickerPair(self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      timestamp = self.milliseconds
      vwap = ticker['vwap']
      baseVolume = ticker['volume']
      quoteVolume = nil
      if baseVolume != nil && vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = ticker['last']
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => ticker['high'],
        'low' => ticker['low'],
        'bid' => ticker['bid'],
        'bidVolume' => nil,
        'ask' => ticker['ask'],
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      side = (trade['trade_type'] == 'bid') ? 'buy' : 'sell'
      timestamp = trade['date'] * 1000
      id = self.safe_string(trade, 'id')
      id = self.safe_string(trade, 'tid', id)
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      if !market
        market = self.markets_by_id[trade['currency_pair']]
      end
      return {
        'id' => id.to_s,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTradesPair(self.shallow_extend({
        'pair' => market['id']
      }, params))
      numTrades = response.length
      if numTrades == 1
        firstTrade = response[0]
        if !firstTrade
          response = []
        end
      end
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      response = self.privatePostTrade(self.shallow_extend({
        'currency_pair' => self.market_id(symbol),
        'action' => (side == 'buy') ? 'bid' : 'ask',
        'amount' => amount,
        'price' => price
      }, params))
      return {
        'info' => response,
        'id' => response['return']['order_id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancelOrder(self.shallow_extend({
        'order_id' => id
      }, params))
    end

    def parse_order(order, market = nil)
      side = (order['action'] == 'bid') ? 'buy' : 'sell'
      timestamp = parse_int(order['timestamp']) * 1000
      if !market
        market = self.markets_by_id[order['currency_pair']]
      end
      price = order['price']
      amount = order['amount']
      return {
        'id' => order['id'].to_s,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => 'open',
        'symbol' => market['symbol'],
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => price * amount,
        'amount' => amount,
        'filled' => nil,
        'remaining' => nil,
        'trades' => nil,
        'fee' => nil
      }
    end

    def parse_orders(orders, market = nil, since = nil, limit = nil)
      ids = orders.keys
      result = []
      for i in (0...ids.length)
        id = ids[i]
        order = orders[id]
        extended = self.shallow_extend(order, { 'id' => id })
        result.push(self.parse_order(extended, market))
      end
      return self.filter_by_since_limit(result, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      request = {
        # 'is_token' => false,
        # 'is_token_both' => false
      }
      if symbol != nil
        market = self.market(symbol)
        request['currency_pair'] = market['id']
      end
      response = self.privatePostActiveOrders(self.shallow_extend(request, params))
      return self.parse_orders(response['return'], market, since, limit)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      request = {
        # 'from' => 0,
        # 'count' => 1000,
        # 'from_id' => 0,
        # 'end_id' => 1000,
        # 'order' => 'DESC',
        # 'since' => 1503821051,
        # 'end' => 1503821051,
        # 'is_token' => false
      }
      if symbol != nil
        market = self.market(symbol)
        request['currency_pair'] = market['id']
      end
      response = self.privatePostTradeHistory(self.shallow_extend(request, params))
      return self.parse_orders(response['return'], market, since, limit)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      if code == 'JPY'
        raise(ExchangeError, self.id + ' withdraw does not allow ' + code + ' withdrawals')
      end
      request = {
        'currency' => currency['id'],
        'amount' => amount,
        'address' => address,
        # 'message' => 'Hi!', # XEM and others
        # 'opt_fee' => 0.003, # BTC and MONA only
      }
      if tag != nil
        request['message'] = tag
      end
      result = self.privatePostWithdraw(self.shallow_extend(request, params))
      return {
        'info' => result,
        'id' => result['return']['txid'],
        'fee' => result['return']['fee']
      }
    end

    def nonce
      nonce = parse_float(self.milliseconds / 1000)
      return nonce.to_f
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/'
      if api == 'public'
        url += 'api/' + self.version + '/' + self.implode_params(path, params)
      elsif api == 'fapi'
        url += 'fapi/' + self.version + '/' + self.implode_params(path, params)
      else
        self.check_required_credentials
        if api == 'ecapi'
          url += 'ecapi'
        elsif api == 'tlapi'
          url += 'tlapi'
        else
          url += 'tapi'
        end
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({
          'method' => path,
          'nonce' => nonce
        }, params))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Key' => self.apiKey,
          'Sign' => self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if response.nil?
        return
      end
      #
      #     {"error" => "unsupported currency_pair"}
      #
      feedback = self.id + ' ' + body
      error = self.safe_string(response, 'error')
      if error != nil
        exact = self.exceptions['exact']
        if exact.include?(error)
          raise(exact[error], feedback)
        end
        broad = self.exceptions['broad']
        broadKey = self.findBroadlyMatchedKey(broad, error)
        if broadKey != nil
          raise(broad[broadKey], feedback)
        end
        raise(ExchangeError, feedback) # unknown message
      end
      success = self.safe_value(response, 'success', true)
      if !success
        raise(ExchangeError, feedback)
      end
    end
  end
end
