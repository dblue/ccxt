# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bitso < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bitso',
        'name' => 'Bitso',
        'countries' => ['MX'], # Mexico
        'rateLimit' => 2000, # 30 requests per minute
        'version' => 'v3',
        'has' => {
          'CORS' => true,
          'fetchMyTrades' => true,
          'fetchOpenOrders' => true,
          'fetchOrder' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766335-715ce7aa-5ed5-11e7-88a8-173a27bb30fe.jpg',
          'api' => 'https://api.bitso.com',
          'www' => 'https://bitso.com',
          'doc' => 'https://bitso.com/api_info',
          'fees' => 'https://bitso.com/fees?l=es',
          'referral' => 'https://bitso.com/?ref=itej'
        },
        'api' => {
          'public' => {
            'get' => [
              'available_books',
              'ticker',
              'order_book',
              'trades'
            ]
          },
          'private' => {
            'get' => [
              'account_status',
              'balance',
              'fees',
              'fundings',
              'fundings/{fid}',
              'funding_destination',
              'kyc_documents',
              'ledger',
              'ledger/trades',
              'ledger/fees',
              'ledger/fundings',
              'ledger/withdrawals',
              'mx_bank_codes',
              'open_orders',
              'order_trades/{oid}',
              'orders/{oid}',
              'user_trades',
              'user_trades/{tid}',
              'withdrawals/',
              'withdrawals/{wid}'
            ],
            'post' => [
              'bitcoin_withdrawal',
              'debit_card_withdrawal',
              'ether_withdrawal',
              'ripple_withdrawal',
              'bcash_withdrawal',
              'litecoin_withdrawal',
              'orders',
              'phone_number',
              'phone_verification',
              'phone_withdrawal',
              'spei_withdrawal',
              'ripple_withdrawal',
              'bcash_withdrawal',
              'litecoin_withdrawal'
            ],
            'delete' => [
              'orders/{oid}',
              'orders/all'
            ]
          }
        },
        'exceptions' => {
          '0201' => AuthenticationError, # Invalid Nonce or Invalid Credentials
          '104' => InvalidNonce, # Cannot perform request - nonce must be higher than 1520307203724237
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetAvailableBooks
      result = []
      for i in (0...markets['payload'].length)
        market = markets['payload'][i]
        id = market['book']
        symbol = id.upcase.gsub('_', '/')
        base, quote = symbol.split('/')
        limits = {
          'amount' => {
            'min' => self.safe_float(market, 'minimum_amount'),
            'max' => self.safe_float(market, 'maximum_amount')
          },
          'price' => {
            'min' => self.safe_float(market, 'minimum_price'),
            'max' => self.safe_float(market, 'maximum_price')
          },
          'cost' => {
            'min' => self.safe_float(market, 'minimum_value'),
            'max' => self.safe_float(market, 'maximum_value')
          }
        }
        precision = {
          'amount' => self.precision_from_string(market['minimum_amount']),
          'price' => self.precision_from_string(market['minimum_price'])
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'info' => market,
          'limits' => limits,
          'precision' => precision
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetBalance
      balances = response['payload']['balances']
      result = { 'info' => response }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency'].upcase
        account = {
          'free' => parse_float(balance['available']),
          'used' => parse_float(balance['locked']),
          'total' => parse_float(balance['total'])
        }
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      response = self.publicGetOrderBook(self.shallow_extend({
        'book' => self.market_id(symbol)
      }, params))
      orderbook = response['payload']
      timestamp = self.parse8601(orderbook['updated_at'])
      return self.parse_order_book(orderbook, timestamp, 'bids', 'asks', 'price', 'amount')
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      response = self.publicGetTicker(self.shallow_extend({
        'book' => self.market_id(symbol)
      }, params))
      ticker = response['payload']
      timestamp = self.parse8601(ticker['created_at'])
      vwap = self.safe_float(ticker, 'vwap')
      baseVolume = self.safe_float(ticker, 'volume')
      quoteVolume = nil
      if baseVolume != nil && vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(trade['created_at'])
      symbol = nil
      if market.nil?
        marketId = self.safe_string(trade, 'book')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      side = self.safe_string(trade, 'side')
      if side.nil?
        side = self.safe_string(trade, 'maker_side')
      end
      amount = self.safe_float(trade, 'amount')
      if amount.nil?
        amount = self.safe_float(trade, 'major')
      end
      if amount != nil
        amount = amount.abs
      end
      fee = nil
      feeCost = self.safe_float(trade, 'fees_amount')
      if feeCost != nil
        feeCurrency = self.safe_string(trade, 'fees_currency')
        if feeCurrency != nil
          if self.currencies_by_id.include?(feeCurrency)
            feeCurrency = self.currencies_by_id[feeCurrency]['code']
          end
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      cost = self.safe_float(trade, 'minor')
      if cost != nil
        cost = cost.abs
      end
      price = self.safe_float(trade, 'price')
      orderId = self.safe_string(trade, 'oid')
      return {
        'id' => trade['tid'].to_s,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => orderId,
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTrades(self.shallow_extend({
        'book' => market['id']
      }, params))
      return self.parse_trades(response['payload'], market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = 25, params = {})
      self.load_markets
      market = self.market(symbol)
      # the don't support fetching trades starting from a date yet
      # use the `marker` extra param for that
      # self is not a typo, the variable name is 'marker'(don't confuse with 'market')
      markerInParams = (params.include?('marker'))
      # warn the user with an exception if the user wants to filter
      # starting from since timestamp, but does not set the trade id with an extra 'marker' param
      if (since != nil) && !markerInParams
        raise ExchangeError(self.id + ' fetchMyTrades does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id')
      end
      # convert it to an integer unconditionally
      if markerInParams
        params = self.shallow_extend(params, {
          'marker' => parse_int(params['marker'])
        })
      end
      request = {
        'book' => market['id'],
        'limit' => limit, # default = 25, max = 100
        # 'sort' => 'desc', # default = desc
        # 'marker' => id, # integer id to start from
      }
      response = self.privateGetUserTrades(self.shallow_extend(request, params))
      return self.parse_trades(response['payload'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      order = {
        'book' => self.market_id(symbol),
        'side' => side,
        'type' => type,
        'major' => self.amount_to_precision(symbol, amount)
      }
      if type == 'limit'
        order['price'] = self.price_to_precision(symbol, price)
      end
      response = self.privatePostOrders(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['payload']['oid']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privateDeleteOrdersOid({ 'oid' => id })
    end

    def parse_order_status(status)
      statuses = {
        'partial-fill' => 'open', # self is a common substitution in ccxt
        'completed' => 'closed'
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      id = self.safe_string(order, 'oid')
      side = self.safe_string(order, 'side')
      status = self.parse_order_status(self.safe_string(order, 'status'))
      symbol = nil
      marketId = self.safe_string(order, 'book')
      if marketId != nil
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        else
          baseId, quoteId = marketId.split('_')
          base = self.common_currency_code(baseId.upcase)
          quote = self.common_currency_code(quoteId.upcase)
          symbol = base + '/' + quote
        end
      end
      if symbol.nil?
        if market != nil
          symbol = market['symbol']
        end
      end
      orderType = self.safe_string(order, 'type')
      timestamp = self.parse8601(self.safe_string(order, 'created_at'))
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'original_amount')
      remaining = self.safe_float(order, 'unfilled_amount')
      filled = nil
      if amount != nil
        if remaining != nil
          filled = amount - remaining
        end
      end
      return {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => orderType,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => nil,
        'remaining' => remaining,
        'filled' => filled,
        'status' => status,
        'fee' => nil
      }
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = 25, params = {})
      self.load_markets
      market = self.market(symbol)
      # the don't support fetching trades starting from a date yet
      # use the `marker` extra param for that
      # self is not a typo, the variable name is 'marker'(don't confuse with 'market')
      markerInParams = (params.include?('marker'))
      # warn the user with an exception if the user wants to filter
      # starting from since timestamp, but does not set the trade id with an extra 'marker' param
      if (since != nil) && !markerInParams
        raise ExchangeError(self.id + ' fetchOpenOrders does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id')
      end
      # convert it to an integer unconditionally
      if markerInParams
        params = self.shallow_extend(params, {
          'marker' => parse_int(params['marker'])
        })
      end
      request = {
        'book' => market['id'],
        'limit' => limit, # default = 25, max = 100
        # 'sort' => 'desc', # default = desc
        # 'marker' => id, # integer id to start from
      }
      response = self.privateGetOpenOrders(self.shallow_extend(request, params))
      orders = self.parse_orders(response['payload'], market, since, limit)
      return orders
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privateGetOrdersOid({
        'oid' => id
      })
      payload = self.safe_value(response, 'payload')
      if payload.is_a?(Array)
        numOrders = response['payload'].length
        if numOrders == 1
          return self.parse_order(payload[0])
        end
      end
      raise(OrderNotFound, self.id + ' => The order ' + id + ' not found.')
    end

    def fetch_order_trades(id, symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privateGetOrderTradesOid({
        'oid' => id
      })
      return self.parse_trades(response['payload'], market)
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'fund_currency' => currency['id']
      }
      response = self.privateGetFundingDestination(self.shallow_extend(request, params))
      address = self.safe_string(response['payload'], 'account_identifier')
      tag = nil
      if code == 'XRP'
        parts = address.split('?dt=')
        address = parts[0]
        tag = parts[1]
      end
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      methods = {
        'BTC' => 'Bitcoin',
        'ETH' => 'Ether',
        'XRP' => 'Ripple',
        'BCH' => 'Bcash',
        'LTC' => 'Litecoin'
      }
      method = (methods.include?(code)) ? methods[code] : nil
      if method.nil?
        raise(ExchangeError, self.id + ' not valid withdraw coin => ' + code)
      end
      request = {
        'amount' => amount,
        'address' => address,
        'destination_tag' => tag
      }
      classMethod = 'privatePost' + method + 'Withdrawal'
      response = self.send_wrapper(classMethod, self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => self.safe_string(response['payload'], 'wid')
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      endpoint = '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if method == 'GET'
        if query
          endpoint += '?' + self.urlencode(query)
        end
      end
      url = self.urls['api'] + endpoint
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce.to_s
        request = ''.join([nonce, method, endpoint])
        if method != 'GET'
          if query
            body = self.json(query)
            request += body
          end
        end
        signature = self.hmac(self.encode(request), self.encode(self.secret))
        auth = self.apiKey + ':' + nonce + ':' + signature
        headers = {
          'Authorization' => 'Bitso ' + auth,
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        if response.include?('success')
          #
          #     {"success":false,"error":{"code":104,"message":"Cannot perform request - nonce must be higher than 1520307203724237"}}
          #
          success = self.safe_value(response, 'success', false)
          if success.is_a?(String)
            if (success == 'true') || (success == '1')
              success = true
            else
              success = false
            end
          end
          if !success
            feedback = self.id + ' ' + self.json(response)
            error = self.safe_value(response, 'error')
            if error.nil?
              raise(ExchangeError, feedback)
            end
            code = self.safe_string(error, 'code')
            exceptions = self.exceptions
            if exceptions.include?(code)
              raise(exceptions[code], feedback)
            else
              raise(ExchangeError, feedback)
            end
          end
        end
      end
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('success')
        if response['success']
          return response
        end
      end
      raise(ExchangeError, self.id + ' ' + self.json(response))
    end
  end
end
