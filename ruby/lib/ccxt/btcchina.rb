# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Btcchina < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'btcchina',
        'name' => 'BTCChina',
        'countries' => ['CN'],
        'rateLimit' => 1500,
        'version' => 'v1',
        'has' => {
          'CORS' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766368-465b3286-5ed6-11e7-9a11-0f6467e1d82b.jpg',
          'api' => {
            'plus' => 'https://plus-api.btcchina.com/market',
            'public' => 'https://data.btcchina.com/data',
            'private' => 'https://api.btcchina.com/api_trade_v1.php'
          },
          'www' => 'https://www.btcchina.com',
          'doc' => 'https://www.btcchina.com/apidocs'
        },
        'api' => {
          'plus' => {
            'get' => [
              'orderbook',
              'ticker',
              'trade'
            ]
          },
          'public' => {
            'get' => [
              'historydata',
              'orderbook',
              'ticker',
              'trades'
            ]
          },
          'private' => {
            'post' => [
              'BuyIcebergOrder',
              'BuyOrder',
              'BuyOrder2',
              'BuyStopOrder',
              'CancelIcebergOrder',
              'CancelOrder',
              'CancelStopOrder',
              'GetAccountInfo',
              'getArchivedOrder',
              'getArchivedOrders',
              'GetDeposits',
              'GetIcebergOrder',
              'GetIcebergOrders',
              'GetMarketDepth',
              'GetMarketDepth2',
              'GetOrder',
              'GetOrders',
              'GetStopOrder',
              'GetStopOrders',
              'GetTransactions',
              'GetWithdrawal',
              'GetWithdrawals',
              'RequestWithdrawal',
              'SellIcebergOrder',
              'SellOrder',
              'SellOrder2',
              'SellStopOrder'
            ]
          }
        },
        'markets' => {
          'BTC/CNY' => { 'id' => 'btccny', 'symbol' => 'BTC/CNY', 'base' => 'BTC', 'quote' => 'CNY', 'api' => 'public', 'plus' => false },
          'LTC/CNY' => { 'id' => 'ltccny', 'symbol' => 'LTC/CNY', 'base' => 'LTC', 'quote' => 'CNY', 'api' => 'public', 'plus' => false },
          'LTC/BTC' => { 'id' => 'ltcbtc', 'symbol' => 'LTC/BTC', 'base' => 'LTC', 'quote' => 'BTC', 'api' => 'public', 'plus' => false },
          'BCH/CNY' => { 'id' => 'bcccny', 'symbol' => 'BCH/CNY', 'base' => 'BCH', 'quote' => 'CNY', 'api' => 'plus', 'plus' => true },
          'ETH/CNY' => { 'id' => 'ethcny', 'symbol' => 'ETH/CNY', 'base' => 'ETH', 'quote' => 'CNY', 'api' => 'plus', 'plus' => true }
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetTicker({
        'market' => 'all'
      })
      result = []
      keys = markets.keys
      for p in (0...keys.length)
        key = keys[p]
        market = markets[key]
        parts = key.split('_')
        id = parts[1]
        base = id[0...3]
        quote = id[3...6]
        base = base.upcase
        quote = quote.upcase
        symbol = base + '/' + quote
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostGetAccountInfo
      balances = response['result']
      result = { 'info' => balances }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        lowercase = currency.downcase
        account = self.account
        if balances['balance'].include?(lowercase)
          account['total'] = parse_float(balances['balance'][lowercase]['amount'])
        end
        if balances['frozen'].include?(lowercase)
          account['used'] = parse_float(balances['frozen'][lowercase]['amount'])
        end
        account['free'] = account['total'] - account['used']
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def create_market_request(market)
      request = {}
      field = (market['plus']) ? 'symbol' : 'market'
      request[field] = market['id']
      return request
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      method = market['api'] + 'GetOrderbook'
      request = self.create_market_request(market)
      orderbook = self.send_wrapper(method, self.shallow_extend(request, params))
      timestamp = orderbook['date'] * 1000
      return self.parse_order_book(orderbook, timestamp)
    end

    def parse_ticker(ticker, market)
      timestamp = ticker['date'] * 1000
      last = self.safe_float(ticker, 'last')
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'ask' => self.safe_float(ticker, 'sell'),
        'vwap' => self.safe_float(ticker, 'vwap'),
        'open' => self.safe_float(ticker, 'open'),
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def parse_ticker_plus(ticker, market)
      timestamp = ticker['Timestamp']
      symbol = nil
      if market
        symbol = market['symbol']
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'High'),
        'low' => self.safe_float(ticker, 'Low'),
        'bid' => self.safe_float(ticker, 'BidPrice'),
        'ask' => self.safe_float(ticker, 'AskPrice'),
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'Open'),
        'last' => self.safe_float(ticker, 'Last'),
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'Volume24H'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      method = market['api'] + 'GetTicker'
      request = self.create_market_request(market)
      tickers = self.send_wrapper(method, self.shallow_extend(request, params))
      ticker = tickers['ticker']
      if market['plus']
        return self.parse_ticker_plus(ticker, market)
      end
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      timestamp = parse_int(trade['date']) * 1000
      return {
        'id' => trade['tid'],
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => nil,
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def parse_trade_plus(trade, market)
      timestamp = self.parse8601(trade['timestamp'])
      return {
        'id' => nil,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => trade['side'].downcase,
        'price' => trade['price'],
        'amount' => trade['size']
      }
    end

    def parse_trades_plus(trades, market = nil)
      result = []
      for i in (0...trades.length)
        result.push(self.parse_trade_plus(trades[i], market))
      end
      return result
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      method = market['api'] + 'GetTrade'
      request = self.create_market_request(market)
      if market['plus']
        now = self.milliseconds
        request['start_time'] = now - 86400 * 1000
        request['end_time'] = now
      else
        method += 's' # trades vs trade
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      if market['plus']
        return self.parse_trades_plus(response['trades'], market)
      end
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      method = 'privatePost' + self.capitalize(side) + 'Order2'
      order = {}
      id = market['id'].upcase
      if type == 'market'
        order['params'] = [nil, amount, id]
      else
        order['params'] = [price, amount, id]
      end
      response = self.send_wrapper(method, self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['id']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      market = params['market'] # TODO fixme
      return self.privatePostCancelOrder(self.shallow_extend({
        'params' => [id, market]
      }, params))
    end

    def nonce
      return self.microseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + path
      if api == 'private'
        self.check_required_credentials
        p = []
        if params.include?('params')
          p = params['params']
        end
        nonce = self.nonce
        request = {
          'method' => path,
          'id' => nonce,
          'params' => p
        }
        p = p.join(',')
        body = self.json(request)
        query = (
          'tonce=' + nonce
          + '&accesskey=' + self.apiKey
          + '&requestmethod=' + method.downcase
          + '&id=' + nonce
          + '&method=' + path
          + '&params=' + p
        )
        signature = self.hmac(self.encode(query), self.encode(self.secret), 'sha1')
        auth = self.encode(self.apiKey + ':' + signature)
        headers = {
          'Authorization' => 'Basic ' + Base64.encode64(auth),
          'Json-Rpc-Tonce' => nonce
        }
      else
        if params
          url += '?' + self.urlencode(params)
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
