# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coinmarketcap < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coinmarketcap',
        'name' => 'CoinMarketCap',
        'rateLimit' => 10000,
        'version' => 'v1',
        'countries' => ['US'],
        'has' => {
          'CORS' => true,
          'privateAPI' => false,
          'createOrder' => false,
          'createMarketOrder' => false,
          'createLimitOrder' => false,
          'cancelOrder' => false,
          'editOrder' => false,
          'fetchBalance' => false,
          'fetchOrderBook' => false,
          'fetchL2OrderBook' => false,
          'fetchOHLCV' => false,
          'fetchTrades' => false,
          'fetchTickers' => true,
          'fetchCurrencies' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/28244244-9be6312a-69ed-11e7-99c1-7c1797275265.jpg',
          'api' => {
            'public' => 'https://api.coinmarketcap.com',
            'files' => 'https://files.coinmarketcap.com',
            'charts' => 'https://graph.coinmarketcap.com'
          },
          'www' => 'https://coinmarketcap.com',
          'doc' => 'https://coinmarketcap.com/api'
        },
        'requiredCredentials' => {
          'apiKey' => false,
          'secret' => false
        },
        'api' => {
          'files' => {
            'get' => [
              'generated/stats/global.json'
            ]
          },
          'graphs' => {
            'get' => [
              'currencies/{name}/'
            ]
          },
          'public' => {
            'get' => [
              'ticker/',
              'ticker/{id}/',
              'global/'
            ]
          }
        },
        'currencyCodes' => [
          'AUD',
          'BRL',
          'CAD',
          'CHF',
          'CNY',
          'EUR',
          'GBP',
          'HKD',
          'IDR',
          'INR',
          'JPY',
          'KRW',
          'MXN',
          'RUB',
          'USD',
          'BTC',
          'ETH',
          'LTC'
        ]
      })
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      raise(ExchangeError, 'Fetching order books is not supported by the API of ' + self.id)
    end

    def currency_code(base, name)
      currencies = {
        'ACChain' => 'ACChain',
        'AdCoin' => 'AdCoin',
        'BatCoin' => 'BatCoin',
        'Bitgem' => 'Bitgem',
        'BlazeCoin' => 'BlazeCoin',
        'BlockCAT' => 'BlockCAT',
        'Blocktrade Token' => 'Blocktrade Token',
        'Catcoin' => 'Catcoin',
        'CanYaCoin' => 'CanYaCoin', # conflict with CAN(Content and AD Network)
        'Comet' => 'Comet', # conflict with CMT(CyberMiles)
        'CPChain' => 'CPChain',
        'CrowdCoin' => 'CrowdCoin', # conflict with CRC CryCash
        'Cubits' => 'Cubits', # conflict with QBT(Qbao)
        'DAO.Casino' => 'DAO.Casino', # conflict with BET(BetaCoin)
        'E-Dinar Coin' => 'E-Dinar Coin', # conflict with EDR Endor Protocol and EDRCoin
        'EDRcoin' => 'EDRcoin', # conflict with EDR Endor Protocol and E-Dinar Coin
        'ENTCash' => 'ENTCash', # conflict with ENT(Eternity)
        'FairGame' => 'FairGame',
        'Fabric Token' => 'Fabric Token',
        'GET Protocol' => 'GET Protocol',
        'Global Tour Coin' => 'Global Tour Coin', # conflict with GTC(Game.com)
        'GuccioneCoin' => 'GuccioneCoin', # conflict with GCC(Global Cryptocurrency)
        'HarmonyCoin' => 'HarmonyCoin', # conflict with HMC(Hi Mutual Society)
        'Harvest Masternode Coin' => 'Harvest Masternode Coin', # conflict with HC(HyperCash)
        'Hydro Protocol' => 'Hydro Protocol', # conflict with HOT(Holo)
        'Huncoin' => 'Huncoin', # conflict with HNC(Helleniccoin)
        'iCoin' => 'iCoin',
        'Infinity Economics' => 'Infinity Economics', # conflict with XIN(Mixin)
        'KingN Coin' => 'KingN Coin', # conflict with KNC(Kyber Network)
        'LiteBitcoin' => 'LiteBitcoin', # conflict with LBTC(LightningBitcoin)
        'Maggie' => 'Maggie',
        'IOTA' => 'IOTA', # a special case, most exchanges list it as IOTA, therefore we change just the Coinmarketcap instead of changing them all
        'NetCoin' => 'NetCoin',
        'PCHAIN' => 'PCHAIN', # conflict with PAI(Project Pai)
        'Polcoin' => 'Polcoin',
        'PutinCoin' => 'PutinCoin', # conflict with PUT(Profile Utility Token)
        'Rcoin' => 'Rcoin', # conflict with RCN(Ripio Credit Network)
      }
      if currencies.include?(name)
        return currencies[name]
      end
      return base
    end

    def fetch_markets(params = {})
      markets = self.publicGetTicker({
        'limit' => 0
      })
      result = []
      for p in (0...markets.length)
        market = markets[p]
        currencies = self.currencyCodes
        for i in (0...currencies.length)
          quote = currencies[i]
          quoteId = quote.downcase
          baseId = market['id']
          base = self.currency_code(market['symbol'], market['name'])
          symbol = base + '/' + quote
          id = baseId + '/' + quoteId
          result.push({
            'id' => id,
            'symbol' => symbol,
            'base' => base,
            'quote' => quote,
            'baseId' => baseId,
            'quoteId' => quoteId,
            'info' => market
          })
        end
      end
      return result
    end

    def fetch_global(currency = 'USD')
      self.load_markets
      request = {}
      if currency
        request['convert'] = currency
      end
      return self.publicGetGlobal(request)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      if ticker.include?('last_updated')
        if ticker['last_updated']
          timestamp = parse_int(ticker['last_updated']) * 1000
        end
      end
      change = nil
      if ticker.include?('percent_change_24h')
        if ticker['percent_change_24h']
          change = self.safe_float(ticker, 'percent_change_24h')
        end
      end
      last = nil
      symbol = nil
      volume = nil
      if market != nil
        priceKey = 'price_' + market['quoteId']
        if ticker.include?(priceKey)
          if ticker[priceKey]
            last = self.safe_float(ticker, priceKey)
          end
        end
        symbol = market['symbol']
        volumeKey = '24h_volume_' + market['quoteId']
        if ticker.include?(volumeKey)
          if ticker[volumeKey]
            volume = self.safe_float(ticker, volumeKey)
          end
        end
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => nil,
        'bidVolume' => nil,
        'ask' => nil,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => change,
        'average' => nil,
        'baseVolume' => nil,
        'quoteVolume' => volume,
        'info' => ticker
      }
    end

    def fetch_tickers(currency = 'USD', params = {})
      self.load_markets
      request = {
        'limit' => 10000
      }
      if currency
        request['convert'] = currency
      end
      response = self.publicGetTicker(self.shallow_extend(request, params))
      tickers = {}
      for t in (0...response.length)
        ticker = response[t]
        currencyId = currency.downcase
        id = ticker['id'] + '/' + currencyId
        symbol = id
        market = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        end
        tickers[symbol] = self.parse_ticker(ticker, market)
      end
      return tickers
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      request = self.shallow_extend({
        'convert' => market['quote'],
        'id' => market['baseId']
      }, params)
      response = self.publicGetTickerId(request)
      ticker = response[0]
      return self.parse_ticker(ticker, market)
    end

    def fetch_currencies(params = {})
      currencies = self.publicGetTicker(self.shallow_extend({
        'limit' => 0
      }, params))
      result = {}
      for i in (0...currencies.length)
        currency = currencies[i]
        id = currency['symbol']
        name = currency['name']
        # todo => will need to rethink the fees
        # to add support for multiple withdrawal/deposit methods and
        # differentiated fees for each particular method
        precision = 8 # default precision, todo => fix "magic constants"
        code = self.currency_code(id, name)
        result[code] = {
          'id' => id,
          'code' => code,
          'info' => currency,
          'name' => name,
          'active' => true,
          'fee' => nil, # todo => redesign
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'withdraw' => {
              'min' => nil,
              'max' => nil
            }
          }
        }
      end
      return result
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if query
        url += '?' + self.urlencode(query)
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('error')
        if response['error']
          raise(ExchangeError, self.id + ' ' + self.json(response))
        end
      end
      return response
    end
  end
end
