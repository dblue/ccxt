# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Uex < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'uex',
        'name' => 'UEX',
        'countries' => ['SG', 'US'],
        'version' => 'v1.0.3',
        'rateLimit' => 1000,
        'certified' => false,
        # new metainfo interface
        'has' => {
          'CORS' => false,
          'fetchMyTrades' => true,
          'fetchOHLCV' => true,
          'fetchOrder' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchDepositAddress' => true,
          'fetchDeposits' => true,
          'fetchWithdrawals' => true,
          'withdraw' => true
        },
        'timeframes' => {
          '1m' => '1',
          '5m' => '5',
          '15m' => '15',
          '30m' => '30',
          '1h' => '60',
          '2h' => '120',
          '3h' => '180',
          '4h' => '240',
          '6h' => '360',
          '12h' => '720',
          '1d' => '1440'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/43999923-051d9884-9e1f-11e8-965a-76948cb17678.jpg',
          'api' => 'https://open-api.uex.com/open/api',
          'www' => 'https://www.uex.com',
          'doc' => 'https://download.uex.com/doc/UEX-API-English-1.0.3.pdf',
          'fees' => 'https://www.uex.com/footer/ufees.html',
          'referral' => 'https://www.uex.com/signup.html?code=VAGQLL'
        },
        'api' => {
          'public' => {
            'get' => [
              'common/coins', # funding limits
              'common/symbols',
              'get_records', # ohlcvs
              'get_ticker',
              'get_trades',
              'market_dept', # dept here is not a typo... they mean depth
            ]
          },
          'private' => {
            'get' => [
              'deposit_address_list',
              'withdraw_address_list',
              'deposit_history',
              'withdraw_history',
              'user/account',
              'market', # an assoc array of market ids to corresponding prices traded most recently(prices of last trades per market)
              'order_info',
              'new_order', # a list of currently open orders
              'all_order',
              'all_trade'
            ],
            'post' => [
              'create_order',
              'cancel_order',
              'create_withdraw'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.0010,
            'taker' => 0.0010
          }
        },
        'exceptions' => {
          # descriptions from ↓ exchange
          # '0' => 'no error', # succeed
          '4' => InsufficientFunds, # {"code":"4","msg":"余额不足:0E-16","data":null}
          '5' => InvalidOrder, # fail to order {"code":"5","msg":"Price fluctuates more than1000.0%","data":null}
          '6' => InvalidOrder, # the quantity value less than the minimum one {"code":"6","msg":"数量小于最小值:0.001","data":null}
          '7' => InvalidOrder, # the quantity value more than the maximum one {"code":"7","msg":"数量大于最大值:10000","data":null}
          '8' => InvalidOrder, # fail to cancel order
          '9' => ExchangeError, # transaction be frozen
          '13' => ExchangeError, # Sorry, the program made an error, please contact with the manager.
          '19' => InsufficientFunds, # Available balance is insufficient.
          '22' => OrderNotFound, # The order does not exist. {"code":"22","msg":"not exist order","data":null}
          '23' => InvalidOrder, # Lack of parameters of numbers of transaction
          '24' => InvalidOrder, # Lack of parameters of transaction price
          '100001' => ExchangeError, # System is abnormal
          '100002' => ExchangeNotAvailable, # Update System
          '100004' => ExchangeError, # {"code":"100004","msg":"request parameter illegal","data":null}
          '100005' => AuthenticationError, # {"code":"100005","msg":"request sign illegal","data":null}
          '100007' => PermissionDenied, # illegal IP
          '110002' => ExchangeError, # unknown currency code
          '110003' => AuthenticationError, # fund password error
          '110004' => AuthenticationError, # fund password error
          '110005' => InsufficientFunds, # Available balance is insufficient.
          '110020' => AuthenticationError, # Username does not exist.
          '110023' => AuthenticationError, # Phone number is registered.
          '110024' => AuthenticationError, # Email box is registered.
          '110025' => PermissionDenied, # Account is locked by background manager
          '110032' => PermissionDenied, # The user has no authority to do self operation.
          '110033' => ExchangeError, # fail to recharge
          '110034' => ExchangeError, # fail to withdraw
          '-100' => ExchangeError, # {"code":"-100","msg":"Your request path is not exist or you can try method GET/POST.","data":null}
          '-1000' => ExchangeNotAvailable, # {"msg":"System maintenance!","code":"-1000","data":null}
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true
        },
        'options' => {
          'createMarketBuyOrderRequiresPrice' => true,
          'limits' => {
            'BTC/USDT' => { 'amount' => { 'min' => 0.001 }, 'price' => { 'min' => 0.01 }},
            'ETH/USDT' => { 'amount' => { 'min' => 0.001 }, 'price' => { 'min' => 0.01 }},
            'BCH/USDT' => { 'amount' => { 'min' => 0.001 }, 'price' => { 'min' => 0.01 }},
            'ETH/BTC' => { 'amount' => { 'min' => 0.001 }, 'price' => { 'min' => 0.000001 }},
            'BCH/BTC' => { 'amount' => { 'min' => 0.001 }, 'price' => { 'min' => 0.000001 }},
            'LEEK/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'CTXC/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'COSM/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'MANA/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'LBA/BTC' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'OLT/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'DTA/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'KNT/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'REN/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'LBA/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'EXC/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'ZIL/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'RATING/ETH' => { 'amount' => { 'min' => 100 }, 'price' => { 'min' => 100 }},
            'CENNZ/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }},
            'TTC/ETH' => { 'amount' => { 'min' => 10 }, 'price' => { 'min' => 10 }}
          }
        }
      })
    end

    def calculate_fee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {})
      market = self.markets[symbol]
      key = 'quote'
      rate = market[takerOrMaker]
      cost = parse_float(self.cost_to_precision(symbol, amount * rate))
      if side == 'sell'
        cost *= price
      else
        key = 'base'
      end
      return {
        'type' => takerOrMaker,
        'currency' => market[key],
        'rate' => rate,
        'cost' => parse_float(self.currency_to_precision(market[key], cost))
      }
    end

    def fetch_markets(params = {})
      response = self.publicGetCommonSymbols
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => [{           symbol => "btcusdt",
      #                       count_coin => "usdt",
      #                 amount_precision =>  3,
      #                        base_coin => "btc",
      #                  price_precision =>  2         },
      #               {           symbol => "ethusdt",
      #                       count_coin => "usdt",
      #                 amount_precision =>  3,
      #                        base_coin => "eth",
      #                  price_precision =>  2         },
      #               {           symbol => "ethbtc",
      #                       count_coin => "btc",
      #                 amount_precision =>  3,
      #                        base_coin => "eth",
      #                  price_precision =>  6        }]}
      #
      result = []
      markets = response['data']
      for i in (0...markets.length)
        market = markets[i]
        id = market['symbol']
        baseId = market['base_coin']
        quoteId = market['count_coin']
        base = baseId.upcase
        quote = quoteId.upcase
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        precision = {
          'amount' => market['amount_precision'],
          'price' => market['price_precision']
        }
        active = true
        defaultLimits = self.safe_value(self.options['limits'], symbol, {})
        limits = self.deep_extend({
          'amount' => {
            'min' => nil,
            'max' => nil
          },
          'price' => {
            'min' => nil,
            'max' => nil
          },
          'cost' => {
            'min' => nil,
            'max' => nil
          }
        }, defaultLimits)
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'info' => market,
          'precision' => precision,
          'limits' => limits
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetUserAccount(params)
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => { total_asset =>   "0.00000000",
      #                 coin_list => [{      normal => "0.00000000",
      #                                btcValuatin => "0.00000000",
      #                                     locked => "0.00000000",
      #                                       coin => "usdt"        },
      #                              {      normal => "0.00000000",
      #                                btcValuatin => "0.00000000",
      #                                     locked => "0.00000000",
      #                                       coin => "btc"         },
      #                              {      normal => "0.00000000",
      #                                btcValuatin => "0.00000000",
      #                                     locked => "0.00000000",
      #                                       coin => "eth"         },
      #                              {      normal => "0.00000000",
      #                                btcValuatin => "0.00000000",
      #                                     locked => "0.00000000",
      #                                       coin => "ren"         }]}}
      #
      balances = response['data']['coin_list']
      result = { 'info' => balances }
      for i in (0...balances.length)
        balance = balances[i]
        currencyId = balance['coin']
        code = currencyId.upcase
        if self.currencies_by_id.include?(currencyId)
          code = self.currencies_by_id[currencyId]['code']
        else
          code = self.common_currency_code(code)
        end
        account = self.account
        free = parse_float(balance['normal'])
        used = parse_float(balance['locked'])
        total = self.sum(free, used)
        account['free'] = free
        account['used'] = used
        account['total'] = total
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      response = self.publicGetMarketDept(self.shallow_extend({
        'symbol' => self.market_id(symbol),
        'type' => 'step0', # step1, step2 from most detailed to least detailed
      }, params))
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => { tick => { asks => [["0.05824200", 9.77],
      #                               ["0.05830000", 7.81],
      #                               ["0.05832900", 8.59],
      #                               ["0.10000000", 0.001]  ],
      #                       bids => [["0.05780000", 8.25],
      #                               ["0.05775000", 8.12],
      #                               ["0.05773200", 8.57],
      #                               ["0.00010000", 0.79]   ],
      #                       time =>    1533412622463            } } }
      #
      timestamp = self.safe_integer(response['data']['tick'], 'time')
      return self.parse_order_book(response['data']['tick'], timestamp)
    end

    def parse_ticker(ticker, market = nil)
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => { symbol => "ETHBTC",
      #                 high =>  0.058426,
      #                  vol =>  19055.875,
      #                 last =>  0.058019,
      #                  low =>  0.055802,
      #               change =>  0.03437271,
      #                  buy => "0.05780000",
      #                 sell => "0.05824200",
      #                 time =>  1533413083184 } }
      #
      timestamp = self.safe_integer(ticker, 'time')
      symbol = nil
      if market.nil?
        marketId = self.safe_string(ticker, 'symbol')
        marketId = marketId.downcase
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      change = self.safe_float(ticker, 'change')
      percentage = change * 100
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => percentage,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetGetTicker(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => { symbol => "ETHBTC",
      #                 high =>  0.058426,
      #                  vol =>  19055.875,
      #                 last =>  0.058019,
      #                  low =>  0.055802,
      #               change =>  0.03437271,
      #                  buy => "0.05780000",
      #                 sell => "0.05824200",
      #                 time =>  1533413083184 } }
      #
      return self.parse_ticker(response['data'], market)
    end

    def parse_trade(trade, market = nil)
      #
      # public fetchTrades
      #
      #   {      amount =>  0.88,
      #     create_time =>  1533414358000,
      #           price =>  0.058019,
      #              id =>  406531,
      #            type => "sell"          },
      #
      # private fetchMyTrades, fetchOrder, fetchOpenOrders, fetchClosedOrders
      #
      #   {     volume => "0.010",
      #           side => "SELL",
      #        feeCoin => "BTC",
      #          price => "0.05816200",
      #            fee => "0.00000029",
      #          ctime =>  1533616674000,
      #     deal_price => "0.00058162",
      #             id =>  415779,
      #           type => "卖出",
      #         bid_id =>  3669539, # only in fetchMyTrades
      #         ask_id =>  3669583, # only in fetchMyTrades
      #   }
      #
      timestamp = self.safe_integer_2(trade, 'create_time', 'ctime')
      if timestamp.nil?
        timestring = self.safe_string(trade, 'created_at')
        if timestring != nil
          timestamp = self.parse8601('2018-' + timestring + ':00Z')
        end
      end
      side = self.safe_string_2(trade, 'side', 'type')
      if side != nil
        side = side.downcase
      end
      id = self.safe_string(trade, 'id')
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      price = self.safe_float(trade, 'price')
      amount = self.safe_float_2(trade, 'volume', 'amount')
      cost = self.safe_float(trade, 'deal_price')
      if cost.nil?
        if amount != nil
          if price != nil
            cost = amount * price
          end
        end
      end
      fee = nil
      feeCost = self.safe_float_2(trade, 'fee', 'deal_fee')
      if feeCost != nil
        feeCurrency = self.safe_string(trade, 'feeCoin')
        if feeCurrency != nil
          currencyId = feeCurrency.downcase
          if self.currencies_by_id.include?(currencyId)
            feeCurrency = self.currencies_by_id[currencyId]['code']
          end
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      orderIdField = (side == 'sell') ? 'ask_id' : 'bid_id'
      orderId = self.safe_string(trade, orderIdField)
      return {
        'id' => id,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => orderId,
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetGetTrades(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => [{      amount =>  0.88,
      #                 create_time =>  1533414358000,
      #                       price =>  0.058019,
      #                          id =>  406531,
      #                        type => "sell"          },
      #               {      amount =>  4.88,
      #                 create_time =>  1533414331000,
      #                       price =>  0.058019,
      #                          id =>  406530,
      #                        type => "buy"           },
      #               {      amount =>  0.5,
      #                 create_time =>  1533414311000,
      #                       price =>  0.058019,
      #                          id =>  406529,
      #                        type => "sell"          }] }
      #
      return self.parse_trades(response['data'], market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1d', since = nil, limit = nil)
      return [
        ohlcv[0] * 1000, # timestamp
        ohlcv[1], # open
        ohlcv[2], # high
        ohlcv[3], # low
        ohlcv[4], # close
        ohlcv[5], # volume
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'period' => self.timeframes[timeframe], # in minutes
      }
      response = self.publicGetGetRecords(self.shallow_extend(request, params))
      #
      #     { code => '0',
      #        msg => 'suc',
      #       data:
      #        [[1533402420, 0.057833, 0.057833, 0.057833, 0.057833, 18.1],
      #          [1533402480, 0.057833, 0.057833, 0.057833, 0.057833, 29.88],
      #          [1533402540, 0.057833, 0.057833, 0.057833, 0.057833, 29.06] ] }
      #
      return self.parse_ohlcvs(response['data'], market, timeframe, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        # for market buy it requires the amount of quote currency to spend
        if side == 'buy'
          if self.options['createMarketBuyOrderRequiresPrice']
            if price.nil?
              raise(InvalidOrder, self.id + " createOrder requires the price argument with market buy orders to calculate total order cost(amount to spend), where cost = amount * price. Supply a price argument to createOrder call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument(the exchange-specific behaviour)")
            else
              amount = amount * price
            end
          end
        end
      end
      self.load_markets
      market = self.market(symbol)
      orderType = (type == 'limit') ? '1' : '2'
      orderSide = side.upcase
      amountToPrecision = self.amount_to_precision(symbol, amount)
      request = {
        'side' => orderSide,
        'type' => orderType,
        'symbol' => market['id'],
        'volume' => amountToPrecision,
        # An excerpt from their docs:
        # side required Trading Direction
        # type required pending order types，1:Limit-price Delegation 2:Market- price Delegation
        # volume required
        #     Purchase Quantity（polysemy，multiplex field）
        #     type=1 => Quantity of buying and selling
        #     type=2 => Buying represents gross price, and selling represents total number
        #     Trading restriction user/me-user information
        # price optional Delegation Price：type=2：self parameter is no use.
        # fee_is_user_exchange_coin optional
        #     0，when making transactions with all platform currencies,
        #     self parameter represents whether to use them to pay
        #     fees or not and 0 is no, 1 is yes.
      }
      priceToPrecision = nil
      if type == 'limit'
        priceToPrecision = self.price_to_precision(symbol, price)
        request['price'] = priceToPrecision
      end
      response = self.privatePostCreateOrder(self.shallow_extend(request, params))
      #
      #     { code => '0',
      #        msg => 'suc',
      #       data => { 'order_id' : 34343 } }
      #
      result = self.parse_order(response['data'], market)
      return self.shallow_extend(result, {
        'info' => response,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'status' => 'open',
        'price' => parse_float(priceToPrecision),
        'amount' => parse_float(amountToPrecision)
      })
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'order_id' => id,
        'symbol' => market['id']
      }
      response = self.privatePostCancelOrder(self.shallow_extend(request, params))
      order = self.safe_value(response, 'data', {})
      return self.shallow_extend(self.parse_order(order), {
        'id' => id,
        'symbol' => symbol,
        'status' => 'canceled'
      })
    end

    def parse_order_status(status)
      statuses = {
        '0' => 'open', # INIT(0,"primary order，untraded and not enter the market")
        '1' => 'open', # NEW_(1,"new order，untraded and enter the market ")
        '2' => 'closed', # FILLED(2,"complete deal")
        '3' => 'open', # PART_FILLED(3,"partial deal")
        '4' => 'canceled', # CANCELED(4,"already withdrawn")
        '5' => 'canceled', # PENDING_CANCEL(5,"pending withdrawak")
        '6' => 'canceled', # EXPIRED(6,"abnormal orders")
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      #
      # createOrder
      #
      #     {"order_id":34343}
      #
      # fetchOrder, fetchOpenOrders, fetchClosedOrders
      #
      #     {          side =>   "BUY",
      #         total_price =>   "0.10000000",
      #          created_at =>    1510993841000,
      #           avg_price =>   "0.10000000",
      #           countCoin =>   "btc",
      #              source =>    1,
      #                type =>    1,
      #            side_msg =>   "买入",
      #              volume =>   "1.000",
      #               price =>   "0.10000000",
      #          source_msg =>   "WEB",
      #          status_msg =>   "完全成交",
      #         deal_volume =>   "1.00000000",
      #                  id =>    424,
      #       remain_volume =>   "0.00000000",
      #            baseCoin =>   "eth",
      #           tradeList => [{     volume => "1.000",
      #                             feeCoin => "YLB",
      #                               price => "0.10000000",
      #                                 fee => "0.16431104",
      #                               ctime =>  1510996571195,
      #                          deal_price => "0.10000000",
      #                                  id =>  306,
      #                                type => "买入"            }],
      #              status =>    2                                 }
      #
      # fetchOrder
      #
      #      { trade_list => [{     volume => "0.010",
      #                           feeCoin => "BTC",
      #                             price => "0.05816200",
      #                               fee => "0.00000029",
      #                             ctime =>  1533616674000,
      #                        deal_price => "0.00058162",
      #                                id =>  415779,
      #                              type => "卖出"            }],
      #        order_info => {          side =>   "SELL",
      #                        total_price =>   "0.010",
      #                         created_at =>    1533616673000,
      #                          avg_price =>   "0.05816200",
      #                          countCoin =>   "btc",
      #                             source =>    3,
      #                               type =>    2,
      #                           side_msg =>   "卖出",
      #                             volume =>   "0.010",
      #                              price =>   "0.00000000",
      #                         source_msg =>   "API",
      #                         status_msg =>   "完全成交",
      #                        deal_volume =>   "0.01000000",
      #                                 id =>    3669583,
      #                      remain_volume =>   "0.00000000",
      #                           baseCoin =>   "eth",
      #                          tradeList => [{     volume => "0.010",
      #                                            feeCoin => "BTC",
      #                                              price => "0.05816200",
      #                                                fee => "0.00000029",
      #                                              ctime =>  1533616674000,
      #                                         deal_price => "0.00058162",
      #                                                 id =>  415779,
      #                                               type => "卖出"            }],
      #                             status =>    2                                 } }
      #
      side = self.safe_string(order, 'side')
      if side != nil
        side = side.downcase
      end
      status = self.parse_order_status(self.safe_string(order, 'status'))
      symbol = nil
      if market.nil?
        baseId = self.safe_string(order, 'baseCoin')
        quoteId = self.safe_string(order, 'countCoin')
        marketId = baseId + quoteId
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        else
          if (baseId != nil) && (quoteId != nil)
            base = baseId.upcase
            quote = quoteId.upcase
            base = self.common_currency_code(base)
            quote = self.common_currency_code(quote)
            symbol = base + '/' + quote
          end
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'created_at')
      if timestamp.nil?
        timestring = self.safe_string(order, 'created_at')
        if timestring != nil
          timestamp = self.parse8601('2018-' + timestring + ':00Z')
        end
      end
      lastTradeTimestamp = nil
      fee = nil
      average = self.safe_float(order, 'avg_price')
      price = self.safe_float(order, 'price')
      if price == 0
        price = average
      end
      amount = self.safe_float(order, 'volume')
      filled = self.safe_float(order, 'deal_volume')
      remaining = self.safe_float(order, 'remain_volume')
      cost = self.safe_float(order, 'total_price')
      id = self.safe_string_2(order, 'id', 'order_id')
      trades = nil
      tradeList = self.safe_value(order, 'tradeList', [])
      feeCurrencies = {}
      feeCost = nil
      for i in (0...tradeList.length)
        trade = self.parse_trade(tradeList[i], market)
        if feeCost.nil?
          feeCost = 0
        end
        feeCost = feeCost + trade['fee']['cost']
        tradeFeeCurrency = trade['fee']['currency']
        feeCurrencies[tradeFeeCurrency] = trade['fee']['cost']
        if trades.nil?
          trades = []
        end
        lastTradeTimestamp = trade['timestamp']
        trades.push(self.shallow_extend(trade, {
          'order' => id
        }))
      end
      if feeCost != nil
        feeCurrency = nil
        keys = feeCurrencies.keys
        numCurrencies = keys.length
        if numCurrencies == 1
          feeCurrency = keys[0]
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => average,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee,
        'trades' => trades
      }
      return result
    end

    def fetch_orders_with_method(method, symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrdersWithMethod requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        # pageSize optional page size
        # page optional page number
        'symbol' => market['id']
      }
      if limit != nil
        request['pageSize'] = limit
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => {     count =>    1,
      #               orderList => [{          side =>   "SELL",
      #                                total_price =>   "0.010",
      #                                 created_at =>    1533616673000,
      #                                  avg_price =>   "0.05816200",
      #                                  countCoin =>   "btc",
      #                                     source =>    3,
      #                                       type =>    2,
      #                                   side_msg =>   "卖出",
      #                                     volume =>   "0.010",
      #                                      price =>   "0.00000000",
      #                                 source_msg =>   "API",
      #                                 status_msg =>   "完全成交",
      #                                deal_volume =>   "0.01000000",
      #                                         id =>    3669583,
      #                              remain_volume =>   "0.00000000",
      #                                   baseCoin =>   "eth",
      #                                  tradeList => [{     volume => "0.010",
      #                                                    feeCoin => "BTC",
      #                                                      price => "0.05816200",
      #                                                        fee => "0.00000029",
      #                                                      ctime =>  1533616674000,
      #                                                 deal_price => "0.00058162",
      #                                                         id =>  415779,
      #                                                       type => "卖出"            }],
      #                                     status =>    2                                 }] } }
      #
      # privateGetNewOrder returns resultList, privateGetAllOrder returns orderList
      orders = self.safe_value_2(response['data'], 'orderList', 'resultList', [])
      return self.parse_orders(orders, market, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_with_method('privateGetNewOrder', symbol, since, limit, params)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_with_method('privateGetAllOrder', symbol, since, limit, params)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'order_id' => id,
        'symbol' => market['id']
      }
      response = self.privateGetOrderInfo(self.shallow_extend(request, params))
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => { trade_list => [{     volume => "0.010",
      #                                  feeCoin => "BTC",
      #                                    price => "0.05816200",
      #                                      fee => "0.00000029",
      #                                    ctime =>  1533616674000,
      #                               deal_price => "0.00058162",
      #                                       id =>  415779,
      #                                     type => "卖出"            }],
      #               order_info => {          side =>   "SELL",
      #                               total_price =>   "0.010",
      #                                created_at =>    1533616673000,
      #                                 avg_price =>   "0.05816200",
      #                                 countCoin =>   "btc",
      #                                    source =>    3,
      #                                      type =>    2,
      #                                  side_msg =>   "卖出",
      #                                    volume =>   "0.010",
      #                                     price =>   "0.00000000",
      #                                source_msg =>   "API",
      #                                status_msg =>   "完全成交",
      #                               deal_volume =>   "0.01000000",
      #                                        id =>    3669583,
      #                             remain_volume =>   "0.00000000",
      #                                  baseCoin =>   "eth",
      #                                 tradeList => [{     volume => "0.010",
      #                                                   feeCoin => "BTC",
      #                                                     price => "0.05816200",
      #                                                       fee => "0.00000029",
      #                                                     ctime =>  1533616674000,
      #                                                deal_price => "0.00058162",
      #                                                        id =>  415779,
      #                                                      type => "卖出"            }],
      #                                    status =>    2                                 } } }
      #
      return self.parse_order(response['data']['order_info'], market)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        # pageSize optional page size
        # page optional page number
        'symbol' => market['id']
      }
      if limit != nil
        request['pageSize'] = limit
      end
      response = self.privateGetAllTrade(self.shallow_extend(request, params))
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => {      count =>    1,
      #               resultList => [{     volume => "0.010",
      #                                     side => "SELL",
      #                                  feeCoin => "BTC",
      #                                    price => "0.05816200",
      #                                      fee => "0.00000029",
      #                                    ctime =>  1533616674000,
      #                               deal_price => "0.00058162",
      #                                       id =>  415779,
      #                                     type => "卖出",
      #                                   bid_id =>  3669539,
      #                                   ask_id =>  3669583        }] } }
      #
      trades = self.safe_value(response['data'], 'resultList', [])
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'coin' => currency['id']
      }
      # https://github.com/UEX-OpenAPI/API_Docs_en/wiki/Query-deposit-address-of-assigned-token
      response = self.privateGetDepositAddressList(self.shallow_extend(request, params))
      #
      #     {
      #         "code" => "0",
      #         "msg" => "suc",
      #         "data" => {
      #             "addressList" => [
      #                 {
      #                     "address" => "0x198803ef8e0df9e8812c0105421885e843e6d2e2",
      #                     "tag" => "",
      #                 },
      #             ],
      #         },
      #     }
      #
      data = self.safe_value(response, 'data')
      if data.nil?
        raise(InvalidAddress, self.id + ' privateGetDepositAddressList returned no data')
      end
      addressList = self.safe_value(data, 'addressList')
      if addressList.nil?
        raise(InvalidAddress, self.id + ' privateGetDepositAddressList returned no address list')
      end
      numAddresses = addressList.length
      if numAddresses < 1
        raise(InvalidAddress, self.id + ' privatePostDepositAddresses returned no addresses')
      end
      firstAddress = addressList[0]
      address = self.safe_string(firstAddress, 'address')
      tag = self.safe_string(firstAddress, 'tag')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def fetch_transactions_by_type(type, code = nil, since = nil, limit = nil, params = {})
      if code.nil?
        raise(ArgumentsRequired, self.id + ' fetchWithdrawals requires a currency code argument')
      end
      currency = self.currency(code)
      request = {
        'coin' => currency['id']
      }
      if limit != nil
        request['pageSize'] = limit # default 10
      end
      transactionType = (type == 'deposit') ? 'deposit' : 'withdraw' # instead of withdrawal...
      method = 'privateGet' + self.capitalize(transactionType) + 'History'
      # https://github.com/UEX-OpenAPI/API_Docs_en/wiki/Query-deposit-record-of-assigned-token
      # https://github.com/UEX-OpenAPI/API_Docs_en/wiki/Query-withdraw-record-of-assigned-token
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => { depositList => [{     createdAt =>  1533615955000,
      #                                       amount => "0.01",
      #                                     updateAt =>  1533616311000,
      #                                         txid => "0x0922fde6ab8270fe6eb31cb5a37dc732d96dc8193f81cf46c4ab29fde…",
      #                                          tag => "",
      #                                confirmations =>  30,
      #                                    addressTo => "0x198803ef8e0df9e8812c0105421885e843e6d2e2",
      #                                       status =>  1,
      #                                         coin => "ETH"                                                           }] } }
      #
      #     {
      #         "code" => "0",
      #         "msg" => "suc",
      #         "data" => {
      #             "withdrawList" => [{
      #                 "updateAt" => 1540344965000,
      #                 "createdAt" => 1539311971000,
      #                 "status" => 0,
      #                 "addressTo" => "tz1d7DXJXU3AKWh77gSmpP7hWTeDYs8WF18q",
      #                 "tag" => "100128877",
      #                 "id" => 5,
      #                 "txid" => "",
      #                 "fee" => 0.0,
      #                 "amount" => "1",
      #                 "symbol" => "XTZ"
      #             }]
      #         }
      #     }
      #
      transactions = self.safe_value(response['data'], transactionType + 'List')
      return self.parse_transactions_by_type(type, transactions, code, since, limit)
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions_by_type('deposit', code, since, limit, params)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions_by_type('withdrawal', code, since, limit, params)
    end

    def parse_transactions_by_type(type, transactions, code = nil, since = nil, limit = nil)
      result = []
      for i in (0...transactions.length)
        transaction = self.parse_transaction(self.shallow_extend({
          'type' => type
        }, transactions[i]))
        result.push(transaction)
      end
      return self.filterByCurrencySinceLimit(result, code, since, limit)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # deposits
      #
      #      {     createdAt =>  1533615955000,
      #               amount => "0.01",
      #             updateAt =>  1533616311000,
      #                 txid => "0x0922fde6ab8270fe6eb31cb5a37dc732d96dc8193f81cf46c4ab29fde…",
      #                  tag => "",
      #        confirmations =>  30,
      #            addressTo => "0x198803ef8e0df9e8812c0105421885e843e6d2e2",
      #               status =>  1,
      #                 coin => "ETH"                                                           }] } }
      #
      # withdrawals
      #
      #     {
      #         "updateAt" => 1540344965000,
      #         "createdAt" => 1539311971000,
      #         "status" => 0,
      #         "addressTo" => "tz1d7DXJXU3AKWh77gSmpP7hWTeDYs8WF18q",
      #         "tag" => "100128877",
      #         "id" => 5,
      #         "txid" => "",
      #         "fee" => 0.0,
      #         "amount" => "1",
      #         "symbol" => "XTZ"
      #     }
      #
      id = self.safe_string(transaction, 'id')
      txid = self.safe_string(transaction, 'txid')
      timestamp = self.safe_integer(transaction, 'createdAt')
      updated = self.safe_integer(transaction, 'updateAt')
      code = nil
      currencyId = self.safe_string_2(transaction, 'symbol', 'coin')
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency != nil
        code = currency['code']
      else
        code = self.common_currency_code(currencyId)
      end
      address = self.safe_string(transaction, 'addressTo')
      tag = self.safe_string(transaction, 'tag')
      amount = self.safe_float(transaction, 'amount')
      status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
      type = self.safe_string(transaction, 'type') # injected from the outside
      feeCost = self.safe_float(transaction, 'fee')
      if (type == 'deposit') && (feeCost.nil?)
        feeCost = 0
      end
      return {
        'info' => transaction,
        'id' => id,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => tag,
        'status' => status,
        'type' => type,
        'updated' => updated,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => {
          'currency' => code,
          'cost' => feeCost
        }
      }
    end

    def parse_transaction_status(status)
      statuses = {
        '0' => 'pending', # unaudited
        '1' => 'ok', # audited
        '2' => 'failed', # audit failed
        '3' => 'pending', # "payment"
        '4' => 'failed', # payment failed
        '5' => 'ok',
        '6' => 'canceled'
      }
      return self.safe_string(statuses, status, status)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.load_markets
      fee = self.safe_float(params, 'fee')
      if fee.nil?
        raise(ArgumentsRequired, self.id + 'requires a "fee" extra parameter in its last argument')
      end
      self.check_address(address)
      currency = self.currency(code)
      request = {
        'coin' => currency['id'],
        'address' => address, # only supports existing addresses in your withdraw address list
        'amount' => amount,
        'fee' => fee, # balance >= self.sum(amount, fee)
      }
      if tag != nil
        request['tag'] = tag
      end
      # https://github.com/UEX-OpenAPI/API_Docs_en/wiki/Withdraw
      response = self.privatePostCreateWithdraw(self.shallow_extend(request, params))
      id = nil
      return {
        'info' => response,
        'id' => id
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.implode_params(path, params)
      if api == 'public'
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        timestamp = self.seconds.to_s
        auth = ''
        query = self.keysort(self.shallow_extend(params, {
          'api_key' => self.apiKey,
          'time' => timestamp
        }))
        keys = query.keys
        for i in (0...keys.length)
          key = keys[i]
          auth += key
          auth += query[key].to_s
        end
        signature = self.hash(self.encode(auth + self.secret))
        if query
          if method == 'GET'
            url += '?' + self.urlencode(query) + '&sign=' + signature
          else
            body = self.urlencode(query) + '&sign=' + signature
          end
        end
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        #
        # {"code":"0","msg":"suc","data":{}}
        #
        code = self.safe_string(response, 'code')
        # message = self.safe_string(response, 'msg')
        feedback = self.id + ' ' + self.json(response)
        exceptions = self.exceptions
        if code != '0'
          if exceptions.include?(code)
            raise(exceptions[code], feedback)
          else
            raise(ExchangeError, feedback)
          end
        end
      end
    end
  end
end
