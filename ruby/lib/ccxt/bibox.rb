# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bibox < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bibox',
        'name' => 'Bibox',
        'countries' => ['CN', 'US', 'KR'],
        'version' => 'v1',
        'has' => {
          'CORS' => false,
          'publicAPI' => false,
          'fetchBalance' => true,
          'fetchDeposits' => true,
          'fetchWithdrawals' => true,
          'fetchCurrencies' => true,
          'fetchDepositAddress' => true,
          'fetchFundingFees' => true,
          'fetchTickers' => true,
          'fetchOrder' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchMyTrades' => true,
          'fetchOHLCV' => true,
          'createMarketOrder' => false, # or they will return https://github.com/ccxt/ccxt/issues/2338
          'withdraw' => true
        },
        'timeframes' => {
          '1m' => '1min',
          '5m' => '5min',
          '15m' => '15min',
          '30m' => '30min',
          '1h' => '1hour',
          '2h' => '2hour',
          '4h' => '4hour',
          '6h' => '6hour',
          '12h' => '12hour',
          '1d' => 'day',
          '1w' => 'week'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/34902611-2be8bf1a-f830-11e7-91a2-11b2f292e750.jpg',
          'api' => 'https://api.bibox.com',
          'www' => 'https://www.bibox.com',
          'doc' => [
            'https://github.com/Biboxcom/api_reference/wiki/home_en',
            'https://github.com/Biboxcom/api_reference/wiki/api_reference'
          ],
          'fees' => 'https://bibox.zendesk.com/hc/en-us/articles/115004417013-Fee-Structure-on-Bibox',
          'referral' => 'https://www.bibox.com/signPage?id=11114745&lang=en'
        },
        'api' => {
          'public' => {
            'post' => [
              # TODO => rework for full endpoint/cmd paths here
              'mdata'
            ],
            'get' => [
              'mdata'
            ]
          },
          'private' => {
            'post' => [
              'user',
              'orderpending',
              'transfer'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'taker' => 0.001,
            'maker' => 0.001
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {},
            'deposit' => {}
          }
        },
        'exceptions' => {
          '2021' => InsufficientFunds, # Insufficient balance available for withdrawal
          '2015' => AuthenticationError, # Google authenticator is wrong
          '2027' => InsufficientFunds, # Insufficient balance available(for trade)
          '2033' => OrderNotFound, # operation failed! Orders have been completed or revoked
          '2067' => InvalidOrder, # Does not support market orders
          '2068' => InvalidOrder, # The number of orders can not be less than
          '2085' => InvalidOrder, # Order quantity is too small
          '3012' => AuthenticationError, # invalid apiKey
          '3024' => PermissionDenied, # wrong apikey permissions
          '3025' => AuthenticationError, # signature failed
          '4000' => ExchangeNotAvailable, # current network is unstable
          '4003' => DDoSProtection, # server busy please try again later
        },
        'commonCurrencies' => {
          'KEY' => 'Bihu',
          'PAI' => 'PCHAIN'
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetMdata(self.shallow_extend({
        'cmd' => 'marketAll'
      }, params))
      markets = response['result']
      result = []
      for i in (0...markets.length)
        market = markets[i]
        baseId = market['coin_symbol']
        quoteId = market['currency_symbol']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        id = baseId + '_' + quoteId
        precision = {
          'amount' => 4,
          'price' => 8
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => base,
          'quoteId' => quote,
          'active' => true,
          'info' => market,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => nil
            },
            'price' => {
              'min' => nil,
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      # we don't set values that are not defined by the exchange
      timestamp = self.safe_integer(ticker, 'timestamp')
      symbol = nil
      if market != nil
        symbol = market['symbol']
      else
        base = ticker['coin_symbol']
        quote = ticker['currency_symbol']
        symbol = self.common_currency_code(base) + '/' + self.common_currency_code(quote)
      end
      last = self.safe_float(ticker, 'last')
      change = self.safe_float(ticker, 'change')
      baseVolume = nil
      if ticker.include?('vol')
        baseVolume = self.safe_float(ticker, 'vol')
      else
        baseVolume = self.safe_float(ticker, 'vol24H')
      end
      open = nil
      if (last != nil) && (change != nil)
        open = last - change
      end
      percentage = self.safe_string(ticker, 'percent')
      if percentage != nil
        percentage = percentage.gsub('%', '')
        percentage = parse_float(percentage)
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => open,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => percentage,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => self.safe_float(ticker, 'amount'),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMdata(self.shallow_extend({
        'cmd' => 'ticker',
        'pair' => market['id']
      }, params))
      return self.parse_ticker(response['result'], market)
    end

    def parse_tickers(rawTickers, symbols = nil)
      tickers = []
      for i in (0...rawTickers.length)
        ticker = self.parse_ticker(rawTickers[i])
        if (symbols.nil?) || (self.in_array(ticker['symbol'], symbols))
          tickers.push(ticker)
        end
      end
      return tickers
    end

    def fetch_tickers(symbols = nil, params = {})
      request = {
        'cmd' => 'marketAll'
      }
      response = self.publicGetMdata(self.shallow_extend(request, params))
      tickers = self.parse_tickers(response['result'], symbols)
      return self.index_by(tickers, 'symbol')
    end

    def parse_trade(trade, market = nil)
      timestamp = self.safe_integer(trade, 'time')
      timestamp = self.safe_integer(trade, 'createdAt', timestamp)
      side = self.safe_integer(trade, 'side')
      side = self.safe_integer(trade, 'order_side', side)
      side = (side == 1) ? 'buy' : 'sell'
      symbol = nil
      if market.nil?
        marketId = self.safe_string(trade, 'pair')
        if marketId.nil?
          baseId = self.safe_string(trade, 'coin_symbol')
          quoteId = self.safe_string(trade, 'currency_symbol')
          if (baseId != nil) && (quoteId != nil)
            marketId = baseId + '_' + quoteId
          end
        end
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      fee = nil
      feeCost = self.safe_float(trade, 'fee')
      feeCurrency = self.safe_string(trade, 'fee_symbol')
      if feeCurrency != nil
        if self.currencies_by_id.include?(feeCurrency)
          feeCurrency = self.currencies_by_id[feeCurrency]['code']
        else
          feeCurrency = self.common_currency_code(feeCurrency)
        end
      end
      feeRate = nil # todo => deduce from market if market is defined
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      cost = price * amount
      if feeCost != nil
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency,
          'rate' => feeRate
        }
      end
      return {
        'info' => trade,
        'id' => self.safe_string(trade, 'id'),
        'order' => nil, # Bibox does not have it(documented) yet
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => 'limit',
        'takerOrMaker' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'cmd' => 'deals',
        'pair' => market['id']
      }
      if limit != nil
        request['size'] = limit # default = 200
      end
      response = self.publicGetMdata(self.shallow_extend(request, params))
      return self.parse_trades(response['result'], market, since, limit)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'cmd' => 'depth',
        'pair' => market['id']
      }
      if limit != nil
        request['size'] = limit # default = 200
      end
      response = self.publicGetMdata(self.shallow_extend(request, params))
      return self.parse_order_book(response['result'], self.safe_float(response['result'], 'update_time'), 'bids', 'asks', 'price', 'volume')
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv['time'],
        self.safe_float(ohlcv, 'open'),
        self.safe_float(ohlcv, 'high'),
        self.safe_float(ohlcv, 'low'),
        self.safe_float(ohlcv, 'close'),
        self.safe_float(ohlcv, 'vol')
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = 1000, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMdata(self.shallow_extend({
        'cmd' => 'kline',
        'pair' => market['id'],
        'period' => self.timeframes[timeframe],
        'size' => limit
      }, params))
      return self.parse_ohlcvs(response['result'], market, timeframe, since, limit)
    end

    def fetch_currencies(params = {})
      if !self.apiKey || !self.secret
        raise(AuthenticationError, self.id + " fetchCurrencies is an authenticated endpoint, therefore it requires 'apiKey' and 'secret' credentials. If you don't need currency details, set exchange.has['fetchCurrencies'] = false before calling its methods.")
      end
      response = self.privatePostTransfer({
        'cmd' => 'transfer/coinList',
        'body' => {}
      })
      currencies = response['result']
      result = {}
      for i in (0...currencies.length)
        currency = currencies[i]
        id = currency['symbol']
        code = self.common_currency_code(id)
        precision = 8
        deposit = currency['enable_deposit']
        withdraw = currency['enable_withdraw']
        active = (deposit && withdraw) ? true : false
        result[code] = {
          'id' => id,
          'code' => code,
          'info' => currency,
          'name' => currency['name'],
          'active' => active,
          'fee' => nil,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'withdraw' => {
              'min' => nil,
              'max' => 10**precision
            }
          }
        }
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostTransfer({
        'cmd' => 'transfer/assets',
        'body' => self.shallow_extend({
          'select' => 1
        }, params)
      })
      balances = response['result']
      result = { 'info' => balances }
      indexed = nil
      if balances.include?('assets_list')
        indexed = self.index_by(balances['assets_list'], 'coin_symbol')
      else
        indexed = balances
      end
      keys = indexed.keys
      for i in (0...keys.length)
        id = keys[i]
        code = id.upcase
        if code.include?('TOTAL_')
          code = code[6..-1]
        end
        if self.currencies_by_id.include?(code)
          code = self.currencies_by_id[code]['code']
        end
        account = self.account
        balance = indexed[id]
        if balance.is_a?(String)
          balance = parse_float(balance)
          account['free'] = balance
          account['used'] = 0.0
          account['total'] = balance
        else
          account['free'] = parse_float(balance['balance'])
          account['used'] = parse_float(balance['freeze'])
          account['total'] = self.sum(account['free'], account['used'])
        end
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      currency = nil
      request = {
        'page' => 1
      }
      if code != nil
        currency = self.currency(code)
        request['symbol'] = currency['id']
      end
      if limit != nil
        request['size'] = limit
      else
        request['size'] = 100
      end
      response = self.privatePostTransfer({
        'cmd' => 'transfer/transferInList',
        'body' => self.shallow_extend(request, params)
      })
      deposits = self.safe_value(response['result'], 'items', [])
      for i in (0...deposits.length)
        deposits[i]['type'] = 'deposit'
      end
      return self.parseTransactions(deposits, currency, since, limit)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      currency = nil
      request = {
        'page' => 1
      }
      if code != nil
        currency = self.currency(code)
        request['symbol'] = currency['id']
      end
      if limit != nil
        request['size'] = limit
      else
        request['size'] = 100
      end
      response = self.privatePostTransfer({
        'cmd' => 'transfer/transferOutList',
        'body' => self.shallow_extend(request, params)
      })
      withdrawals = self.safe_value(response['result'], 'items', [])
      for i in (0...withdrawals.length)
        withdrawals[i]['type'] = 'withdrawal'
      end
      return self.parseTransactions(withdrawals, currency, since, limit)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchDeposits
      #
      #     {
      #         'id' => 1023291,
      #         'coin_symbol' => 'ETH',
      #         'to_address' => '0x7263....',
      #         'amount' => '0.49170000',
      #         'confirmCount' => '16',
      #         'createdAt' => 1553123867000,
      #         'status' => 2
      #     }
      #
      # fetchWithdrawals
      #
      #     {
      #         'id' => 521844,
      #         'coin_symbol' => 'ETH',
      #         'to_address' => '0xfd4e....',
      #         'addr_remark' => '',
      #         'amount' => '0.39452750',
      #         'fee' => '0.00600000',
      #         'createdAt' => 1553226906000,
      #         'memo' => '',
      #         'status' => 3
      #     }
      #
      id = self.safe_string(transaction, 'id')
      address = self.safe_string(transaction, 'to_address')
      code = nil
      currencyId = self.safe_string(transaction, 'coin_symbol')
      if self.currencies_by_id.include?(currencyId)
        currency = self.currencies_by_id[currencyId]
      else
        code = self.common_currency_code(currencyId)
      end
      if currency != nil
        code = currency['code']
      end
      timestamp = self.safe_string(transaction, 'createdAt')
      tag = self.safe_string(transaction, 'addr_remark')
      type = self.safe_string(transaction, 'type')
      status = self.parse_transaction_status_by_type(self.safe_string(transaction, 'status'), type)
      amount = self.safe_float(transaction, 'amount')
      feeCost = self.safe_float(transaction, 'fee')
      if type == 'deposit'
        feeCost = 0
        tag = nil
      end
      fee = {
        'cost' => feeCost,
        'currency' => code
      }
      return {
        'info' => transaction,
        'id' => id,
        'txid' => nil,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => address,
        'tag' => tag,
        'type' => type,
        'amount' => amount,
        'currency' => code,
        'status' => status,
        'updated' => nil,
        'fee' => fee
      }
    end

    def parse_transaction_status_by_type(status, type = nil)
      statuses = {
        'deposit' => {
          '1' => 'pending',
          '2' => 'ok'
        },
        'withdrawal' => {
          '0' => 'pending',
          '3' => 'ok'
        }
      }
      return self.safe_string(self.safe_value(statuses, type, {}), status, status)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      orderType = (type == 'limit') ? 2 : 1
      orderSide = (side == 'buy') ? 1 : 2
      response = self.privatePostOrderpending({
        'cmd' => 'orderpending/trade',
        'body' => self.shallow_extend({
          'pair' => market['id'],
          'account_type' => 0,
          'order_type' => orderType,
          'order_side' => orderSide,
          'pay_bix' => 0,
          'amount' => amount,
          'price' => price
        }, params)
      })
      return {
        'info' => response,
        'id' => self.safe_string(response, 'result')
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      response = self.privatePostOrderpending({
        'cmd' => 'orderpending/cancelTrade',
        'body' => self.shallow_extend({
          'orders_id' => id
        }, params)
      })
      return response
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePostOrderpending({
        'cmd' => 'orderpending/order',
        'body' => self.shallow_extend({
          'id' => id
        }, params)
      })
      order = self.safe_value(response, 'result')
      if self.is_empty(order)
        raise(OrderNotFound, self.id + ' order ' + id + ' not found')
      end
      return self.parse_order(order)
    end

    def parse_order(order, market = nil)
      symbol = nil
      if market.nil?
        marketId = nil
        baseId = self.safe_string(order, 'coin_symbol')
        quoteId = self.safe_string(order, 'currency_symbol')
        if (baseId != nil) && (quoteId != nil)
          marketId = baseId + '_' + quoteId
        end
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      type = (order['order_type'] == 1) ? 'market' : 'limit'
      timestamp = order['createdAt']
      price = self.safe_float(order, 'price')
      average = self.safe_float(order, 'deal_price')
      filled = self.safe_float(order, 'deal_amount')
      amount = self.safe_float(order, 'amount')
      cost = self.safe_float_2(order, 'deal_money', 'money')
      remaining = nil
      if filled != nil
        if amount != nil
          remaining = amount - filled
        end
        if cost.nil?
          cost = price * filled
        end
      end
      side = (order['order_side'] == 1) ? 'buy' : 'sell'
      status = self.parse_order_status(self.safe_string(order, 'status'))
      result = {
        'info' => order,
        'id' => self.safe_string(order, 'id'),
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost ? cost : parse_float(price) * filled,
        'average' => average,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => self.safe_float(order, 'fee')
      }
      return result
    end

    def parse_order_status(status)
      statuses = {
        # original comments from bibox:
        '1' => 'open', # pending
        '2' => 'open', # part completed
        '3' => 'closed', # completed
        '4' => 'canceled', # part canceled
        '5' => 'canceled', # canceled
        '6' => 'canceled', # canceling
      }
      return self.safe_string(statuses, status, status)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      market = nil
      pair = nil
      if symbol != nil
        self.load_markets
        market = self.market(symbol)
        pair = market['id']
      end
      size = (limit) ? limit : 200
      response = self.privatePostOrderpending({
        'cmd' => 'orderpending/orderPendingList',
        'body' => self.shallow_extend({
          'pair' => pair,
          'account_type' => 0, # 0 - regular, 1 - margin
          'page' => 1,
          'size' => size
        }, params)
      })
      orders = self.safe_value(response['result'], 'items', [])
      return self.parse_orders(orders, market, since, limit)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = 200, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchClosedOrders requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostOrderpending({
        'cmd' => 'orderpending/pendingHistoryList',
        'body' => self.shallow_extend({
          'pair' => market['id'],
          'account_type' => 0, # 0 - regular, 1 - margin
          'page' => 1,
          'size' => limit
        }, params)
      })
      orders = self.safe_value(response['result'], 'items', [])
      return self.parse_orders(orders, market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      size = (limit) ? limit : 200
      response = self.privatePostOrderpending({
        'cmd' => 'orderpending/orderHistoryList',
        'body' => self.shallow_extend({
          'pair' => market['id'],
          'account_type' => 0, # 0 - regular, 1 - margin
          'page' => 1,
          'size' => size,
          'coin_symbol' => market['baseId'],
          'currency_symbol' => market['quoteId']
        }, params)
      })
      trades = self.safe_value(response['result'], 'items', [])
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostTransfer({
        'cmd' => 'transfer/transferIn',
        'body' => self.shallow_extend({
          'coin_symbol' => currency['id']
        }, params)
      })
      address = self.safe_string(response, 'result')
      tag = nil # todo => figure self out
      result = {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
      return result
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      if self.password.nil?
        if params.include?(!('trade_pwd'))
          raise(ExchangeError, self.id + ' withdraw requires self.password set on the exchange instance or a trade_pwd parameter')
        end
      end
      if params.include?(!('totp_code'))
        raise(ExchangeError, self.id + ' withdraw requires a totp_code parameter for 2FA authentication')
      end
      body = {
        'trade_pwd' => self.password,
        'coin_symbol' => currency['id'],
        'amount' => amount,
        'addr' => address
      }
      if tag != nil
        body['address_remark'] = tag
      end
      response = self.privatePostTransfer({
        'cmd' => 'transfer/transferOut',
        'body' => self.shallow_extend(body, params)
      })
      return {
        'info' => response,
        'id' => nil
      }
    end

    def fetch_funding_fees(codes = nil, params = {})
      # by default it will try load withdrawal fees of all currencies(with separate requests)
      # however if you define codes = ['ETH', 'BTC'] in args it will only load those
      self.load_markets
      withdrawFees = {}
      info = {}
      if codes.nil?
        codes = self.currencies.keys
      end
      for i in (0...codes.length)
        code = codes[i]
        currency = self.currency(code)
        response = self.privatePostTransfer({
          'cmd' => 'transfer/transferOutInfo',
          'body' => self.shallow_extend({
            'coin_symbol' => currency['id']
          }, params)
        })
        info[code] = response
        withdrawFees[code] = response['result']['withdraw_fee']
      end
      return {
        'info' => info,
        'withdraw' => withdrawFees,
        'deposit' => {}
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + path
      cmds = self.json([params])
      if api == 'public'
        if method != 'GET'
          body = { 'cmds' => cmds }
        elsif params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        body = {
          'cmds' => cmds,
          'apikey' => self.apiKey,
          'sign' => self.hmac(self.encode(cmds), self.encode(self.secret), 'md5')
        }
      end
      if body != nil
        body = self.json(body, { 'convertArraysToObjects' => true })
      end
      headers = { 'Content-Type' => 'application/json' }
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if body.length > 0
        if body[0] == '{'
          if response.include?('error')
            if response['error'].include?('code')
              code = self.safe_string(response['error'], 'code')
              feedback = self.id + ' ' + body
              exceptions = self.exceptions
              if exceptions.include?(code)
                raise(exceptions[code], feedback)
              else
                raise(ExchangeError, feedback)
              end
            end
            raise(ExchangeError, self.id + ' => "error" in response => ' + body)
          end
          if response.include?(!('result'))
            raise(ExchangeError, self.id + ' ' + body)
          end
        end
      end
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if method == 'GET'
        return response
      else
        return response['result'][0]
      end
    end
  end
end
