# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

require_relative 'okcoinusd'

module Ccxt
  class Okex < Okcoinusd
    def describe
      return self.deep_extend(super, {
        'id' => 'okex',
        'name' => 'OKEX',
        'countries' => ['CN', 'US'],
        'has' => {
          'CORS' => false,
          'futures' => true,
          'fetchTickers' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg',
          'api' => {
            'web' => 'https://www.okex.com/v2',
            'public' => 'https://www.okex.com/api',
            'private' => 'https://www.okex.com/api'
          },
          'www' => 'https://www.okex.com',
          'doc' => [
            'https://github.com/okcoin-okex/API-docs-OKEx.com',
            'https://www.okex.com/docs/en/'
          ],
          'fees' => 'https://www.okex.com/pages/products/fees.html'
        },
        'commonCurrencies' => {
          # OKEX refers to ERC20 version of Aeternity(AEToken)
          'AE' => 'AET', # https://github.com/ccxt/ccxt/issues/4981
          'FAIR' => 'FairGame',
          'HOT' => 'Hydro Protocol',
          'HSR' => 'HC',
          'MAG' => 'Maggie',
          'YOYO' => 'YOYOW'
        },
        'options' => {
          'fetchTickersMethod' => 'fetch_tickers_from_api'
        }
      })
    end

    def calculate_fee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {})
      market = self.markets[symbol]
      key = 'quote'
      rate = market[takerOrMaker]
      cost = parse_float(self.cost_to_precision(symbol, amount * rate))
      if side == 'sell'
        cost *= price
      else
        key = 'base'
      end
      return {
        'type' => takerOrMaker,
        'currency' => market[key],
        'rate' => rate,
        'cost' => parse_float(self.fee_to_precision(symbol, cost))
      }
    end

    def fetch_markets(params = {})
      markets = super(params)
      # TODO => they have a new fee schedule as of Feb 7
      # the new fees are progressive and depend on 30-day traded volume
      # the following is the worst case
      for i in (0...markets.length)
        if markets[i]['spot']
          markets[i]['maker'] = 0.0010
          markets[i]['taker'] = 0.0015
        else
          markets[i]['maker'] = 0.0002
          markets[i]['taker'] = 0.0003
        end
      end
      return markets
    end

    def fetch_tickers_from_api(symbols = nil, params = {})
      self.load_markets
      request = {}
      response = self.publicGetTickers(self.shallow_extend(request, params))
      tickers = response['tickers']
      timestamp = parse_int(response['date']) * 1000
      result = {}
      for i in (0...tickers.length)
        ticker = tickers[i]
        ticker = self.parse_ticker(self.shallow_extend(tickers[i], { 'timestamp' => timestamp }))
        symbol = ticker['symbol']
        result[symbol] = ticker
      end
      return result
    end

    def fetch_tickers_from_web(symbols = nil, params = {})
      self.load_markets
      request = {}
      response = self.webGetSpotMarketsTickers(self.shallow_extend(request, params))
      tickers = response['data']
      result = {}
      for i in (0...tickers.length)
        ticker = self.parse_ticker(tickers[i])
        symbol = ticker['symbol']
        result[symbol] = ticker
      end
      return result
    end

    def fetch_tickers(symbols = nil, params = {})
      method = self.options['fetchTickersMethod']
      response = self.send_wrapper(method, symbols, params)
      return response
    end
  end
end
