# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Mandala < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'mandala',
        'name' => 'Mandala',
        'countries' => ['MT'],
        'version' => 'v1.1',
        'rateLimit' => 1500,
        'certified' => false,
        # new metainfo interface
        'has' => {
          'cancelAllOrders' => true,
          'CORS' => true,
          'createDepositAddress' => true,
          'createMarketOrder' => true,
          'fetchCurrencies' => true,
          'fetchDepositAddress' => true,
          'fetchDepositAddresses' => true,
          'fetchDeposits' => true,
          'fetchMyTrades' => true,
          'fetchOHLCV' => true,
          'fetchOpenOrders' => true,
          'fetchOrders' => true,
          'fetchOrderStatus' => true,
          'fetchTickers' => true,
          'fetchWithdrawals' => true,
          'withdraw' => true
        },
        'timeframes' => {
          '1m' => '1',
          '5m' => '5',
          '1h' => '60',
          '1d' => '1440'
        },
        'comment' => 'Modulus Exchange API ',
        'hostname' => 'mandalaex.com',
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/54686665-df629400-4b2a-11e9-84d3-d88856367dd7.jpg',
          'api' => 'https://zapi.{hostname}',
          'www' => 'https://mandalaex.com',
          'doc' => [
            'https://documenter.getpostman.com/view/6273708/RznBP1Hh'
          ],
          'fees' => [
            'https://mandalaex.com/trading-rules/'
          ],
          'referral' => 'https://trade.mandalaex.com/?ref=564377'
        },
        'api' => {
          'settings' => {
            'get' => [
              'getCoinInfo', # FIX ME, self endpoint is documented, but broken => https://zapi.mandalaex.com/api/getCoinInfo
              'GetSettings',
              'CurrencySettings',
              'Get_Withdrawal_Limits'
            ]
          },
          'token' => {
            'post' => [
              'token'
            ]
          },
          'public' => {
            'post' => [
              'AuthenticateUser',
              'ForgotPassword',
              'SignUp',
              'check_Duplicate_Mobile',
              'check_Duplicate_Email'
            ]
          },
          'api' => {
            'get' => [
              'GAuth_Check_Status',
              'GAuth_Enable_Request',
              'GetProfile',
              'Loginhistory',
              'ListAllAddresses',
              'Get_User_Withdrawal_Limits',
              'GetPendingOrders', # ?side=aLL&pair=ALL&timestamp=1541240408&recvWindow=3600',
              'TradeHistory', # ?side=ALL&pair=ALL&timestamp=1550920234&recvWindow=10000&count=100&page=1',
              'GOKYC_Get_Kyc_Form',
              'language_list',
              'language', # ?code=en&namespace=translation',
              'get_page_n_content',
              'GetExchangeTokenDiscountEnrollmentStatus',
              'GetDiscountTiers',
              'My_Affiliate',
              'Affiliate_Summary',
              'Affiliate_Commission',
              'List_Fiat_Manual_Deposit_Requests',
              'List_Fiat_BanksList/YCN/',
              'Get_Fiat_PGs', # ?Currency=TRY',
              'get_insta_pairs',
              'hmac', # ?side=BUY&market=BTC&trade=ETH&type=STOPLIMIT&volume=0.025&rate=0.032&timeInForce=GTC&stop=2&'
            ],
            'post' => [
              'GAuth_Set_Enable',
              'GAuth_Disable_Request',
              'VerifyAccount',
              'SignUp_Resend_Email',
              'AuthenticateUser_Resend_EmailOTP/{tempAuthToken}',
              'Validate_BearerToken',
              'RequestChangePasswordOT',
              'ChangePassword',
              'ResetPassword',
              'GenerateAddress',
              'GetBalance',
              'GetDeposits',
              'GetWithdrawals',
              'RequestWithdraw',
              'RequestWithdrawConfirmation',
              'RequestTransfer_AeraPass',
              'PlaceOrder',
              'PlaceOrder_Priced',
              'CancelOrder',
              'KYC_GetSumAndSub_AccessToken',
              'KYC_SaveSumAndSubstanceApplicationId',
              'GOKYC_Submit_KYC_Form',
              'SetExchangeTokenDiscountEnrollment',
              'Dis_Enroll_ExchangeTokenDiscount',
              'Webhook_BitGoDeposit',
              'Add_Fiat_Manual_Deposit_Request',
              'Add_Fiat_Manual_Withdrawal_Request',
              'Add_Fiat_PG_Deposit_Request',
              'ListApiKey',
              'GenerateApiKey',
              'DeleteApiKey',
              'request_insta_trade',
              'confirm_insta_trade',
              'simplex_get_quote',
              'simplex_payment',
              'hmac',
              'import_translations'
            ]
          },
          'market' => {
            'get' => [
              'get-market-summary',
              'get-market-summary/{marketId}',
              'get-trade-history/{marketId}',
              'get-bid_ask-price/{marketId}',
              'get-open-orders/{marketId}/{side}/{depth}',
              'get-currency-price/{marketId}',
              'get-currency-usd-rate/{currencyId}',
              'depth', # ?symbol=BTC_ETH&limit=10
              'get-chart-data', # ?baseCurrency=BTC&quoteCurrency=ETH&interval=60&limit=200&timestamp=1541228704517
            ]
          },
          'order' => {
            'get' => [
              'my-order-history/{key}/{side}',
              'my-order-history/{key}/{side}/{orderId}',
              'my-order-status/{key}/{side}/{orderId}',
              'my-trade-history', # ?side=BUY&pair=BTC_ETH&orderID=13165837&apiKey=d14b1eb4-fe1f-4bfc-896d-97285975989e
              'hmac', # ?side=BUY&market=BTC&trade=ETH&type=STOPLIMIT&volume=0.025&rate=0.032&timeInForce=GTC&stop=2&'
            ],
            'post' => [
              'PlaceOrder',
              'cancel-my-order',
              'cancel-all-my-orders',
              'get-balance'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.005,
            'taker' => 0.005
          }
        },
        'exceptions' => {
          'exact' => {
            'Failure_General' => ExchangeError, # {"Status":"Error","Message":"Failure_General","Data":"Cannot roll back TransBuyOrder. No transaction or savepoint of that name was found."}
            'Exception_Insufficient_Funds' => InsufficientFunds, # {"Status":"Error","Message":"Exception_Insufficient_Funds","Data":"Insufficient Funds."}
            'Exception_TimeStamp' => BadRequest, # {"status":"BadRequest","message":"Exception_TimeStamp","data":"Invalid timestamp."}
            'Exception_HMAC_Validation' => AuthenticationError, # {"status":"Error","message":"Exception_HMAC_Validation","data":"HMAC validation failed."}
            'Exception_General' => BadRequest, # {"status":"BadRequest","message":"Exception_General","data":"Our servers are experiencing some glitch, please try again later."}
            'Must provide the orderID param.' => BadRequest, # {"Status":"BadRequest","Message":"Must provide the orderID param.","Data":null}
            'Invalid Market_Currency pair!' => ExchangeError, # {"status":"Error","errorMessage":"Invalid Market_Currency pair!","data":null}
            'Invalid volume parameter.' => InvalidOrder, # {"Status":"BadRequest","Message":"Invalid volume parameter.","Data":null}
            'Invalid rate parameter.' => InvalidOrder, # {"Status":"BadRequest","Message":"Invalid rate parameter.","Data":null}
            "Invalid parameter 'side', must be 'BUY' or 'SELL'." => InvalidOrder, # {"Status":"BadRequest","Message":"Invalid parameter 'side', must be 'BUY' or 'SELL'.","Data":null}
            'Invalid Type' => BadRequest, # on fetchOrders with a wrong type {"status":"Error","errorMessage":"Invalid Type","data":null}
            'Exception_Invalid_CurrencyName' => BadRequest, # {"status":"BadRequest","message":"Exception_Invalid_CurrencyName","data":"Invalid Currency name"}
            'Exception_BadRequest' => BadRequest, # {"status":"BadRequest","message":"Exception_BadRequest","data":"Invalid Payload"}
          },
          'broad' => {
          }
        },
        'options' => {
          'symbolSeparator' => '_',
          'api' => {
            'settings' => 'api',
            'public' => 'api'
          },
          'fetchCurrencies' => {
            'expires' => 5000
          },
          # https://documenter.getpostman.com/view/5614390/RWguuvfd#a74ee943-3b7a-415e-9315-a7bf204db09d
          # HMAC can be obtained using a Secret key. Thispre shared secret key ensures that the message is encrypted by a legitimate source. You can get a secret key issued for your sandbox enviroment by writing an email to support@modulus.io
          # Secret-Key : 03c06dd7-4982-441a-910d-5fd2cbb3f1c6
          'secret' => '03c06dd7-4982-441a-910d-5fd2cbb3f1c6'
        }
      })
    end

    def sign_in(params = {})
      if !self.login || !self.password
        raise(AuthenticationError, self.id + ' signIn requires self.login(email) and self.password credentials')
      end
      authenticateRequest = {
        'email' => self.login,
        'password' => self.password
      }
      authenticateResponse = self.publicPostAuthenticateUser(authenticateRequest)
      #
      #     {
      #         status => 'Success',
      #         message => 'Success!',
      #         data => {
      #             tempAuthToken => 'e1b0603a-5996-4bac-9ec4-f097a02d9696',
      #             tokenExpiry => '2019-03-19T21:16:15.999201Z',
      #             twoFAMehtod => 'GAuth'
      #         }
      #     }
      #
      data = self.safe_value(authenticateResponse, 'data', {})
      tempAuthToken = self.safe_string(data, 'tempAuthToken')
      otp = nil
      if self.twofa != nil
        otp = self.oath
      end
      otp = self.safe_string(params, 'password', otp)
      if otp.nil?
        raise(AuthenticationError, self.id + ' signIn requires self.twofa credential or a one-time 2FA "password" parameter')
      end
      tokenRequest = {
        'grant_type' => 'password',
        'username' => tempAuthToken,
        'password' => otp
      }
      tokenResponse = self.tokenPostToken(self.shallow_extend(tokenRequest, params))
      #
      #     {
      #         "access_token" => "WWRNCO--bFjX3zKAixROAjy3dbU0csNoI91PXpT1oScTrik50mVrSIbr22HrsJV5ATXgN867vy66pxY7IzMQGzYtz-7KTxUnL6uPbQpiveBgPEGD5drpvh5KwhcCOzFelJ1-OxZa6g6trx82x2YqQI7Lny0VkAIEv-EBQT8B4C_UVYhoMVCzYumeQgcxtyXc9hoRolVUwwQ965--LrAYIybBby85LzRRIfh7Yg_CVSx6zehAcHFUeKh2tE4NwN9lYweeDEPb6z2kHn0UJb18nxYcC3-NjgiyublBiY1AI_U",
      #         "token_type" => "bearer",
      #         "expires_in" => 86399
      #     }
      #
      expiresIn = self.safe_integer(tokenResponse, 'expires_in')
      self.options['expires'] = self.sum(self.milliseconds, expiresIn * 1000)
      self.options['accessToken'] = self.safe_string(tokenResponse, 'accessToken')
      self.options['tokenType'] = self.safe_string(tokenResponse, 'token_type')
      # accessToken = self.safe_value(tokenResponse, 'access_token')
      # self.headers['Authorization'] = 'Bearer ' + accessToken
      return tokenResponse
    end

    def fetch_currencies_from_cache(params = {})
      # self method is now redundant
      # currencies are now fetched before markets
      options = self.safe_value(self.options, 'fetchCurrencies', {})
      timestamp = self.safe_integer(options, 'timestamp')
      expires = self.safe_integer(options, 'expires', 1000)
      now = self.milliseconds
      if (timestamp.nil?) || ((now - timestamp) > expires)
        response = self.settingsGetCurrencySettings(params)
        self.options['fetchCurrencies'] = self.shallow_extend(options, {
          'response' => response,
          'timestamp' => now
        })
      end
      return self.safe_value(self.options['fetchCurrencies'], 'response')
    end

    def fetch_currencies(params = {})
      response = self.fetch_currencies_from_cache(params)
      self.options['currencies'] = {
        'timestamp' => self.milliseconds,
        'response' => response
      }
      #
      #     {
      #         status => 'Success',
      #         message => 'Success!',
      #         data => [
      #             {
      #                 shortName => 'BAT',
      #                 fullName => 'Basic Attention Token',
      #                 buyServiceCharge => 0.5,
      #                 sellServiceCharge => 0.5,
      #                 withdrawalServiceCharge => 0.25,
      #                 withdrawalServiceChargeInBTC => 0,
      #                 confirmationCount => 29,
      #                 contractAddress => null,
      #                 minWithdrawalLimit => 100,
      #                 maxWithdrawalLimit => 2000000,
      #                 decimalPrecision => 18,
      #                 tradeEnabled => true,
      #                 depositEnabled => true,
      #                 withdrawalEnabled => true,
      #                 secondaryWalletType => '',
      #                 addressSeparator => '',
      #                 walletType => 'BitGo',
      #                 withdrawalServiceChargeType => 'Percentage',
      #             },
      #             {
      #                 shortName => 'BCH',
      #                 fullName => 'BitcoinCash',
      #                 buyServiceCharge => 0.5,
      #                 sellServiceCharge => 0.5,
      #                 withdrawalServiceCharge => 0.25,
      #                 withdrawalServiceChargeInBTC => 0.001,
      #                 confirmationCount => 3,
      #                 contractAddress => null,
      #                 minWithdrawalLimit => 0.1,
      #                 maxWithdrawalLimit => 300,
      #                 decimalPrecision => 8,
      #                 tradeEnabled => true,
      #                 depositEnabled => true,
      #                 withdrawalEnabled => true,
      #                 secondaryWalletType => '',
      #                 addressSeparator => '',
      #                 walletType => 'BitGo',
      #                 withdrawalServiceChargeType => 'Percentage',
      #             },
      #         ]
      #     }
      #
      data = self.safe_value(response, 'data', [])
      result = {}
      for i in (0...data.length)
        currency = data[i]
        id = self.safe_string(currency, 'shortName')
        code = self.common_currency_code(id)
        name = self.safe_string(currency, 'fullName')
        precision = self.safe_integer(currency, 'decimalPrecision')
        active = true
        canWithdraw = self.safe_value(currency, 'withdrawalEnabled')
        canDeposit = self.safe_value(currency, 'depositEnabled')
        if !canWithdraw || !canDeposit
          active = false
        end
        result[code] = {
          'id' => id,
          'code' => code,
          'name' => name,
          'active' => active,
          'precision' => precision,
          'fee' => self.safe_float(currency, 'withdrawalServiceCharge') / 100,
          'limits' => {
            'amount' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'withdraw' => {
              'min' => self.safe_float(currency, 'minWithdrawalLimit'),
              'max' => self.safe_float(currency, 'maxWithdrawalLimit')
            }
          },
          'info' => currency
        }
      end
      return result
    end

    def fetch_markets(params = {})
      currenciesResponse = self.fetch_currencies_from_cache(params)
      currencies = self.safe_value(currenciesResponse, 'data', [])
      currenciesById = self.index_by(currencies, 'shortName')
      response = self.marketGetGetMarketSummary
      #
      #     {
      #         status => 'Success',
      #         errorMessage => null,
      #         data => {
      #             BTC_BAT:
      #                 Last => 0.00003431,
      #                 LowestAsk => 0,
      #                 HeighestBid => 0,
      #                 PercentChange => 0,
      #                 BaseVolume => 0,
      #                 QuoteVolume => 0,
      #                 High_24hr => 0,
      #                 Low_24hr => 0,
      #             },
      #             ETH_ZRX => {
      #                 Last => 0.00213827,
      #                 LowestAsk => 0,
      #                 HeighestBid => 0,
      #                 PercentChange => 0,
      #                 BaseVolume => 0,
      #                 QuoteVolume => 0,
      #                 High_24hr => 0,
      #                 Low_24hr => 0,
      #             },
      #         },
      #     }
      #
      result = []
      data = self.safe_value(response, 'data', {})
      ids = data.keys
      for i in (0...ids.length)
        id = ids[i]
        market = data[id]
        quoteId, baseId = id.split('_')  # they have base/quote reversed with some endpoints
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        baseCurrency = self.safe_value(currenciesById, baseId, {})
        quoteCurrency = self.safe_value(currenciesById, quoteId, {})
        precision = {
          'amount' => self.safe_integer(baseCurrency, 'decimalPrecision', 8),
          'price' => self.safe_integer(quoteCurrency, 'decimalPrecision', 8)
        }
        baseTradeEnabled = self.safe_value(baseCurrency, 'tradeEnabled', true)
        quoteTradeEnabled = self.safe_value(quoteCurrency, 'tradeEnabled', true)
        active = baseTradeEnabled && quoteTradeEnabled
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'info' => market,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => nil
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      request = {
        'currency' => 'ALL'
      }
      response = self.orderPostGetBalance(self.shallow_extend(request, params))
      #
      #     {
      #         Status => 'Success',
      #         Message => null,
      #         Data => [
      #             { currency => 'BCH', balance => 0, balanceInTrade => 0 },
      #             { currency => 'BTC', balance => 0, balanceInTrade => 0 },
      #             ...,
      #         ],
      #     }
      #
      data = self.safe_value(response, 'Data')
      result = { 'info' => response }
      for i in (0...data.length)
        balance = data[i]
        code = self.common_currency_code(self.safe_string(balance, 'currency'))
        account = self.account
        free = self.safe_float(balance, 'balance', 0)
        used = self.safe_float(balance, 'balanceInTrade', 0)
        total = self.sum(free, used)
        account['free'] = free
        account['used'] = used
        account['total'] = total
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      if limit.nil?
        limit = 10
      end
      request = {
        'symbol' => self.market_id(symbol),
        'limit' => limit
      }
      response = self.marketGetDepth(self.shallow_extend(request, params))
      # https://documenter.getpostman.com/view/6273708/RznBP1Hh#19469d73-45b5-4dd1-8464-c043efb62e00
      #
      #     {
      #         status => 'Success',
      #         errorMessage => '',
      #         data => {
      #             lastUpdate => 1552825727108,
      #             bids => [
      #                 ["0.02880201", "0.05939008", []],
      #                 ["0.02880200", "0.30969842", []],
      #             ],
      #             'asks' => [
      #                 ["0.02877161", "0.00001779", []],
      #                 ["0.02881321", "0.47325696", []],
      #             ],
      #         },
      #     }
      #
      data = self.safe_value(response, 'data', {})
      timestamp = self.safe_integer(data, 'lastUpdate')
      return self.parse_order_book(data, timestamp)
    end

    def parse_ticker(ticker, market = nil)
      #
      # fetchTicker, fetchTickers
      #     {
      #         Pair => 'ETH_MDX', # FIXME missing in fetchTickers
      #         Last => 0.000055,
      #         LowestAsk => 0.000049,
      #         HeighestBid => 0.00003,
      #         PercentChange => 12.47,
      #         BaseVolume => 34.60345,
      #         QuoteVolume => 629153.63636364,
      #         IsFrozen => false, # FIXME missing in fetchTickers
      #         High_24hr => 0,
      #         Low_24hr => 0
      #     }
      #
      symbol = nil
      marketId = self.safe_string(ticker, 'Pair')
      if marketId != nil
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
          symbol = market['symbol']
        else
          symbol = self.parse_symbol(marketId)
        end
      end
      if symbol.nil?
        if market != nil
          symbol = market['symbol']
        end
      end
      last = self.safe_float(ticker, 'Last')
      return {
        'symbol' => symbol,
        'timestamp' => nil, # FIXME, no timestamp in tickers
        'datetime' => nil,
        'high' => self.safe_float(ticker, 'High_24hr'),
        'low' => self.safe_float(ticker, 'Low_24hr'),
        'bid' => self.safe_float(ticker, 'HeighestBid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'LowestAsk'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => self.safe_float(ticker, 'PercentChange'),
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'QuoteVolume'),
        'quoteVolume' => self.safe_float(ticker, 'BaseVolume'),
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.marketGetGetMarketSummary(params)
      #
      #     {
      #         status => 'Success',
      #         errorMessage => null,
      #         data => {
      #             BTC_BAT => {
      #                 Last => 0.00003431,
      #                 LowestAsk => 0,
      #                 HeighestBid => 0,
      #                 PercentChange => 0,
      #                 BaseVolume => 0,
      #                 QuoteVolume => 0,
      #                 High_24hr => 0,
      #                 Low_24hr => 0,
      #             },
      #             ETH_ZRX => {
      #                 Last => 0.00213827,
      #                 LowestAsk => 0,
      #                 HeighestBid => 0,
      #                 PercentChange => 0,
      #                 BaseVolume => 0,
      #                 QuoteVolume => 0,
      #                 High_24hr => 0,
      #                 Low_24hr => 0,
      #             },
      #         },
      #     }
      #
      data = self.safe_value(response, 'data', {})
      ids = data.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        ticker = data[id]
        market = nil
        symbol = id
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        else
          symbol = self.parse_symbol(id)
        end
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      request = {
        'marketId' => self.market_id(symbol)
      }
      response = self.marketGetGetMarketSummaryMarketId(self.shallow_extend(request, params))
      #
      #     {
      #         status => 'Success',
      #         errorMessage => null,
      #         data => {
      #             Pair => 'ETH_MDX',
      #             Last => 0.000055,
      #             LowestAsk => 0.000049,
      #             HeighestBid => 0.00003,
      #             PercentChange => 12.47,
      #             BaseVolume => 34.60345,
      #             QuoteVolume => 629153.63636364,
      #             IsFrozen => false,
      #             High_24hr => 0,
      #             Low_24hr => 0
      #         }
      #     }
      #
      data = self.safe_value(response, 'data')
      return self.parse_ticker(data)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #     {
      #         TradeID =>  619255,
      #         Rate =>  0.000055,
      #         Volume =>  79163.63636364,
      #         Total =>  4.354,
      #         Date => "2019-03-16T23:14:48.613",
      #         Type => "Buy"
      #     }
      #
      # fetchMyTrades(private)
      #
      #     {
      #         orderId => 20000040,
      #         market => 'ETH',
      #         trade => 'MDX',
      #         volume => 1,
      #         rate => 2,
      #         amount => 2,
      #         serviceCharge => 0.003,
      #         side => 'SELL',
      #         date => '2019-03-20T01:47:09.14'
      #     }
      #
      timestamp = self.parse8601(self.safe_string_2(trade, 'Date', 'date'))
      side = self.safe_string_2(trade, 'Type', 'side')
      if side != nil
        side = side.downcase
      end
      id = self.safe_string(trade, 'TradeID')
      symbol = nil
      baseId = self.safe_string(trade, 'trade')
      quoteId = self.safe_string(trade, 'market')
      base = self.common_currency_code(baseId)
      quote = self.common_currency_code(quoteId)
      if base != nil && quote != nil
        symbol = base + '/' + quote
      else
        if market != nil
          symbol = market['symbol']
        end
      end
      cost = self.safe_float_2(trade, 'Total', 'amount')
      price = self.safe_float_2(trade, 'Rate', 'rate')
      amount = self.safe_float_2(trade, 'Volume', 'volume')
      orderId = self.safe_string(trade, 'orderId')
      feeCost = self.safe_value(trade, 'serviceCharge')
      fee = nil
      if feeCost != nil
        fee = {
          'cost' => feeCost,
          'currency' => quote
        }
      end
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => id,
        'order' => orderId,
        'type' => nil,
        'takerOrMaker' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'marketId' => market['id']
      }
      # self endpoint returns last 50 trades
      response = self.marketGetGetTradeHistoryMarketId(self.shallow_extend(request, params))
      #
      #     {
      #         status =>   "Success",
      #         errorMessage =>    null,
      #         data => [
      #             {
      #                 TradeID =>  619255,
      #                 Rate =>  0.000055,
      #                 Volume =>  79163.63636364,
      #                 Total =>  4.354,
      #                 Date => "2019-03-16T23:14:48.613",
      #                 Type => "Buy"
      #             },
      #             {
      #                 TradeID =>  619206,
      #                 Rate =>  0.000073,
      #                 Volume =>  7635.50136986,
      #                 Total =>  0.5573916,
      #                 Date => "2019-02-13T16:49:54.02",
      #                 Type => "Sell"
      #             }
      #         ]
      #     }
      #
      data = self.safe_value(response, 'data')
      return self.parse_trades(data, market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      #
      #     {
      #         time => 1552830600000,
      #         open => 0.000055,
      #         close => 0.000055,
      #         high => 0.000055,
      #         low => 0.000055,
      #         volume => 0,
      #     }
      #
      return [
        self.safe_integer(ohlcv, 'time'),
        self.safe_float(ohlcv, 'open'),
        self.safe_float(ohlcv, 'high'),
        self.safe_float(ohlcv, 'low'),
        self.safe_float(ohlcv, 'close'),
        self.safe_float(ohlcv, 'volume')
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      if limit.nil?
        limit = 100 # default is 100
      end
      offset = self.parse_timeframe(timeframe) * self.sum(limit, 1) * 1000
      if since.nil?
        since = self.milliseconds - offset
      end
      request = {
        'interval' => self.timeframes[timeframe],
        'baseCurrency' => market['baseId'], # they have base/quote reversed with some endpoints
        'quoteCurrency' => market['quoteId'],
        'limit' => limit,
        'timestamp' => self.sum(since, offset)
      }
      response = self.marketGetGetChartData(self.shallow_extend(request, params))
      #
      #     {
      #         status => 'Success',
      #         errorMessage => null,
      #         data => [
      #             {
      #                 time => 1552830600000,
      #                 open => 0.000055,
      #                 close => 0.000055,
      #                 high => 0.000055,
      #                 low => 0.000055,
      #                 volume => 0,
      #             },
      #             {
      #                 time => 1552830540000,
      #                 open => 0.000055,
      #                 close => 0.000055,
      #                 high => 0.000055,
      #                 low => 0.000055,
      #                 volume => 0,
      #             },
      #         ],
      #     }
      #
      data = self.safe_value(response, 'data')
      return self.parse_ohlcvs(data, market, timeframe, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      orderPrice = price
      if type == 'market'
        orderPrice = 0
      end
      request = {
        'market' => market['quoteId'],
        'trade' => market['baseId'],
        'type' => type.upcase, # MARKET, LIMIT, STOPLIMIT
        'side' => side.upcase, # BUY, SELL
        # Here GTC should be default for LIMIT, MARKET & STOP LIMIT Orders.
        # IOC,FOK, DO must be passed only with a LIMIT order.
        # GTC(Good till cancelled), IOC(Immediate or cancel), FOK(Fill or Kill), Do(Day only)
        'timeInForce' => 'GTC',
        'rate' => self.price_to_precision(symbol, orderPrice),
        'volume' => self.amount_to_precision(symbol, amount),
        # the stop-price at which a stop-limit order
        # triggers and becomes a limit order
        'stop' => 0, # stop is always zero for limit and market orders
        # 'clientOrderId' => self.uuid
      }
      response = self.orderPostPlaceOrder(self.shallow_extend(request, params))
      #
      #     {
      #         Status => 'Success',
      #         Message => 'Success!',
      #         Data => {
      #             orderId => 20000031,
      #         },
      #     }
      #
      data = self.safe_value(response, 'Data', {})
      order = self.parse_order(data, market)
      return self.shallow_extend(order, {
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'status' => 'open'
      })
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      side = self.safe_string(params, 'side')
      if side.nil?
        raise(ArgumentsRequired, self.id + ' cancelOrder requires an order side extra parameter')
      end
      params = self.omit(params, 'side')
      request = {
        'orderId' => id.to_s,
        'side' => side.upcase
      }
      response = self.orderPostCancelMyOrder(self.shallow_extend(request, params))
      #
      #     {
      #         Status => 'Success',
      #         Message => 'Success_General',
      #         Data => 'Success!'
      #     }
      #
      return self.parse_order(response, {
        'id' => id,
        'symbol' => symbol,
        'side' => side,
        'status' => 'canceled'
      })
    end

    def cancel_all_orders(symbols = nil, params = {})
      side = self.safe_string(params, 'side')
      if side.nil?
        raise(ArgumentsRequired, self.id + ' cancelAllOrders requires an order side extra parameter')
      end
      params = self.omit(params, 'side')
      if symbols.nil?
        raise(ArgumentsRequired, self.id + ' cancelAllOrders requires a symbols argument(a list containing one symbol)')
      else
        numSymbols = symbols.length
        if numSymbols != 1
          raise(ArgumentsRequired, self.id + ' cancelAllOrders requires a symbols argument(a list containing one symbol)')
        end
      end
      symbol = symbols[0]
      request = {
        'side' => side.upcase,
        'pair' => self.market_id(symbol)
      }
      return self.orderPostCancelAllMyOrders(self.shallow_extend(request, params))
    end

    def parse_symbol(id)
      quote, base = id.split(self.options['symbolSeparator'])
      base = self.common_currency_code(base)
      quote = self.common_currency_code(quote)
      return base + '/' + quote
    end

    def parse_order(order, market = nil)
      #
      # fetchOrders
      #
      #     {
      #         orderId => 20000038,
      #         market => 'BTC',
      #         trade => 'ETH',
      #         volume => 1,
      #         pendingVolume => 1,
      #         orderStatus => false,
      #         rate => 1,
      #         amount => 1,
      #         serviceCharge => 0,
      #         placementDate => '2019-03-19T18:28:43.553',
      #         completionDate => null
      #     }
      #
      # fetchOpenOrders
      #
      #     {
      #         orderId => 20000038,
      #         market => 'BTC',
      #         trade => 'ETH',
      #         volume => 1,
      #         rate => 1,
      #         side => 'SELL',
      #         date => '2019-03-19T18:28:43.553',
      #     }
      #
      # fetchOrderStatus
      #
      #     {
      #         "PendingVolume" => 0.7368974,
      #         "Volume" => 0.7368974,
      #         "Price" => 0.22921771,
      #         "Status" => true
      #     }
      #
      id = self.safe_string(order, 'orderId')
      baseId = self.safe_string(order, 'trade')
      quoteId = self.safe_string(order, 'market')
      base = self.common_currency_code(baseId)
      quote = self.common_currency_code(quoteId)
      symbol = nil
      if base != nil && quote != nil
        symbol = base + '/' + quote
      end
      completionDate = self.parse8601(self.safe_string(order, 'completionDate'))
      timestamp = self.parse8601(self.safe_string_2(order, 'placementDate', 'date'))
      price = self.safe_float_2(order, 'rate', 'Price')
      amount = self.safe_float_2(order, 'volume', 'Volume')
      cost = self.safe_float(order, 'amount')
      remaining = self.safe_float_2(order, 'pendingVolume', 'PendingVolume')
      filled = nil
      if amount != nil && remaining != nil
        filled = maximum_wrapper(amount - remaining, 0)
      end
      if !cost
        if price && filled
          cost = price * filled
        end
      end
      if !price
        if cost && filled
          price = cost / filled
        end
      end
      status = self.safe_value_2(order, 'orderStatus', 'Status')
      status = status ? 'closed' : 'open'
      lastTradeTimestamp = nil
      if filled > 0
        lastTradeTimestamp = completionDate
      end
      if (filled != nil) && (amount != nil)
        if (filled < amount) && (status == 'closed')
          status = 'canceled'
        end
      end
      feeCost = self.safe_value(order, 'serviceCharge')
      fee = nil
      if feeCost != nil
        fee = {
          'cost' => feeCost,
          'currency' => quote
        }
      end
      return {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => nil,
        'price' => price,
        'cost' => cost,
        'average' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee
      }
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      side = self.safe_string(params, 'side')
      if side.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrders requires an order side extra parameter')
      end
      params = self.omit(params, 'side')
      request = {
        'key' => self.apiKey,
        'side' => side.upcase,
        # 'orderId' => id
      }
      response = self.orderGetMyOrderHistoryKeySide(self.shallow_extend(request, params))
      #
      #     {
      #         status => 'Success',
      #         errorMessage => null,
      #         data => [
      #             {
      #                 orderId => 20000038,
      #                 market => 'BTC',
      #                 trade => 'ETH',
      #                 volume => 1,
      #                 pendingVolume => 1,
      #                 orderStatus => false,
      #                 rate => 1,
      #                 amount => 1,
      #                 serviceCharge => 0,
      #                 placementDate => '2019-03-19T18:28:43.553',
      #                 completionDate => null
      #             },
      #             {
      #                 orderId => 20000037,
      #                 market => 'BTC',
      #                 trade => 'ETH',
      #                 volume => 1,
      #                 pendingVolume => 1,
      #                 orderStatus => true,
      #                 rate => 1,
      #                 amount => 1,
      #                 serviceCharge => 0,
      #                 placementDate => '2019-03-19T18:27:51.087',
      #                 completionDate => '2019-03-19T18:28:16.07'
      #             }
      #         ]
      #     }
      #
      data = self.safe_value(response, 'data', [])
      market = (symbol != nil) ? self.market(symbol) : nil
      return self.parse_orders(data, market, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      side = self.safe_string(params, 'side', 'ALL')
      params = self.omit(params, 'side')
      market = nil
      pair = 'ALL'
      if symbol != nil
        market = self.market(symbol)
        pair = market['baseId'] + '-' + market['quoteId']
      end
      request = {
        'side' => side.upcase,
        'pair' => pair
      }
      response = self.apiGetGetPendingOrders(self.shallow_extend(request, params))
      #
      #     {
      #         status => 'Success',
      #         message => 'Success!',
      #         data => [
      #             {
      #                 orderId => 20000038,
      #                 market => 'BTC',
      #                 trade => 'ETH',
      #                 volume => 1,
      #                 rate => 1,
      #                 side => 'SELL',
      #                 date => '2019-03-19T18:28:43.553',
      #             },
      #             {
      #                 orderId => 20000039,
      #                 market => 'BTC',
      #                 trade => 'ETH',
      #                 volume => 1,
      #                 rate => 2,
      #                 side => 'SELL',
      #                 date => '2019-03-19T18:48:12.033',
      #             }
      #         ]
      #     }
      #
      data = self.safe_value(response, 'data')
      return self.parse_orders(data, market, since, limit)
    end

    def fetch_order_status(id, symbol = nil, params = {})
      self.load_markets
      side = self.safe_string(params, 'side')
      if side.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrderStatus requires an order side extra parameter')
      end
      params = self.omit(params, 'side')
      request = {
        'key' => self.apiKey,
        'side' => side.upcase,
        'orderId' => id.to_s
      }
      response = self.orderGetMyOrderStatusKeySideOrderId(self.shallow_extend(request, params))
      #
      #     {
      #         "status" => "Success",
      #         "errorMessage" => null,
      #         "data" => {
      #             "PendingVolume" => 0.7368974,
      #             "Volume" => 0.7368974,
      #             "Price" => 0.22921771,
      #             "Status" => true
      #         }
      #     }
      #
      data = self.safe_value(response, 'data')
      order = self.parse_order(data)
      return order['status']
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      side = self.safe_string(params, 'side', 'ALL')
      params = self.omit(params, 'side')
      market = nil
      pair = 'ALL'
      if symbol != nil
        market = self.market(symbol)
        pair = market['id']
      end
      request = {
        'side' => side.upcase,
        'pair' => pair,
        'orderID' => -1,
        'apiKey' => self.apiKey
      }
      response = self.orderGetMyTradeHistory(self.shallow_extend(request, params))
      #
      #     {
      #         Status => 'Success',
      #         Message => null,
      #         Data => [
      #             {
      #                 orderId => 20000040,
      #                 market => 'ETH',
      #                 trade => 'MDX',
      #                 volume => 1,
      #                 rate => 2,
      #                 amount => 2,
      #                 serviceCharge => 0.003,
      #                 side => 'SELL',
      #                 date => '2019-03-20T01:47:09.14'
      #             },
      #             {
      #                 orderId => 20000041,
      #                 market => 'ETH',
      #                 trade => 'MDX',
      #                 volume => 0.5,
      #                 rate => 3,
      #                 amount => 1.5,
      #                 serviceCharge => 0.00225,
      #                 side => 'SELL',
      #                 date => '2019-03-20T01:49:20.42'
      #             },
      #             {
      #                 orderId => 20000041,
      #                 market => 'ETH',
      #                 trade => 'MDX',
      #                 volume => 0.25,
      #                 rate => 3,
      #                 amount => 0.75,
      #                 serviceCharge => 0.001125,
      #                 side => 'SELL',
      #                 date => '2019-03-20T01:51:01.307'
      #             }
      #         ]
      #     }
      #
      data = self.safe_value(response, 'Data')
      return self.parse_trades(data, market, since, limit)
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      currency = nil
      requestCurrency = 'ALL'
      if code != nil
        currency = self.currency(code)
        requestCurrency = currency['id']
      end
      request = {
        'currency' => requestCurrency
      }
      response = self.apiPostGetDeposits(self.shallow_extend(request, params))
      #
      #     {
      #         "status" => "Success",
      #         "message" => null,
      #         "data" => {
      #             "deposits" => [
      #                 {
      #                     ?
      #                 }
      #             ]
      #         }
      #     }
      #
      data = self.safe_value(response, 'data', {})
      deposits = self.safe_value(data, 'deposits', [])
      return self.parseTransactions(deposits, currency, since, limit)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      currency = nil
      requestCurrency = 'ALL'
      if code != nil
        currency = self.currency(code)
        requestCurrency = currency['id']
      end
      request = {
        'currency' => requestCurrency
      }
      response = self.apiPostGetWithdrawals(self.shallow_extend(request, params))
      #
      #     {
      #         "status" => "Success",
      #         "message" => null,
      #         "data" => {
      #             "withdrawals" => [
      #                 {
      #                     "withdrawalType" => "ETH",
      #                     "withdrawalAddress" => "0xE28CE3A999d6035d042D1a87FAab389Cb0B78Db6",
      #                     "withdrawalAmount" => 0.071,
      #                     "txnHash" => null,
      #                     "withdrawalReqDate" => "2018-11-12T09:38:28.43",
      #                     "withdrawalConfirmDate" => null,
      #                     "withdrawalStatus" => "Pending"
      #                 }
      #             ]
      #         }
      #     }
      #
      data = self.safe_value(response, 'data', {})
      withdrawals = self.safe_value(data, 'withdrawals', [])
      return self.parseTransactions(withdrawals, currency, since, limit)
    end

    def parse_transaction_status(status)
      statuses = {
        'Pending' => 'pending'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchDeposits
      #
      #     {
      #         ?
      #     }
      #
      # fetchWithdrawals
      #
      #     {
      #         "withdrawalType" => "ETH",
      #         "withdrawalAddress" => "0xE28CE3A999d6035d042D1a87FAab389Cb0B78Db6",
      #         "withdrawalAmount" => 0.071,
      #         "txnHash" => null,
      #         "withdrawalReqDate" => "2018-11-12T09:38:28.43",
      #         "withdrawalConfirmDate" => null,
      #         "withdrawalStatus" => "Pending"
      #     }
      #
      id = nil
      amount = self.safe_float(transaction, 'withdrawalAmount')
      address = self.safe_string(transaction, 'withdrawalAddress')
      tag = nil
      txid = self.safe_string(transaction, 'txnHash')
      updated = self.parse8601(self.safe_value(transaction, 'withdrawalConfirmDate'))
      timestamp = self.parse8601(self.safe_string(transaction, 'withdrawalReqDate', updated))
      type = (transaction.include?('withdrawalReqDate')) ? 'withdrawal' : 'deposit'
      code = nil
      currencyId = self.safe_string(transaction, 'withdrawalType')
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency != nil
        code = currency['code']
      else
        code = self.common_currency_code(currencyId)
      end
      status = self.parse_transaction_status(self.safe_string(transaction, 'withdrawalStatus'))
      feeCost = nil
      if type == 'deposit'
        status = 'ok'
        feeCost = 0
      end
      fee = nil
      if feeCost != nil
        fee = {
          'cost' => feeCost,
          'currency' => code
        }
      end
      return {
        'info' => transaction,
        'id' => id,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => tag,
        'status' => status,
        'type' => type,
        'updated' => updated,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => fee
      }
    end

    def parse_deposit_addresses(addresses)
      result = []
      ids = addresses.keys
      for i in (0...ids.length)
        id = ids[i]
        address = addresses[id]
        currencyId = id.upcase
        currency = self.safe_value(self.currencies_by_id, currencyId)
        result.push(self.parse_deposit_address(address, currency))
      end
      return result
    end

    def fetch_deposit_addresses(codes = nil, params = {})
      self.load_markets
      response = self.apiGetListAllAddresses(params)
      #
      #     {
      #         "status" => "Success",
      #         "message" => null,
      #         "data" => {
      #             "btc" => "3PLKhwm59C21U3KN3YZVQmrQhoE3q1p1i8",
      #             "eth" => "0x8143c11ed6b100e5a96419994846c890598647cf",
      #             "xrp" => "rKHZQttBiDysDT4PtYL7RmLbGm6p5HBHfV:3931222419"
      #         }
      #     }
      #
      data = self.safe_value(response, 'data')
      return self.parse_deposit_addresses(data)
    end

    def parse_deposit_address(depositAddress, currency = nil)
      #
      #     "btc" => "3PLKhwm59C21U3KN3YZVQmrQhoE3q1p1i8",
      #     "eth" => "0x8143c11ed6b100e5a96419994846c890598647cf",
      #     "xrp" => "rKHZQttBiDysDT4PtYL7RmLbGm6p5HBHfV:3931222419"
      #
      parts = depositAddress.split(':')
      address = parts[0]
      self.check_address(address)
      tag = nil
      numParts = parts.length
      if numParts > 1
        tag = parts[1]
      end
      code = nil
      if currency != nil
        code = currency['code']
      end
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => depositAddress
      }
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = self.apiPostGenerateAddress(self.shallow_extend(request, params))
      #
      #     {
      #         status => 'Success',
      #         message => '',
      #         data => {
      #             address => '0x13a1ac355bf1be5b157486f619169cf7f9ffed4e'
      #         }
      #     }
      #
      data = self.safe_value(response, 'data', {})
      address = self.safe_string(data, 'address')
      return self.parse_deposit_address(address, currency)
    end

    def create_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = self.apiPostGenerateAddress(self.shallow_extend(request, params))
      #
      #     {
      #         status => 'Success',
      #         message => '',
      #         data => {
      #             address => '0x13a1ac355bf1be5b157486f619169cf7f9ffed4e'
      #         }
      #     }
      #
      data = self.safe_value(response, 'data', {})
      address = self.safe_string(data, 'address')
      return self.parse_deposit_address(address, currency)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      withdrawalRequest = {
        'currency' => currency['id'],
        'amount' => parse_float(amount),
        'address' => address,
        # 'addressTag' => null
      }
      if tag != nil
        withdrawalRequest['addressTag'] = tag
      end
      withdrawalResponse = self.apiPostRequestWithdraw(self.shallow_extend(withdrawalRequest, params))
      #
      #     {
      #         "status" => "Success",
      #         "message" => null,
      #         "data" => {
      #             "withdrawalId" => "E26AA92F-F526-4F6C-85FD-B1EA9B1B118D"
      #         }
      #     }
      #
      data = self.safe_value(withdrawalResponse, 'data', {})
      id = self.safe_string(data, 'withdrawalId')
      otp = nil
      if self.twofa != nil
        otp = self.oath
      end
      otp = self.safe_string(params, 'emailToken', otp)
      if otp.nil?
        raise(AuthenticationError, self.id + ' signIn requires self.twofa credential or a one-time 2FA "emailToken" parameter')
      end
      confirmationRequest = {
        'EmailToken' => otp
      }
      confirmationResponse = self.apiPostRequestWithdrawConfirmation(self.shallow_extend(confirmationRequest, params))
      timestamp = self.milliseconds
      return {
        'info' => [withdrawalResponse, confirmationResponse],
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => tag,
        'addressFrom' => nil,
        'tagFrom' => nil,
        'addressTo' => address,
        'tagTo' => tag,
        'type' => 'withdrawal',
        'updated' => nil,
        'txid' => nil,
        'status' => 'pending',
        'fee' => nil
      }
    end

    def sign(path, api = 'api', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.implode_params(self.urls['api'], {
        'hostname' => self.hostname
      })
      if api != 'token'
        url += '/' + self.safe_string(self.options['api'], api, api)
      end
      url += '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      # isPublic = self.safe_value(self.options['api'], api, true)
      if api == 'market' || api == 'settings' || api == 'public'
        if method == 'POST'
          body = self.json(query)
          headers = {
            'Content-Type' => 'application/json'
          }
        else
          if query
            url += '?' + self.urlencode(query)
          end
        end
      elsif api == 'token'
        body = self.urlencode(query)
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      else
        self.check_required_credentials
        query = self.keysort(self.shallow_extend({
          'timestamp' => self.seconds
        }, query))
        auth = self.urlencode(query)
        secret = (api == 'api') ? self.options['secret'] : self.secret
        signature = self.hmac(self.encode(auth), self.encode(secret), 'sha512')
        headers = {
          'HMAC' => signature.upcase
        }
        if api == 'api'
          token = self.safe_string(self.options, 'accessToken')
          if token.nil?
            raise(AuthenticationError, self.id + ' ' + path + ' endpoint requires an accessToken option or a prior call to signIn method')
          end
          expires = self.safe_integer(self.options, 'expires')
          if expires != nil
            if self.milliseconds >= expires
              raise(AuthenticationError, self.id + ' accessToken expired, supply a new accessToken or call signIn method')
            end
          end
          tokenType = self.safe_string(self.options, 'tokenType', 'bearer')
          headers['Authorization'] = tokenType + ' ' + token
        end
        if method == 'POST'
          body = self.json(query)
          headers['Content-Type'] = 'application/json'
          headers['publicKey'] = self.apiKey
        elsif method == 'GET'
          if query
            url += '?' + self.urlencode(query)
          end
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !response
        return # fallback to default error handler
      end
      #
      #     {"Status":"Error","Message":"Exception_Insufficient_Funds","Data":"Insufficient Funds."}
      #     {"status":"Error","errorMessage":"Invalid Market_Currency pair!","data":null}
      #     {"status":"BadRequest","message":"Exception_BadRequest","data":"Invalid Payload"}
      #
      #
      status = self.safe_string_2(response, 'status', 'Status')
      if (status != nil) && (status != 'Success')
        message = self.safe_string_2(response, 'errorMessage', 'Message')
        message = self.safe_string(response, 'message', message)
        feedback = self.id + ' ' + self.json(response)
        exact = self.exceptions['exact']
        if exact.include?(message)
          raise(exact[message], feedback)
        end
        broad = self.exceptions['broad']
        broadKey = self.findBroadlyMatchedKey(broad, message)
        if broadKey != nil
          raise(broad[broadKey], feedback)
        end
        raise(ExchangeError, feedback) # unknown message
      end
    end
  end
end
