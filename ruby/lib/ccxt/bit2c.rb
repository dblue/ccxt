# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bit2c < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bit2c',
        'name' => 'Bit2C',
        'countries' => ['IL'], # Israel
        'rateLimit' => 3000,
        'has' => {
          'CORS' => false,
          'fetchOpenOrders' => true,
          'fetchMyTrades' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg',
          'api' => 'https://bit2c.co.il',
          'www' => 'https://www.bit2c.co.il',
          'doc' => [
            'https://www.bit2c.co.il/home/api',
            'https://github.com/OferE/bit2c'
          ]
        },
        'api' => {
          'public' => {
            'get' => [
              'Exchanges/{pair}/Ticker',
              'Exchanges/{pair}/orderbook',
              'Exchanges/{pair}/trades',
              'Exchanges/{pair}/lasttrades'
            ]
          },
          'private' => {
            'post' => [
              'Merchant/CreateCheckout',
              'Order/AddCoinFundsRequest',
              'Order/AddFund',
              'Order/AddOrder',
              'Order/AddOrderMarketPriceBuy',
              'Order/AddOrderMarketPriceSell',
              'Order/CancelOrder',
              'Order/AddCoinFundsRequest',
              'Order/AddStopOrder',
              'Payment/GetMyId',
              'Payment/Send',
              'Payment/Pay'
            ],
            'get' => [
              'Account/Balance',
              'Account/Balance/v2',
              'Order/MyOrders',
              'Order/GetById',
              'Order/AccountHistory',
              'Order/OrderHistory'
            ]
          }
        },
        'markets' => {
          'BTC/NIS' => { 'id' => 'BtcNis', 'symbol' => 'BTC/NIS', 'base' => 'BTC', 'quote' => 'NIS' },
          'ETH/NIS' => { 'id' => 'EthNis', 'symbol' => 'ETH/NIS', 'base' => 'ETH', 'quote' => 'NIS' },
          'BCH/NIS' => { 'id' => 'BchAbcNis', 'symbol' => 'BCH/NIS', 'base' => 'BCH', 'quote' => 'NIS' },
          'LTC/NIS' => { 'id' => 'LtcNis', 'symbol' => 'LTC/NIS', 'base' => 'LTC', 'quote' => 'NIS' },
          'ETC/NIS' => { 'id' => 'EtcNis', 'symbol' => 'ETC/NIS', 'base' => 'ETC', 'quote' => 'NIS' },
          'BTG/NIS' => { 'id' => 'BtgNis', 'symbol' => 'BTG/NIS', 'base' => 'BTG', 'quote' => 'NIS' },
          'BSV/NIS' => { 'id' => 'BchSvNis', 'symbol' => 'BSV/NIS', 'base' => 'BSV', 'quote' => 'NIS' }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.5 / 100,
            'taker' => 0.5 / 100
          }
        },
        'options' => {
          'fetchTradesMethod' => 'public_get_exchanges_pair_lasttrades'
        }
      })
    end

    def fetch_balance(params = {})
      balance = self.privateGetAccountBalanceV2
      result = { 'info' => balance }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        account = self.account
        if balance.include?(currency)
          available = 'AVAILABLE_' + currency
          account['free'] = balance[available]
          account['total'] = balance[currency]
          account['used'] = account['total'] - account['free']
        end
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      orderbook = self.publicGetExchangesPairOrderbook(self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook)
    end

    def fetch_ticker(symbol, params = {})
      ticker = self.publicGetExchangesPairTicker(self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      timestamp = self.milliseconds
      averagePrice = self.safe_float(ticker, 'av')
      baseVolume = self.safe_float(ticker, 'a')
      quoteVolume = nil
      if baseVolume != nil && averagePrice != nil
        quoteVolume = baseVolume * averagePrice
      end
      last = self.safe_float(ticker, 'll')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => self.safe_float(ticker, 'h'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'l'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => averagePrice,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      method = self.options['fetchTradesMethod']
      response = self.send_wrapper(method, self.shallow_extend({
        'pair' => market['id']
      }, params))
      if response.is_a?(String)
        raise(ExchangeError, response)
      end
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      method = 'privatePostOrderAddOrder'
      order = {
        'Amount' => amount,
        'Pair' => self.market_id(symbol)
      }
      if type == 'market'
        method += 'MarketPrice' + self.capitalize(side)
      else
        order['Price'] = price
        order['Total'] = amount * price
        order['IsBid'] = (side == 'buy')
      end
      result = self.send_wrapper(method, self.shallow_extend(order, params))
      return {
        'info' => result,
        'id' => result['NewOrder']['id']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostOrderCancelOrder({ 'id' => id })
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.implode_params(path, params)
      if api == 'public'
        # lasttrades is the only endpoint that doesn't require the .json extension/suffix
        if !path.include?('lasttrades')
          url += '.json'
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        query = self.shallow_extend({ 'nonce' => nonce }, params)
        body = self.urlencode(query)
        signature = self.hmac(self.encode(body), self.encode(self.secret), 'sha512', 'base64')
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'key' => self.apiKey,
          'sign' => self.decode(signature)
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOpenOrders requires a symbol argument')
      end
      market = self.market(symbol)
      response = self.privateGetOrderMyOrders(self.shallow_extend({
        'pair' => market['id']
      }, params))
      orders = self.safe_value(response, market['id'], {})
      asks = self.safe_value(orders, 'ask')
      bids = self.safe_value(orders, 'bid')
      return self.parse_orders(self.array_concat(asks, bids), market, since, limit)
    end

    def parse_order(order, market = nil)
      timestamp = order['created']
      price = order['price']
      amount = order['amount']
      cost = price * amount
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      side = self.safe_value(order, 'type')
      if side == 0
        side = 'buy'
      elsif side == 1
        side = 'sell'
      end
      id = self.safe_string(order, 'id')
      status = self.safe_string(order, 'status')
      return {
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'filled' => nil,
        'remaining' => nil,
        'cost' => cost,
        'trades' => nil,
        'fee' => nil,
        'info' => order
      }
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      method = 'privateGetOrderOrderhistory'
      request = {}
      if limit != nil
        request['take'] = limit
      end
      request['take'] = limit
      if since != nil
        request['toTime'] = self.ymd(self.milliseconds, '.')
        request['fromTime'] = self.ymd(since, '.')
      end
      if symbol != nil
        market = self.market(symbol)
        request['pair'] = market['id']
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      return self.parse_trades(response, market, since, limit)
    end

    def parse_trade(trade, market = nil)
      timestamp = nil
      id = nil
      price = nil
      amount = nil
      orderId = nil
      feeCost = nil
      side = nil
      reference = self.safe_string(trade, 'reference')
      if reference != nil
        timestamp = self.safe_integer(trade, 'ticks') * 1000
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'firstAmount')
        reference_parts = reference.split('|') # reference contains => 'pair|orderId|tradeId'
        if market.nil?
          marketId = self.safe_string(trade, 'pair')
          if self.markets_by_id[marketId].include?(marketId)
            market = self.markets_by_id[marketId]
          elsif self.markets_by_id.include?(reference_parts[0])
            market = self.markets_by_id[reference_parts[0]]
          end
        end
        orderId = reference_parts[1]
        id = reference_parts[2]
        side = self.safe_integer(trade, 'action')
        if side == 0
          side = 'buy'
        elsif side == 1
          side = 'sell'
        end
        feeCost = self.safe_float(trade, 'feeAmount')
      else
        timestamp = self.safe_integer(trade, 'date') * 1000
        id = self.safe_string(trade, 'tid')
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'amount')
        side = self.safe_value(trade, 'isBid')
        if side != nil
          if side
            side = 'buy'
          else
            side = 'sell'
          end
        end
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      return {
        'info' => trade,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => orderId,
        'type' => nil,
        'side' => side,
        'takerOrMaker' => nil,
        'price' => price,
        'amount' => amount,
        'cost' => price * amount,
        'fee' => {
          'cost' => feeCost,
          'currency' => 'NIS',
          'rate' => nil
        }
      }
    end
  end
end
