# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Cryptopia < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'cryptopia',
        'name' => 'Cryptopia',
        'rateLimit' => 1500,
        'countries' => ['NZ'], # New Zealand
        'has' => {
          'CORS' => false,
          'createMarketOrder' => false,
          'fetchClosedOrders' => 'emulated',
          'fetchCurrencies' => true,
          'fetchDepositAddress' => true,
          'fetchMyTrades' => true,
          'fetchTransactions' => false,
          'fetchWithdrawals' => true,
          'fetchDeposits' => true,
          'fetchOHLCV' => true,
          'fetchOrder' => 'emulated',
          'fetchOrderBooks' => true,
          'fetchOrders' => 'emulated',
          'fetchOpenOrders' => true,
          'fetchTickers' => true,
          'deposit' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/29484394-7b4ea6e2-84c6-11e7-83e5-1fccf4b2dc81.jpg',
          'api' => {
            'public' => 'https://www.cryptopia.co.nz/api',
            'private' => 'https://www.cryptopia.co.nz/api',
            'web' => 'https://www.cryptopia.co.nz'
          },
          'www' => 'https://www.cryptopia.co.nz',
          'referral' => 'https://www.cryptopia.co.nz/Register?referrer=kroitor',
          'doc' => [
            'https://support.cryptopia.co.nz/csm?id=kb_article&sys_id=a75703dcdbb9130084ed147a3a9619bc',
            'https://support.cryptopia.co.nz/csm?id=kb_article&sys_id=40e9c310dbf9130084ed147a3a9619eb'
          ]
        },
        'timeframes' => {
          '15m' => 15,
          '30m' => 30,
          '1h' => 60,
          '2h' => 120,
          '4h' => 240,
          '12h' => 720,
          '1d' => 1440,
          '1w' => 10080
        },
        'api' => {
          'web' => {
            'get' => [
              'Exchange/GetTradePairChart'
            ]
          },
          'public' => {
            'get' => [
              'GetCurrencies',
              'GetTradePairs',
              'GetMarkets',
              'GetMarkets/{id}',
              'GetMarkets/{hours}',
              'GetMarkets/{id}/{hours}',
              'GetMarket/{id}',
              'GetMarket/{id}/{hours}',
              'GetMarketHistory/{id}',
              'GetMarketHistory/{id}/{hours}',
              'GetMarketOrders/{id}',
              'GetMarketOrders/{id}/{count}',
              'GetMarketOrderGroups/{ids}',
              'GetMarketOrderGroups/{ids}/{count}'
            ]
          },
          'private' => {
            'post' => [
              'CancelTrade',
              'GetBalance',
              'GetDepositAddress',
              'GetOpenOrders',
              'GetTradeHistory',
              'GetTransactions',
              'SubmitTip',
              'SubmitTrade',
              'SubmitTransfer',
              'SubmitWithdraw'
            ]
          }
        },
        'commonCurrencies' => {
          'ACC' => 'AdCoin',
          'BAT' => 'BatCoin',
          'BEAN' => 'BITB', # rebranding, see issue #3380
          'BLZ' => 'BlazeCoin',
          'BTG' => 'Bitgem',
          'CAN' => 'CanYaCoin',
          'CAT' => 'Catcoin',
          'CC' => 'CCX',
          'CMT' => 'Comet',
          'EPC' => 'ExperienceCoin',
          'FCN' => 'Facilecoin',
          'FT' => 'Fabric Token',
          'FUEL' => 'FC2', # FuelCoin != FUEL
          'HAV' => 'Havecoin',
          'HC' => 'Harvest Masternode Coin', # != HyperCash
          'HSR' => 'HC',
          'KARM' => 'KARMA',
          'LBTC' => 'LiteBitcoin',
          'LDC' => 'LADACoin',
          'MARKS' => 'Bitmark',
          'NET' => 'NetCoin',
          'PLC' => 'Polcoin',
          'RED' => 'RedCoin',
          'STC' => 'StopTrumpCoin',
          'QBT' => 'Cubits',
          'WRC' => 'WarCoin'
        },
        'options' => {
          'fetchTickersErrors' => true
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetGetTradePairs
      result = []
      markets = response['Data']
      for i in (0...markets.length)
        market = markets[i]
        numericId = market['Id']
        label = market['Label']
        baseId = market['Symbol']
        quoteId = market['BaseSymbol']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        id = baseId + '_' + quoteId
        precision = {
          'amount' => 8,
          'price' => 8
        }
        lot = market['MinimumTrade']
        priceLimits = {
          'min' => market['MinimumPrice'],
          'max' => market['MaximumPrice']
        }
        amountLimits = {
          'min' => lot,
          'max' => market['MaximumTrade']
        }
        limits = {
          'amount' => amountLimits,
          'price' => priceLimits,
          'cost' => {
            'min' => market['MinimumBaseTrade'],
            'max' => nil
          }
        }
        active = market['Status'] == 'OK'
        result.push({
          'id' => id,
          'symbol' => symbol,
          'numericId' => numericId,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'info' => market,
          'maker' => market['TradeFee'] / 100,
          'taker' => market['TradeFee'] / 100,
          'active' => active,
          'precision' => precision,
          'limits' => limits,
          'label' => label
        })
      end
      self.options['marketsByLabel'] = self.index_by(result, 'label')
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      response = self.publicGetGetMarketOrdersId(self.shallow_extend({
        'id' => self.market_id(symbol)
      }, params))
      orderbook = response['Data']
      return self.parse_order_book(orderbook, nil, 'Buy', 'Sell', 'Price', 'Volume')
    end

    def fetch_ohlcv(symbol, timeframe = '15m', since = nil, limit = nil, params = {})
      dataRange = 0
      if since != nil
        dataRanges = [
          86400,
          172800,
          604800,
          1209600,
          2592000,
          7776000,
          15552000
        ]
        numDataRanges = dataRanges.length
        now = self.seconds
        sinceSeconds = parse_int(since / 1000)
        for i in (1...numDataRanges)
          if (now - sinceSeconds) > dataRanges[i]
            dataRange = i
          end
        end
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'tradePairId' => market['numericId'],
        'dataRange' => dataRange,
        'dataGroup' => self.timeframes[timeframe]
      }
      response = self.webGetExchangeGetTradePairChart(self.shallow_extend(request, params))
      candles = response['Candle']
      volumes = response['Volume']
      for i in (0...candles.length)
        candles[i].push(volumes[i]['basev'])
      end
      return self.parse_ohlcvs(candles, market, timeframe, since, limit)
    end

    def join_market_ids(ids, glue = '-')
      result = ids[0].to_s
      for i in (1...ids.length)
        result += glue + ids[i].to_s
      end
      return result
    end

    def fetch_order_books(symbols = nil, params = {})
      self.load_markets
      if symbols.nil?
        raise(ExchangeError, self.id + ' fetchOrderBooks requires the symbols argument as of May 2018(up to 5 symbols at max)')
      end
      numSymbols = symbols.length
      if numSymbols > 5
        raise(ExchangeError, self.id + ' fetchOrderBooks accepts 5 symbols at max')
      end
      ids = self.join_market_ids(self.market_ids(symbols))
      response = self.publicGetGetMarketOrderGroupsIds(self.shallow_extend({
        'ids' => ids
      }, params))
      orderbooks = response['Data']
      result = {}
      for i in (0...orderbooks.length)
        orderbook = orderbooks[i]
        id = self.safe_string(orderbook, 'Market')
        symbol = id
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        end
        result[symbol] = self.parse_order_book(orderbook, nil, 'Buy', 'Sell', 'Price', 'Volume')
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      open = self.safe_float(ticker, 'Open')
      last = self.safe_float(ticker, 'LastPrice')
      change = last - open
      baseVolume = self.safe_float(ticker, 'Volume')
      quoteVolume = self.safe_float(ticker, 'BaseVolume')
      vwap = nil
      if quoteVolume != nil
        if baseVolume != nil
          if baseVolume > 0
            vwap = quoteVolume / baseVolume
          end
        end
      end
      return {
        'symbol' => symbol,
        'info' => ticker,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'High'),
        'low' => self.safe_float(ticker, 'Low'),
        'bid' => self.safe_float(ticker, 'BidPrice'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'AskPrice'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => open,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => self.safe_float(ticker, 'Change'),
        'average' => self.sum(last, open) / 2,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetGetMarketId(self.shallow_extend({
        'id' => market['id']
      }, params))
      ticker = response['Data']
      return self.parse_ticker(ticker, market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetGetMarkets(params)
      result = {}
      tickers = response['Data']
      for i in (0...tickers.length)
        ticker = tickers[i]
        id = ticker['Label'].gsub('/', '_')
        recognized = (self.markets_by_id.include?(id))
        if !recognized
          if self.options['fetchTickersErrors']
            raise(ExchangeError, self.id + ' fetchTickers returned unrecognized pair id ' + id.to_s)
          end
        else
          market = self.markets_by_id[id]
          symbol = market['symbol']
          result[symbol] = self.parse_ticker(ticker, market)
        end
      end
      return self.filter_by_array(result, 'symbol', symbols)
    end

    def parse_trade(trade, market = nil)
      timestamp = nil
      if trade.include?('Timestamp')
        timestamp = trade['Timestamp'] * 1000
      elsif trade.include?('TimeStamp')
        timestamp = self.parse8601(trade['TimeStamp'])
      end
      price = self.safe_float(trade, 'Price')
      if !price
        price = self.safe_float(trade, 'Rate')
      end
      cost = self.safe_float(trade, 'Total')
      id = self.safe_string(trade, 'TradeId')
      if market.nil?
        marketId = self.safe_string(trade, 'Market')
        marketId = marketId.gsub('/', '_')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      symbol = nil
      fee = nil
      if market != nil
        symbol = market['symbol']
        if trade.include?('Fee')
          fee = {
            'currency' => market['quote'],
            'cost' => trade['Fee']
          }
        end
      end
      return {
        'id' => id,
        'info' => trade,
        'order' => nil,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => 'limit',
        'side' => trade['Type'].downcase,
        'price' => price,
        'cost' => cost,
        'amount' => trade['Amount'],
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      hours = 24 # the default
      if since != nil
        elapsed = self.milliseconds - since
        hour = 1000 * 60 * 60
        hours = parse_int(elapsed / hour.ceil)
      end
      request = {
        'id' => market['id'],
        'hours' => hours
      }
      response = self.publicGetGetMarketHistoryIdHours(self.shallow_extend(request, params))
      trades = response['Data']
      return self.parse_trades(trades, market, since, limit)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchWithdrawals
      #
      #     {
      #         Id => 937355,
      #         Currency => 'BTC',
      #         TxId => '5ba7784576cee48bfb9d1524abf7bdade3de65e0f2f9cdd25f7bef2c506cf296',
      #         Type => 'Withdraw',
      #         Amount => 0.7,
      #         Fee => 0,
      #         Status => 'Complete',
      #         Confirmations => 0,
      #         Timestamp => '2017-10-10T18:39:03.8928376',
      #         Address => '14KyZTusAZZGEmZzxsWf4pee7ThtA2iv2E',
      #     }
      #
      # fetchDeposits
      #     {
      #         Id => 7833741,
      #         Currency => 'BCH',
      #         TxId => '0000000000000000011865af4122fe3b144e2cbeea86142e8ff2fb4107352d43',
      #         Type => 'Deposit',
      #         Amount => 0.0003385,
      #         Fee => 0,
      #         Status => 'Confirmed',
      #         Confirmations => 6,
      #         Timestamp => '2017-08-01T16:19:24',
      #         Address => null
      #     }
      #
      timestamp = self.parse8601(self.safe_string(transaction, 'Timestamp'))
      code = nil
      currencyId = self.safe_string(transaction, 'Currency')
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency.nil?
        code = self.common_currency_code(currencyId)
      end
      if currency != nil
        code = currency['code']
      end
      status = self.safe_string(transaction, 'Status')
      txid = self.safe_string(transaction, 'TxId')
      if status != nil
        status = self.parse_transaction_status(status)
      end
      id = self.safe_string(transaction, 'Id')
      type = self.parse_transaction_type(self.safe_string(transaction, 'Type'))
      amount = self.safe_float(transaction, 'Amount')
      address = self.safe_string(transaction, 'Address')
      feeCost = self.safe_float(transaction, 'Fee')
      return {
        'info' => transaction,
        'id' => id,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => nil,
        'status' => status,
        'type' => type,
        'updated' => nil,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => {
          'currency' => code,
          'cost' => feeCost
        }
      }
    end

    def parse_transaction_status(status)
      statuses = {
        'Confirmed' => 'ok',
        'Complete' => 'ok',
        'Pending' => 'pending'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction_type(type)
      types = {
        'Withdraw' => 'withdrawal',
        'Deposit' => 'deposit'
      }
      return self.safe_string(types, type, type)
    end

    def fetch_transactions_by_type(type, code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {
        'type' => (type == 'deposit') ? 'Deposit' : 'Withdraw'
      }
      response = self.privatePostGetTransactions(self.shallow_extend(request, params))
      return self.parseTransactions(response['Data'], code, since, limit)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions_by_type('withdrawal', code, since, limit, params)
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions_by_type('deposit', code, since, limit, params)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['Market'] = market['id']
      end
      if limit != nil
        request['Count'] = limit # default 100
      end
      response = self.privatePostGetTradeHistory(self.shallow_extend(request, params))
      return self.parse_trades(response['Data'], market, since, limit)
    end

    def fetch_currencies(params = {})
      response = self.publicGetGetCurrencies(params)
      currencies = response['Data']
      result = {}
      for i in (0...currencies.length)
        currency = currencies[i]
        id = currency['Symbol']
        # todo => will need to rethink the fees
        # to add support for multiple withdrawal/deposit methods and
        # differentiated fees for each particular method
        precision = 8 # default precision, todo => fix "magic constants"
        code = self.common_currency_code(id)
        active = (currency['ListingStatus'] == 'Active')
        status = currency['Status'].downcase
        if status != 'ok'
          active = false
        end
        result[code] = {
          'id' => id,
          'code' => code,
          'info' => currency,
          'name' => currency['Name'],
          'active' => active,
          'status' => status,
          'fee' => currency['WithdrawFee'],
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => currency['MinBaseTrade'],
              'max' => nil
            },
            'withdraw' => {
              'min' => currency['MinWithdraw'],
              'max' => currency['MaxWithdraw']
            }
          }
        }
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostGetBalance(params)
      balances = response['Data']
      result = { 'info' => response }
      for i in (0...balances.length)
        balance = balances[i]
        code = balance['Symbol']
        currency = self.common_currency_code(code)
        account = {
          'free' => balance['Available'],
          'used' => 0.0,
          'total' => balance['Total']
        }
        account['used'] = account['total'] - account['free']
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      self.load_markets
      market = self.market(symbol)
      # price = parse_float(price)
      # amount = parse_float(amount)
      request = {
        'Market' => market['id'],
        'Type' => self.capitalize(side),
        # 'Rate' => self.price_to_precision(symbol, price),
        # 'Amount' => self.amount_to_precision(symbol, amount),
        'Rate' => price,
        'Amount' => amount
      }
      response = self.privatePostSubmitTrade(self.shallow_extend(request, params))
      if !response
        raise(ExchangeError, self.id + ' createOrder returned unknown error => ' + self.json(response))
      end
      id = nil
      filled = 0.0
      status = 'open'
      if response.include?('Data')
        if response['Data'].include?('OrderId')
          if response['Data']['OrderId']
            id = response['Data']['OrderId'].to_s
          else
            filled = amount
            status = 'closed'
          end
        end
      end
      order = {
        'id' => id,
        'timestamp' => nil,
        'datetime' => nil,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => price * amount,
        'amount' => amount,
        'remaining' => amount - filled,
        'filled' => filled,
        'fee' => nil,
        # 'trades' => self.parse_trades(order['trades'], market)
      }
      if id
        self.orders[id] = order
      end
      return self.shallow_extend({ 'info' => response }, order)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      response = nil
      begin
        response = self.privatePostCancelTrade(self.shallow_extend({
          'Type' => 'Trade',
          'OrderId' => id
        }, params))
        # We do not know if it is indeed canceled, but cryptopia lacks any
        # reasonable method to get information on executed or canceled order.
        if self.orders.include?(id)
          self.orders[id]['status'] = 'canceled'
        end
      rescue BaseError => e
        if self.last_json_response
          message = self.safe_string(self.last_json_response, 'Error')
          if message
            if message.include?('does not exist')
              raise(OrderNotFound, self.id + ' cancelOrder error => ' + self.last_http_response)
            end
          end
        end
        raise e
      end
      return self.parse_order(response)
    end

    def parse_order(order, market = nil)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      elsif order.include?('Market')
        id = order['Market']
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        else
          if self.options['marketsByLabel'].include?(id)
            market = self.options['marketsByLabel'][id]
            symbol = market['symbol']
          end
        end
      end
      timestamp = self.parse8601(self.safe_string(order, 'TimeStamp'))
      amount = self.safe_float(order, 'Amount')
      remaining = self.safe_float(order, 'Remaining')
      filled = nil
      if amount != nil && remaining != nil
        filled = amount - remaining
      end
      id = self.safe_value(order, 'OrderId')
      if id != nil
        id = id.to_s
      end
      side = self.safe_string(order, 'Type')
      if side != nil
        side = side.downcase
      end
      return {
        'id' => id,
        'info' => self.omit(order, 'status'),
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => self.safe_string(order, 'status'),
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => self.safe_float(order, 'Rate'),
        'cost' => self.safe_float(order, 'Total'),
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'fee' => nil,
        # 'trades' => self.parse_trades(order['trades'], market)
      }
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      request = {
        # 'Market' => market['id'],
        # 'TradePairId' => market['id'], # Cryptopia identifier(not required if 'Market' supplied)
        # 'Count' => 100, # default = 100
      }
      if symbol != nil
        market = self.market(symbol)
        request['Market'] = market['id']
      end
      response = self.privatePostGetOpenOrders(self.shallow_extend(request, params))
      orders = []
      for i in (0...response['Data'].length)
        orders.push(self.shallow_extend(response['Data'][i], { 'status' => 'open' }))
      end
      openOrders = self.parse_orders(orders, market)
      for j in (0...openOrders.length)
        self.orders[openOrders[j]['id']] = openOrders[j]
      end
      openOrdersIndexedById = self.index_by(openOrders, 'id')
      cachedOrderIds = self.orders.keys
      result = []
      for k in (0...cachedOrderIds.length)
        id = cachedOrderIds[k]
        if openOrdersIndexedById.include?(id)
          self.orders[id] = self.shallow_extend(self.orders[id], openOrdersIndexedById[id])
        else
          order = self.orders[id]
          if order['status'] == 'open'
            if (symbol.nil?) || (order['symbol'] == symbol)
              self.orders[id] = self.shallow_extend(order, {
                'status' => 'closed',
                'cost' => order['amount'] * order['price'],
                'filled' => order['amount'],
                'remaining' => 0.0
              })
            end
          end
        end
        order = self.orders[id]
        if (symbol.nil?) || (order['symbol'] == symbol)
          result.push(order)
        end
      end
      return self.filter_by_since_limit(result, since, limit)
    end

    def fetch_order(id, symbol = nil, params = {})
      id = id.to_s
      orders = self.fetch_orders(symbol, nil, nil, params)
      for i in (0...orders.length)
        if orders[i]['id'] == id
          return orders[i]
        end
      end
      raise(OrderNotCached, self.id + ' order ' + id + ' not found in cached .orders, fetchOrder requires .orders(de)serialization implemented for self method to work properly')
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, params)
      result = []
      for i in (0...orders.length)
        if orders[i]['status'] == 'open'
          result.push(orders[i])
        end
      end
      return result
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, params)
      result = []
      for i in (0...orders.length)
        if orders[i]['status'] == 'closed'
          result.push(orders[i])
        end
      end
      return result
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostGetDepositAddress(self.shallow_extend({
        'Currency' => currency['id']
      }, params))
      address = self.safe_string(response['Data'], 'BaseAddress')
      tag = self.safe_string(response['Data'], 'Address')
      if address != nil
        if address.length < 1
          address = nil
        end
      end
      if address.nil?
        address = tag
        tag = nil
      end
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.load_markets
      currency = self.currency(code)
      self.check_address(address)
      request = {
        'Currency' => currency['id'],
        'Amount' => amount,
        'Address' => address, # Address must exist in you AddressBook in security settings
      }
      if tag
        request['PaymentId'] = tag
      end
      response = self.privatePostSubmitWithdraw(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => response['Data']
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce.to_s
        body = self.json(query, { 'convertArraysToObjects' => true })
        hash = self.hash(self.encode(body), 'md5', 'base64')
        secret = Base64.decode64(self.secret)
        uri = self.encode_uri_component(url)
        lowercase = uri.downcase
        hash = self.binary_to_string(hash)
        payload = self.apiKey + method + lowercase + nonce + hash
        signature = self.hmac(self.encode(payload), secret, 'sha256', 'base64')
        auth = 'amx ' + self.apiKey + ':' + self.binary_to_string(signature) + ':' + nonce
        headers = {
          'Content-Type' => 'application/json',
          'Authorization' => auth
        }
      else
        if query
          url += '?' + self.urlencode(query)
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def nonce
      return self.milliseconds
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if response.nil?
        return # fallback to default error handler
      end
      if response.include?('Success')
        success = self.safe_value(response, 'Success')
        if success != nil
          if !success
            error = self.safe_string(response, 'Error')
            feedback = self.id + ' ' + body
            if error.is_a?(String)
              if error.include?('Invalid trade amount')
                raise(InvalidOrder, feedback)
              end
              if error.include?('No matching trades found')
                raise(OrderNotFound, feedback)
              end
              if error.include?('does not exist')
                raise(OrderNotFound, feedback)
              end
              if error.include?('Insufficient Funds')
                raise(InsufficientFunds, feedback)
              end
              if error.include?('Nonce has already been used')
                raise(InvalidNonce, feedback)
              end
            end
            raise(ExchangeError, feedback)
          end
        end
      end
    end
  end
end
