# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Lakebtc < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'lakebtc',
        'name' => 'LakeBTC',
        'countries' => ['US'],
        'version' => 'api_v2',
        'has' => {
          'CORS' => true,
          'createMarketOrder' => false,
          'fetchTickers' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/28074120-72b7c38a-6660-11e7-92d9-d9027502281d.jpg',
          'api' => 'https://api.lakebtc.com',
          'www' => 'https://www.lakebtc.com',
          'doc' => [
            'https://www.lakebtc.com/s/api_v2',
            'https://www.lakebtc.com/s/api'
          ]
        },
        'api' => {
          'public' => {
            'get' => [
              'bcorderbook',
              'bctrades',
              'ticker'
            ]
          },
          'private' => {
            'post' => [
              'buyOrder',
              'cancelOrders',
              'getAccountInfo',
              'getExternalAccounts',
              'getOrders',
              'getTrades',
              'openOrders',
              'sellOrder'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.15 / 100,
            'taker' => 0.2 / 100
          }
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetTicker
      result = []
      keys = markets.keys
      for k in (0...keys.length)
        id = keys[k]
        market = markets[id]
        baseId = id[0...3]
        quoteId = id[3...6]
        base = baseId.upcase
        quote = quoteId.upcase
        symbol = base + '/' + quote
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostGetAccountInfo
      balances = response['balance']
      result = { 'info' => response }
      ids = balances.keys
      for i in (0...ids.length)
        id = ids[i]
        code = id
        if self.currencies_by_id.include?(id)
          currency = self.currencies_by_id[id]
          code = currency['code']
        end
        balance = parse_float(balances[id])
        account = {
          'free' => balance,
          'used' => 0.0,
          'total' => balance
        }
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetBcorderbook(self.shallow_extend({
        'symbol' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'volume'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTicker(params)
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        symbol = ids[i]
        ticker = tickers[symbol]
        market = nil
        if self.markets_by_id.include?(symbol)
          market = self.markets_by_id[symbol]
          symbol = market['symbol']
        end
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      tickers = self.publicGetTicker(params)
      return self.parse_ticker(tickers[market['id']], market)
    end

    def parse_trade(trade, market)
      timestamp = trade['date'] * 1000
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'id' => trade['tid'].to_s,
        'order' => nil,
        'type' => nil,
        'side' => nil,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'amount')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetBctrades(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      method = 'privatePost' + self.capitalize(side) + 'Order'
      market = self.market(symbol)
      order = {
        'params' => [price, amount, market['id']]
      }
      response = self.send_wrapper(method, self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostCancelOrder({
        'params' => [id]
      })
    end

    def nonce
      return self.microseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version
      if api == 'public'
        url += '/' + path
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        queryParams = ''
        if params.include?('params')
          paramsList = params['params']
          queryParams = paramsList.join(',')
        end
        query = self.urlencode({
          'tonce' => nonce,
          'accesskey' => self.apiKey,
          'requestmethod' => method.downcase,
          'id' => nonce,
          'method' => path,
          'params' => queryParams
        })
        body = self.json({
          'method' => path,
          'params' => queryParams,
          'id' => nonce
        })
        signature = self.hmac(self.encode(query), self.encode(self.secret), 'sha1')
        auth = self.encode(self.apiKey + ':' + signature)
        headers = {
          'Json-Rpc-Tonce' => nonce.to_s,
          'Authorization' => 'Basic ' + self.decode(Base64.encode64(auth)),
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('error')
        raise(ExchangeError, self.id + ' ' + self.json(response))
      end
      return response
    end
  end
end
