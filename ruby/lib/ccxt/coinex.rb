# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coinex < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coinex',
        'name' => 'CoinEx',
        'version' => 'v1',
        'countries' => ['CN'],
        'rateLimit' => 1000,
        'has' => {
          'fetchTickers' => true,
          'fetchOHLCV' => true,
          'fetchOrder' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchMyTrades' => true,
          'withdraw' => true,
          'fetchDeposits' => true,
          'fetchWithdrawals' => true
        },
        'timeframes' => {
          '1m' => '1min',
          '3m' => '3min',
          '5m' => '5min',
          '15m' => '15min',
          '30m' => '30min',
          '1h' => '1hour',
          '2h' => '2hour',
          '4h' => '4hour',
          '6h' => '6hour',
          '12h' => '12hour',
          '1d' => '1day',
          '3d' => '3day',
          '1w' => '1week'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/38046312-0b450aac-32c8-11e8-99ab-bc6b136b6cc7.jpg',
          'api' => {
            'public' => 'https://api.coinex.com',
            'private' => 'https://api.coinex.com',
            'web' => 'https://www.coinex.com'
          },
          'www' => 'https://www.coinex.com',
          'doc' => 'https://github.com/coinexcom/coinex_exchange_api/wiki',
          'fees' => 'https://www.coinex.com/fees',
          'referral' => 'https://www.coinex.com/account/signup?refer_code=yw5fz'
        },
        'api' => {
          'web' => {
            'get' => [
              'res/market'
            ]
          },
          'public' => {
            'get' => [
              'market/list',
              'market/ticker',
              'market/ticker/all',
              'market/depth',
              'market/deals',
              'market/kline'
            ]
          },
          'private' => {
            'get' => [
              'balance/coin/withdraw',
              'balance/coin/deposit',
              'balance/info',
              'order',
              'order/pending',
              'order/finished',
              'order/finished/{id}',
              'order/user/deals'
            ],
            'post' => [
              'balance/coin/withdraw',
              'order/limit',
              'order/market'
            ],
            'delete' => [
              'balance/coin/withdraw',
              'order/pending'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.001,
            'taker' => 0.001
          },
          'funding' => {
            'withdraw' => {
              'BCH' => 0.0,
              'BTC' => 0.001,
              'LTC' => 0.001,
              'ETH' => 0.001,
              'ZEC' => 0.0001,
              'DASH' => 0.0001
            }
          }
        },
        'limits' => {
          'amount' => {
            'min' => 0.001,
            'max' => nil
          }
        },
        'precision' => {
          'amount' => 8,
          'price' => 8
        },
        'options' => {
          'createMarketBuyOrderRequiresPrice' => true
        }
      })
    end

    def fetch_markets(params = {})
      response = self.webGetResMarket
      markets = response['data']['market_info']
      result = []
      keys = markets.keys
      for i in (0...keys.length)
        key = keys[i]
        market = markets[key]
        id = market['market']
        quoteId = market['buy_asset_type']
        baseId = market['sell_asset_type']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => market['sell_asset_type_places'],
          'price' => market['buy_asset_type_places']
        }
        numMergeLevels = market['merge'].length
        active = (market['status'] == 'pass')
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'taker' => self.safe_float(market, 'taker_fee_rate'),
          'maker' => self.safe_float(market, 'maker_fee_rate'),
          'info' => market,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => self.safe_float(market, 'least_amount'),
              'max' => nil
            },
            'price' => {
              'min' => parse_float(market['merge'][numMergeLevels - 1]),
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = ticker['date']
      symbol = market['symbol']
      ticker = ticker['ticker']
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float_2(ticker, 'vol', 'volume'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketTicker(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_ticker(response['data'], market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetMarketTickerAll(params)
      data = response['data']
      timestamp = data['date']
      tickers = data['ticker']
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        market = self.markets_by_id[id]
        symbol = market['symbol']
        ticker = {
          'date' => timestamp,
          'ticker' => tickers[id]
        }
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_order_book(symbol, limit = 20, params = {})
      self.load_markets
      if limit.nil?
        limit = 20
      end # default
      request = {
        'market' => self.market_id(symbol),
        'merge' => '0.00000001',
        'limit' => limit.to_s
      }
      response = self.publicGetMarketDepth(self.shallow_extend(request, params))
      return self.parse_order_book(response['data'])
    end

    def parse_trade(trade, market = nil)
      # self method parses both public and private trades
      timestamp = self.safe_integer(trade, 'create_time')
      if timestamp.nil?
        timestamp = self.safe_integer(trade, 'date_ms')
      else
        timestamp = timestamp * 1000
      end
      tradeId = self.safe_string(trade, 'id')
      orderId = self.safe_string(trade, 'order_id')
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      marketId = self.safe_string(trade, 'market')
      market = self.safe_value(self.markets_by_id, marketId, market)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      cost = self.safe_float(trade, 'deal_money')
      if !cost
        cost = parse_float(self.cost_to_precision(symbol, price * amount))
      end
      fee = nil
      feeCost = self.safe_float(trade, 'fee')
      if feeCost != nil
        feeCurrencyId = self.safe_string(trade, 'fee_asset')
        feeCurrency = self.safe_value(self.currencies_by_id, feeCurrencyId)
        feeCurrencyCode = nil
        if feeCurrency != nil
          feeCurrencyCode = feeCurrency['code']
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrencyCode
        }
      end
      takerOrMaker = self.safe_string(trade, 'role')
      side = self.safe_string(trade, 'type')
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => tradeId,
        'order' => orderId,
        'type' => nil,
        'side' => side,
        'takerOrMaker' => takerOrMaker,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketDeals(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_trades(response['data'], market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '5m', since = nil, limit = nil)
      return [
        ohlcv[0] * 1000,
        parse_float(ohlcv[1]),
        parse_float(ohlcv[3]),
        parse_float(ohlcv[4]),
        parse_float(ohlcv[2]),
        parse_float(ohlcv[5])
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '5m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketKline(self.shallow_extend({
        'market' => market['id'],
        'type' => self.timeframes[timeframe]
      }, params))
      return self.parse_ohlcvs(response['data'], market, timeframe, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetBalanceInfo(params)
      #
      #     {
      #       "code" => 0,
      #       "data" => {
      #         "BCH" => {                     # BCH account
      #           "available" => "13.60109",   # Available BCH
      #           "frozen" => "0.00000"        # Frozen BCH
      #         },
      #         "BTC" => {                     # BTC account
      #           "available" => "32590.16",   # Available BTC
      #           "frozen" => "7000.00"        # Frozen BTC
      #         },
      #         "ETH" => {                     # ETH account
      #           "available" => "5.06000",    # Available ETH
      #           "frozen" => "0.00000"        # Frozen ETH
      #         }
      #       },
      #       "message" => "Ok"
      #     }
      #
      result = { 'info' => response }
      balances = response['data']
      currencies = balances.keys
      for i in (0...currencies.length)
        id = currencies[i]
        balance = balances[id]
        currency = self.common_currency_code(id)
        account = {
          'free' => parse_float(balance['available']),
          'used' => parse_float(balance['frozen']),
          'total' => 0.0
        }
        account['total'] = self.sum(account['free'], account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def parse_order_status(status)
      statuses = {
        'not_deal' => 'open',
        'part_deal' => 'open',
        'done' => 'closed',
        'cancel' => 'canceled'
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      #
      # fetchOrder
      #
      #     {
      #         "amount" => "0.1",
      #         "asset_fee" => "0.22736197736197736197",
      #         "avg_price" => "196.85000000000000000000",
      #         "create_time" => 1537270135,
      #         "deal_amount" => "0.1",
      #         "deal_fee" => "0",
      #         "deal_money" => "19.685",
      #         "fee_asset" => "CET",
      #         "fee_discount" => "0.5",
      #         "id" => 1788259447,
      #         "left" => "0",
      #         "maker_fee_rate" => "0",
      #         "market" => "ETHUSDT",
      #         "order_type" => "limit",
      #         "price" => "170.00000000",
      #         "status" => "done",
      #         "taker_fee_rate" => "0.0005",
      #         "type" => "sell",
      #     }
      #
      timestamp = self.safe_integer(order, 'create_time') * 1000
      price = self.safe_float(order, 'price')
      cost = self.safe_float(order, 'deal_money')
      amount = self.safe_float(order, 'amount')
      filled = self.safe_float(order, 'deal_amount')
      average = self.safe_float(order, 'avg_price')
      symbol = nil
      marketId = self.safe_string(order, 'market')
      market = self.safe_value(self.markets_by_id, marketId)
      feeCurrency = nil
      feeCurrencyId = self.safe_string(order, 'fee_asset')
      currency = self.safe_value(self.currencies_by_id, feeCurrencyId)
      if currency != nil
        feeCurrency = currency['code']
      end
      if market != nil
        symbol = market['symbol']
        if feeCurrency.nil?
          feeCurrency = market['quote']
        end
      end
      remaining = self.safe_float(order, 'left')
      status = self.parse_order_status(self.safe_string(order, 'status'))
      type = self.safe_string(order, 'order_type')
      side = self.safe_string(order, 'type')
      return {
        'id' => self.safe_string(order, 'id'),
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => average,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => {
          'currency' => feeCurrency,
          'cost' => self.safe_float(order, 'deal_fee')
        },
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      amount = parse_float(amount) # self line is deprecated
      if type == 'market'
        # for market buy it requires the amount of quote currency to spend
        if side == 'buy'
          if self.options['createMarketBuyOrderRequiresPrice']
            if price.nil?
              raise(InvalidOrder, self.id + " createOrder requires the price argument with market buy orders to calculate total order cost(amount to spend), where cost = amount * price. Supply a price argument to createOrder call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument(the exchange-specific behaviour)")
            else
              price = parse_float(price) # self line is deprecated
              amount = amount * price
            end
          end
        end
      end
      self.load_markets
      method = 'privatePostOrder' + self.capitalize(type)
      market = self.market(symbol)
      request = {
        'market' => market['id'],
        'amount' => self.amount_to_precision(symbol, amount),
        'type' => side
      }
      if type == 'limit'
        price = parse_float(price) # self line is deprecated
        request['price'] = self.price_to_precision(symbol, price)
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      order = self.parse_order(response['data'], market)
      id = order['id']
      self.orders[id] = order
      return order
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privateDeleteOrderPending(self.shallow_extend({
        'id' => id,
        'market' => market['id']
      }, params))
      return self.parse_order(response['data'], market)
    end

    def fetch_order(id, symbol = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      response = self.privateGetOrder(self.shallow_extend({
        'id' => id,
        'market' => market['id']
      }, params))
      #
      #     {
      #         "code" => 0,
      #         "data" => {
      #             "amount" => "0.1",
      #             "asset_fee" => "0.22736197736197736197",
      #             "avg_price" => "196.85000000000000000000",
      #             "create_time" => 1537270135,
      #             "deal_amount" => "0.1",
      #             "deal_fee" => "0",
      #             "deal_money" => "19.685",
      #             "fee_asset" => "CET",
      #             "fee_discount" => "0.5",
      #             "id" => 1788259447,
      #             "left" => "0",
      #             "maker_fee_rate" => "0",
      #             "market" => "ETHUSDT",
      #             "order_type" => "limit",
      #             "price" => "170.00000000",
      #             "status" => "done",
      #             "taker_fee_rate" => "0.0005",
      #             "type" => "sell",
      #         },
      #         "message" => "Ok"
      #     }
      #
      return self.parse_order(response['data'], market)
    end

    def fetch_orders_by_status(status, symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if limit.nil?
        limit = 100
      end
      request = {
        'page' => 1,
        'limit' => limit
      }
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['market'] = market['id']
      end
      method = 'privateGetOrder' + self.capitalize(status)
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      return self.parse_orders(response['data']['data'], market, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_status('pending', symbol, since, limit, params)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_status('finished', symbol, since, limit, params)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if limit.nil?
        limit = 100
      end
      request = {
        'page' => 1,
        'limit' => limit
      }
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['market'] = market['id']
      end
      response = self.privateGetOrderUserDeals(self.shallow_extend(request, params))
      return self.parse_trades(response['data']['data'], market, since, limit)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      if tag
        address = address + ':' + tag
      end
      request = {
        'coin_type' => currency['id'],
        'coin_address' => address,
        'actual_amount' => parse_float(amount)
      }
      response = self.privatePostBalanceCoinWithdraw(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => self.safe_string(response, 'coin_withdraw_id')
      }
    end

    def parse_transaction_status(status)
      statuses = {
        'audit' => 'pending',
        'pass' => 'pending',
        'processing' => 'pending',
        'confirming' => 'pending',
        'not_pass' => 'failed',
        'cancel' => 'canceled',
        'finish' => 'ok',
        'fail' => 'failed'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchDeposits
      #
      #     {
      #         "actual_amount" => "120.00000000",
      #         "actual_amount_display" => "120",
      #         "add_explorer" => "XXX",
      #         "amount" => "120.00000000",
      #         "amount_display" => "120",
      #         "coin_address" => "XXXXXXXX",
      #         "coin_address_display" => "XXXXXXXX",
      #         "coin_deposit_id" => 1866,
      #         "coin_type" => "USDT",
      #         "confirmations" => 0,
      #         "create_time" => 1539595701,
      #         "explorer" => "",
      #         "remark" => "",
      #         "status" => "finish",
      #         "status_display" => "finish",
      #         "transfer_method" => "local",
      #         "tx_id" => "",
      #         "tx_id_display" => "XXXXXXXXXX"
      #     }
      #
      # fetchWithdrawals
      #
      #     {
      #         "actual_amount" => "0.10000000",
      #         "amount" => "0.10000000",
      #         "coin_address" => "15sr1VdyXQ6sVLqeJUJ1uPzLpmQtgUeBSB",
      #         "coin_type" => "BCH",
      #         "coin_withdraw_id" => 203,
      #         "confirmations" => 11,
      #         "create_time" => 1515806440,
      #         "status" => "finish",
      #         "tx_fee" => "0",
      #         "tx_id" => "896371d0e23d64d1cac65a0b7c9e9093d835affb572fec89dd4547277fbdd2f6"
      #     }
      #
      id = self.safe_string_2(transaction, 'coin_withdraw_id', 'coin_deposit_id')
      address = self.safe_string(transaction, 'coin_address')
      tag = self.safe_string(transaction, 'remark') # set but unused
      if tag != nil
        if tag.length < 1
          tag = nil
        end
      end
      txid = self.safe_value(transaction, 'tx_id')
      if txid != nil
        if txid.length < 1
          txid = nil
        end
      end
      code = nil
      currencyId = self.safe_string(transaction, 'coin_type')
      if self.currencies_by_id.include?(currencyId)
        currency = self.currencies_by_id[currencyId]
      else
        code = self.common_currency_code(currencyId)
      end
      if currency != nil
        code = currency['code']
      end
      timestamp = self.safe_integer(transaction, 'create_time')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      type = (transaction.include?('coin_withdraw_id')) ? 'withdraw' : 'deposit'
      status = self.parse_transaction_status(self.safe_string(transaction, 'status'), type)
      amount = self.safe_float(transaction, 'amount')
      feeCost = self.safe_float(transaction, 'tx_fee')
      if type == 'deposit'
        feeCost = 0
      end
      fee = {
        'cost' => feeCost,
        'currency' => code
      }
      return {
        'info' => transaction,
        'id' => id,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => address,
        'tag' => tag,
        'type' => type,
        'amount' => amount,
        'currency' => code,
        'status' => status,
        'updated' => nil,
        'fee' => fee
      }
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      if code.nil?
        raise(ArgumentsRequired, self.id + ' fetchWithdrawals requires a currency code argument')
      end
      currency = self.currency(code)
      request = {
        'coin_type' => currency['id']
      }
      if limit != nil
        request['Limit'] = limit
      end
      response = self.privateGetBalanceCoinWithdraw(self.shallow_extend(request, params))
      #
      #     {
      #         "code" => 0,
      #         "data" => [
      #             {
      #                 "actual_amount" => "1.00000000",
      #                 "amount" => "1.00000000",
      #                 "coin_address" => "1KAv3pazbTk2JnQ5xTo6fpKK7p1it2RzD4",
      #                 "coin_type" => "BCH",
      #                 "coin_withdraw_id" => 206,
      #                 "confirmations" => 0,
      #                 "create_time" => 1524228297,
      #                 "status" => "audit",
      #                 "tx_fee" => "0",
      #                 "tx_id" => ""
      #             },
      #             {
      #                 "actual_amount" => "0.10000000",
      #                 "amount" => "0.10000000",
      #                 "coin_address" => "15sr1VdyXQ6sVLqeJUJ1uPzLpmQtgUeBSB",
      #                 "coin_type" => "BCH",
      #                 "coin_withdraw_id" => 203,
      #                 "confirmations" => 11,
      #                 "create_time" => 1515806440,
      #                 "status" => "finish",
      #                 "tx_fee" => "0",
      #                 "tx_id" => "896371d0e23d64d1cac65a0b7c9e9093d835affb572fec89dd4547277fbdd2f6"
      #             },
      #             {
      #                 "actual_amount" => "0.00100000",
      #                 "amount" => "0.00100000",
      #                 "coin_address" => "1GVVx5UBddLKrckTprNi4VhHSymeQ8tsLF",
      #                 "coin_type" => "BCH",
      #                 "coin_withdraw_id" => 27,
      #                 "confirmations" => 0,
      #                 "create_time" => 1513933541,
      #                 "status" => "cancel",
      #                 "tx_fee" => "0",
      #                 "tx_id" => ""
      #             }
      #         ],
      #         "message" => "Ok"
      #     }
      #
      return self.parseTransactions(response['data'], currency, since, limit)
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      if code.nil?
        raise(ArgumentsRequired, self.id + ' fetchDeposits requires a currency code argument')
      end
      currency = self.currency(code)
      request = {
        'coin_type' => currency['id']
      }
      if limit != nil
        request['Limit'] = limit
      end
      response = self.privateGetBalanceCoinDeposit(self.shallow_extend(request, params))
      #     {
      #         "code" => 0,
      #         "data" => [
      #             {
      #                 "actual_amount" => "4.65397682",
      #                 "actual_amount_display" => "4.65397682",
      #                 "add_explorer" => "https://etherscan.io/address/0x361XXXXXX",
      #                 "amount" => "4.65397682",
      #                 "amount_display" => "4.65397682",
      #                 "coin_address" => "0x36dabcdXXXXXX",
      #                 "coin_address_display" => "0x361X*****XXXXX",
      #                 "coin_deposit_id" => 966191,
      #                 "coin_type" => "ETH",
      #                 "confirmations" => 30,
      #                 "create_time" => 1531661445,
      #                 "explorer" => "https://etherscan.io/tx/0x361XXXXXX",
      #                 "remark" => "",
      #                 "status" => "finish",
      #                 "status_display" => "finish",
      #                 "transfer_method" => "onchain",
      #                 "tx_id" => "0x361XXXXXX",
      #                 "tx_id_display" => "0x361XXXXXX"
      #             }
      #         ],
      #         "message" => "Ok"
      #     }
      #
      return self.parseTransactions(response['data'], currency, since, limit)
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      path = self.implode_params(path, params)
      url = self.urls['api'][api] + '/' + self.version + '/' + path
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      elsif api == 'web'
        url = self.urls['api'][api] + '/' + path
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        query = self.shallow_extend({
          'access_id' => self.apiKey,
          'tonce' => nonce.to_s
        }, query)
        query = self.keysort(query)
        urlencoded = self.urlencode(query)
        signature = self.hash(self.encode(urlencoded + '&secret_key=' + self.secret))
        headers = {
          'Authorization' => signature.upcase,
          'Content-Type' => 'application/json'
        }
        if (method == 'GET') || (method == 'DELETE')
          url += '?' + urlencoded
        else
          body = self.json(query)
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      code = self.safe_string(response, 'code')
      data = self.safe_value(response, 'data')
      if code != '0' || !data
        responseCodes = {
          '24' => AuthenticationError,
          '25' => AuthenticationError,
          '107' => InsufficientFunds,
          '600' => OrderNotFound,
          '601' => InvalidOrder,
          '602' => InvalidOrder,
          '606' => InvalidOrder
        }
        errorClass = self.safe_value(responseCodes, code, ExchangeError)
        raise(errorClass, response['message'])
      end
      return response
    end
  end
end
