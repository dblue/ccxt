# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coinfloor < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coinfloor',
        'name' => 'coinfloor',
        'rateLimit' => 1000,
        'countries' => ['UK'],
        'has' => {
          'CORS' => false,
          'fetchOpenOrders' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/28246081-623fc164-6a1c-11e7-913f-bac0d5576c90.jpg',
          'api' => 'https://webapi.coinfloor.co.uk/bist',
          'www' => 'https://www.coinfloor.co.uk',
          'doc' => [
            'https://github.com/coinfloor/api',
            'https://www.coinfloor.co.uk/api'
          ]
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => false,
          'password' => true,
          'uid' => true
        },
        'api' => {
          'public' => {
            'get' => [
              '{id}/ticker/',
              '{id}/order_book/',
              '{id}/transactions/'
            ]
          },
          'private' => {
            'post' => [
              '{id}/balance/',
              '{id}/user_transactions/',
              '{id}/open_orders/',
              '{id}/cancel_order/',
              '{id}/buy/',
              '{id}/sell/',
              '{id}/buy_market/',
              '{id}/sell_market/',
              '{id}/estimate_sell_market/',
              '{id}/estimate_buy_market/'
            ]
          }
        },
        'markets' => {
          'BTC/GBP' => { 'id' => 'XBT/GBP', 'symbol' => 'BTC/GBP', 'base' => 'BTC', 'quote' => 'GBP', 'baseId' => 'XBT', 'quoteId' => 'GBP' },
          'BTC/EUR' => { 'id' => 'XBT/EUR', 'symbol' => 'BTC/EUR', 'base' => 'BTC', 'quote' => 'EUR', 'baseId' => 'XBT', 'quoteId' => 'EUR' },
          'BTC/USD' => { 'id' => 'XBT/USD', 'symbol' => 'BTC/USD', 'base' => 'BTC', 'quote' => 'USD', 'baseId' => 'XBT', 'quoteId' => 'USD' },
          'BCH/GBP' => { 'id' => 'BCH/GBP', 'symbol' => 'BCH/GBP', 'base' => 'BCH', 'quote' => 'GBP', 'baseId' => 'BCH', 'quoteId' => 'GBP' },
          'ETH/GBP' => { 'id' => 'ETH/GBP', 'symbol' => 'ETH/GBP', 'base' => 'ETH', 'quote' => 'GBP', 'baseId' => 'ETH', 'quoteId' => 'GBP' }
        }
      })
    end

    def fetch_balance(params = {})
      market = nil
      if params.include?('symbol')
        market = self.find_market(params['symbol'])
      end
      if params.include?('id')
        market = self.find_market(params['id'])
      end
      if !market
        raise(NotSupported, self.id + ' fetchBalance requires a symbol param')
      end
      response = self.privatePostIdBalance({
        'id' => market['id']
      })
      result = {
        'info' => response
      }
      # base/quote used for keys e.g. "xbt_reserved"
      keys = market['id'].downcase.split('/')
      result[market['base']] = {
        'free' => parse_float(response[keys[0] + '_available']),
        'used' => parse_float(response[keys[0] + '_reserved']),
        'total' => parse_float(response[keys[0] + '_balance'])
      }
      result[market['quote']] = {
        'free' => parse_float(response[keys[1] + '_available']),
        'used' => parse_float(response[keys[1] + '_reserved']),
        'total' => parse_float(response[keys[1] + '_balance'])
      }
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      orderbook = self.publicGetIdOrderBook(self.shallow_extend({
        'id' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook)
    end

    def parse_ticker(ticker, market = nil)
      # rewrite to get the timestamp from HTTP headers
      timestamp = self.milliseconds
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      vwap = self.safe_float(ticker, 'vwap')
      baseVolume = self.safe_float(ticker, 'volume')
      quoteVolume = nil
      if vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      market = self.market(symbol)
      ticker = self.publicGetIdTicker(self.shallow_extend({
        'id' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      timestamp = trade['date'] * 1000
      return {
        'info' => trade,
        'id' => trade['tid'].to_s,
        'order' => nil,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => nil,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'amount')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetIdTransactions(self.shallow_extend({
        'id' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      order = { 'id' => self.market_id(symbol) }
      method = 'privatePostId' + self.capitalize(side)
      if type == 'market'
        order['quantity'] = amount
        method += 'Market'
      else
        order['price'] = price
        order['amount'] = amount
      end
      return self.send_wrapper(method, self.shallow_extend(order, params))
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostIdCancelOrder({ 'id' => id })
    end

    def parse_order(order, market = nil)
      timestamp = self.parse8601(order['datetime'])
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'amount')
      cost = price * amount
      side = nil
      status = self.safe_string(order, 'status')
      if order['type'] == 0
        side = 'buy'
      elsif order['type'] == 1
        side = 'sell'
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      id = order['id'].to_s
      return {
        'info' => order,
        'id' => id,
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'amount' => amount,
        'filled' => nil,
        'remaining' => nil,
        'cost' => cost,
        'fee' => nil
      }
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(NotSupported, self.id + ' fetchOpenOrders requires a symbol param')
      end
      self.load_markets
      market = self.market(symbol)
      orders = self.privatePostIdOpenOrders({
        'id' => market['id']
      })
      for i in (0...orders.length)
        # Coinfloor open orders would always be limit orders
        orders[i] = self.shallow_extend(orders[i], { 'status' => 'open' })
      end
      return self.parse_orders(orders, market, since, limit)
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      # curl -k -u '[User ID]/[API key]:[Passphrase]' https://webapi.coinfloor.co.uk:8090/bist/XBT/GBP/balance/
      url = self.urls['api'] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({ 'nonce' => nonce }, query))
        auth = self.uid + '/' + self.apiKey + ':' + self.password
        signature = self.decode(Base64.encode64(self.encode(auth)))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Authorization' => 'Basic ' + signature
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
