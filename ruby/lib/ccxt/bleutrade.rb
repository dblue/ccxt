# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

require_relative 'bittrex'

module Ccxt
  class Bleutrade < Bittrex
    def describe
      return self.deep_extend(super, {
        'id' => 'bleutrade',
        'name' => 'Bleutrade',
        'countries' => ['BR'], # Brazil
        'rateLimit' => 1000,
        'version' => 'v2',
        'certified' => false,
        'has' => {
          'CORS' => true,
          'fetchTickers' => true,
          'fetchOrders' => true,
          'fetchClosedOrders' => true,
          'fetchOrderTrades' => true
        },
        'timeframes' => {
          '15m' => '15m',
          '20m' => '20m',
          '30m' => '30m',
          '1h' => '1h',
          '2h' => '2h',
          '3h' => '3h',
          '4h' => '4h',
          '6h' => '6h',
          '8h' => '8h',
          '12h' => '12h',
          '1d' => '1d'
        },
        'hostname' => 'bleutrade.com',
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/30303000-b602dbe6-976d-11e7-956d-36c5049c01e7.jpg',
          'api' => {
            'public' => 'https://{hostname}/api',
            'account' => 'https://{hostname}/api',
            'market' => 'https://{hostname}/api'
          },
          'www' => 'https://bleutrade.com',
          'doc' => 'https://bleutrade.com/help/API',
          'fees' => 'https://bleutrade.com/help/fees_and_deadlines'
        },
        'api' => {
          'account' => {
            'get' => [
              'balance',
              'balances',
              'depositaddress',
              'deposithistory',
              'order',
              'orders',
              'orderhistory',
              'withdrawhistory',
              'withdraw'
            ]
          },
          'public' => {
            'get' => [
              'candles',
              'currencies',
              'markethistory',
              'markets',
              'marketsummaries',
              'marketsummary',
              'orderbook',
              'ticker'
            ]
          }
        },
        'fees' => {
          'funding' => {
            'withdraw' => {
              'ADC' => 0.1,
              'BTA' => 0.1,
              'BITB' => 0.1,
              'BTC' => 0.001,
              'BCC' => 0.001,
              'BTCD' => 0.001,
              'BTG' => 0.001,
              'BLK' => 0.1,
              'CDN' => 0.1,
              'CLAM' => 0.01,
              'DASH' => 0.001,
              'DCR' => 0.05,
              'DGC' => 0.1,
              'DP' => 0.1,
              'DPC' => 0.1,
              'DOGE' => 10.0,
              'EFL' => 0.1,
              'ETH' => 0.01,
              'EXP' => 0.1,
              'FJC' => 0.1,
              'BSTY' => 0.001,
              'GB' => 0.1,
              'NLG' => 0.1,
              'HTML' => 1.0,
              'LTC' => 0.001,
              'MONA' => 0.01,
              'MOON' => 1.0,
              'NMC' => 0.015,
              'NEOS' => 0.1,
              'NVC' => 0.05,
              'OK' => 0.1,
              'PPC' => 0.1,
              'POT' => 0.1,
              'XPM' => 0.001,
              'QTUM' => 0.1,
              'RDD' => 0.1,
              'SLR' => 0.1,
              'START' => 0.1,
              'SLG' => 0.1,
              'TROLL' => 0.1,
              'UNO' => 0.01,
              'VRC' => 0.1,
              'VTC' => 0.1,
              'XVP' => 0.1,
              'WDC' => 0.001,
              'ZET' => 0.1
            }
          }
        },
        'commonCurrencies' => {
          'EPC' => 'Epacoin'
        },
        'exceptions' => {
          'Insufficient funds!' => InsufficientFunds,
          'Invalid Order ID' => InvalidOrder,
          'Invalid apikey or apisecret' => AuthenticationError
        },
        'options' => {
          'parseOrderStatus' => true,
          'disableNonce' => false,
          'symbolSeparator' => '_'
        }
      })
    end

    def parse_order_status(status)
      statuses = {
        'OK' => 'closed',
        'OPEN' => 'open',
        'CANCELED' => 'canceled'
      }
      if statuses.include?(status)
        return statuses[status]
      else
        return status
      end
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      # Possible params
      # orderstatus(ALL, OK, OPEN, CANCELED)
      # ordertype(ALL, BUY, SELL)
      # depth(optional, default is 500, max is 20000)
      self.load_markets
      market = nil
      if symbol != nil
        self.load_markets
        market = self.market(symbol)
      else
        market = nil
      end
      response = self.accountGetOrders(self.shallow_extend({ 'market' => 'ALL', 'orderstatus' => 'ALL' }, params))
      return self.parse_orders(response['result'], market, since, limit)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      response = self.fetch_orders(symbol, since, limit, params)
      return self.filter_by(response, 'status', 'closed')
    end

    def get_order_id_field
      return 'orderid'
    end

    def parse_symbol(id)
      base, quote = id.split(self.options['symbolSeparator'])
      base = self.common_currency_code(base)
      quote = self.common_currency_code(quote)
      return base + '/' + quote
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'market' => self.market_id(symbol),
        'type' => 'ALL'
      }
      if limit != nil
        request['depth'] = limit
      end # 50
      response = self.publicGetOrderbook(self.shallow_extend(request, params))
      orderbook = self.safe_value(response, 'result')
      if !orderbook
        raise(ExchangeError, self.id + ' publicGetOrderbook returneded no result ' + self.json(response))
      end
      return self.parse_order_book(orderbook, nil, 'buy', 'sell', 'Rate', 'Quantity')
    end

    def fetch_order_trades(id, symbol = nil, since = nil, limit = nil, params = {})
      # Currently we can't set the makerOrTaker field, but if the user knows the order side then it can be
      # determined(if the side of the trade is different to the side of the order, then the trade is maker).
      # Similarly, the correct 'side' for the trade is that of the order.
      # The trade fee can be set by the user, it is always 0.25% and is taken in the quote currency.
      self.load_markets
      response = self.accountGetOrderhistory({ 'orderid' => id })
      trades = self.parse_trades(response['result'], nil, since, limit)
      result = []
      for i in (0...trades.length)
        trade = self.shallow_extend(trades[i], {
          'order' => id
        })
        result.push(trade)
      end
      return result
    end

    def fetch_transactions_by_type(type, code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      method = (type == 'deposit') ? 'accountGetDeposithistory' : 'accountGetWithdrawhistory'
      response = self.send_wrapper(method, params)
      result = self.parseTransactions(response['result'])
      return self.filterByCurrencySinceLimit(result, code, since, limit)
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions_by_type('deposit', code, since, limit, params)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions_by_type('withdrawal', code, since, limit, params)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1d', since = nil, limit = nil)
      timestamp = self.parse8601(ohlcv['TimeStamp'] + '+00:00')
      return [
        timestamp,
        ohlcv['Open'],
        ohlcv['High'],
        ohlcv['Low'],
        ohlcv['Close'],
        ohlcv['Volume']
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '15m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'period' => self.timeframes[timeframe],
        'market' => market['id'],
        'count' => limit
      }
      response = self.publicGetCandles(self.shallow_extend(request, params))
      if response.include?('result')
        if response['result']
          return self.parse_ohlcvs(response['result'], market, timeframe, since, limit)
        end
      end
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(trade['TimeStamp'] + '+00:00')
      side = nil
      if trade['OrderType'] == 'BUY'
        side = 'buy'
      elsif trade['OrderType'] == 'SELL'
        side = 'sell'
      end
      id = self.safe_string(trade, 'TradeID')
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      cost = nil
      price = self.safe_float(trade, 'Price')
      amount = self.safe_float(trade, 'Quantity')
      if amount != nil
        if price != nil
          cost = price * amount
        end
      end
      return {
        'id' => id,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil
      }
    end

    def parse_order(order, market = nil)
      side = self.safe_string_2(order, 'OrderType', 'Type')
      isBuyOrder = (side == 'LIMIT_BUY') || (side == 'BUY')
      isSellOrder = (side == 'LIMIT_SELL') || (side == 'SELL')
      if isBuyOrder
        side = 'buy'
      end
      if isSellOrder
        side = 'sell'
      end
      # We parse different fields in a very specific order.
      # Order might well be closed and then canceled.
      status = nil
      if order.include?(('Opened')) && order['Opened']
        status = 'open'
      end
      if order.include?(('Closed')) && order['Closed']
        status = 'closed'
      end
      if order.include?(('CancelInitiated')) && order['CancelInitiated']
        status = 'canceled'
      end
      if order.include?(('Status')) && self.options['parseOrderStatus']
        status = self.parse_order_status(self.safe_string(order, 'Status'))
      end
      symbol = nil
      if order.include?('Exchange')
        marketId = order['Exchange']
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
          symbol = market['symbol']
        else
          symbol = self.parse_symbol(marketId)
        end
      else
        if market != nil
          symbol = market['symbol']
        end
      end
      timestamp = nil
      if order.include?('Opened')
        timestamp = self.parse8601(order['Opened'] + '+00:00')
      end
      if order.include?('Created')
        timestamp = self.parse8601(order['Created'] + '+00:00')
      end
      lastTradeTimestamp = nil
      if order.include?(('TimeStamp')) && (order['TimeStamp'] != nil)
        lastTradeTimestamp = self.parse8601(order['TimeStamp'] + '+00:00')
      end
      if order.include?(('Closed')) && (order['Closed'] != nil)
        lastTradeTimestamp = self.parse8601(order['Closed'] + '+00:00')
      end
      if timestamp.nil?
        timestamp = lastTradeTimestamp
      end
      fee = nil
      commission = nil
      if order.include?('Commission')
        commission = 'Commission'
      elsif order.include?('CommissionPaid')
        commission = 'CommissionPaid'
      end
      if commission
        fee = {
          'cost' => self.safe_float(order, commission)
        }
        if market != nil
          fee['currency'] = market['quote']
        elsif symbol != nil
          currencyIds = symbol.split('/')
          quoteCurrencyId = currencyIds[1]
          if self.currencies_by_id.include?(quoteCurrencyId)
            fee['currency'] = self.currencies_by_id[quoteCurrencyId]['code']
          else
            fee['currency'] = self.common_currency_code(quoteCurrencyId)
          end
        end
      end
      price = self.safe_float(order, 'Price')
      cost = nil
      amount = self.safe_float(order, 'Quantity')
      remaining = self.safe_float(order, 'QuantityRemaining')
      filled = nil
      if amount != nil && remaining != nil
        filled = amount - remaining
      end
      if !cost
        if price && filled
          cost = price * filled
        end
      end
      if !price
        if cost && filled
          price = cost / filled
        end
      end
      average = self.safe_float(order, 'PricePerUnit')
      id = self.safe_string_2(order, 'OrderUuid', 'OrderId')
      return {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => average,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee
      }
    end

    def parse_transaction(transaction, currency = nil)
      #
      #  deposit:
      #
      #     {
      #         Id => '96974373',
      #         Coin => 'DOGE',
      #         Amount => '12.05752192',
      #         TimeStamp => '2017-09-29 08:10:09',
      #         Label => 'DQqSjjhzCm3ozT4vAevMUHgv4vsi9LBkoE',
      #     }
      #
      # withdrawal:
      #
      #     {
      #         Id => '98009125',
      #         Coin => 'DOGE',
      #         Amount => '-483858.64312050',
      #         TimeStamp => '2017-11-22 22:29:05',
      #         Label => '483848.64312050DJVJZ58tJC8UeUv9Tqcdtn6uhWobouxFLT10.00000000',
      #         TransactionId => '8563105276cf798385fee7e5a563c620fea639ab132b089ea880d4d1f4309432',
      #     }
      #
      #     {
      #         "Id" => "95820181",
      #         "Coin" => "BTC",
      #         "Amount" => "-0.71300000",
      #         "TimeStamp" => "2017-07-19 17:14:24",
      #         "Label" => "0.71200000PER9VM2txt4BTdfyWgvv3GziECRdVEPN630.00100000",
      #         "TransactionId" => "CANCELED"
      #     }
      #
      id = self.safe_string(transaction, 'Id')
      amount = self.safe_float(transaction, 'Amount')
      type = 'deposit'
      if amount < 0
        amount = amount.abs
        type = 'withdrawal'
      end
      currencyId = self.safe_string(transaction, 'Coin')
      code = nil
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency != nil
        code = currency['code']
      else
        code = self.common_currency_code(currencyId)
      end
      label = self.safe_string(transaction, 'Label')
      timestamp = self.parse8601(self.safe_string(transaction, 'TimeStamp'))
      txid = self.safe_string(transaction, 'TransactionId')
      address = nil
      feeCost = nil
      labelParts = label.split('')
      if labelParts.length == 3
        amount = labelParts[0]
        address = labelParts[1]
        feeCost = labelParts[2]
      else
        address = label
      end
      fee = nil
      if feeCost != nil
        fee = {
          'currency' => code,
          'cost' => feeCost
        }
      end
      status = 'ok'
      if txid == 'CANCELED'
        txid = nil
        status = 'canceled'
      end
      return {
        'info' => transaction,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'id' => id,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => nil,
        'status' => status,
        'type' => type,
        'updated' => nil,
        'txid' => txid,
        'fee' => fee
      }
    end
  end
end
