# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Southxchange < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'southxchange',
        'name' => 'SouthXchange',
        'countries' => ['AR'], # Argentina
        'rateLimit' => 1000,
        'has' => {
          'CORS' => true,
          'createDepositAddress' => true,
          'fetchOpenOrders' => true,
          'fetchTickers' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27838912-4f94ec8a-60f6-11e7-9e5d-bbf9bd50a559.jpg',
          'api' => 'https://www.southxchange.com/api',
          'www' => 'https://www.southxchange.com',
          'doc' => 'https://www.southxchange.com/Home/Api'
        },
        'api' => {
          'public' => {
            'get' => [
              'markets',
              'price/{symbol}',
              'prices',
              'book/{symbol}',
              'trades/{symbol}'
            ]
          },
          'private' => {
            'post' => [
              'cancelMarketOrders',
              'cancelOrder',
              'generatenewaddress',
              'listOrders',
              'listBalances',
              'placeOrder',
              'withdraw'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.2 / 100,
            'taker' => 0.2 / 100
          }
        },
        'commonCurrencies' => {
          'SMT' => 'SmartNode',
          'MTC' => 'Marinecoin'
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetMarkets
      result = []
      for p in (0...markets.length)
        market = markets[p]
        baseId = market[0]
        quoteId = market[1]
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        id = symbol
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => nil,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privatePostListBalances
      if !balances
        raise(ExchangeError, self.id + ' fetchBalance got an unrecognized response')
      end
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currencyId = balance['Currency']
        uppercase = currencyId.upcase
        currency = self.currencies_by_id[uppercase]
        code = currency['code']
        free = parse_float(balance['Available'])
        deposited = parse_float(balance['Deposited'])
        unconfirmed = parse_float(balance['Unconfirmed'])
        total = self.sum(deposited, unconfirmed)
        used = total - free
        account = {
          'free' => free,
          'used' => used,
          'total' => total
        }
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetBookSymbol(self.shallow_extend({
        'symbol' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook, nil, 'BuyOrders', 'SellOrders', 'Price', 'Amount')
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'Last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => self.safe_float(ticker, 'Bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'Ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => self.safe_float(ticker, 'Variation24Hr'),
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'Volume24Hr'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetPrices(params)
      tickers = self.index_by(response, 'Market')
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        symbol = id
        market = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        end
        ticker = tickers[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetPriceSymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      timestamp = trade['At'] * 1000
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'id' => nil,
        'order' => nil,
        'type' => nil,
        'side' => trade['Type'],
        'price' => trade['Price'],
        'amount' => trade['Amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTradesSymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def parse_order(order, market = nil)
      status = 'open'
      symbol = order['ListingCurrency'] + '/' + order['ReferenceCurrency']
      timestamp = nil
      price = self.safe_float(order, 'LimitPrice')
      amount = self.safe_float(order, 'OriginalAmount')
      remaining = self.safe_float(order, 'Amount')
      filled = nil
      cost = nil
      if amount != nil
        cost = price * amount
        if remaining != nil
          filled = amount - remaining
        end
      end
      orderType = order['Type'].downcase
      result = {
        'info' => order,
        'id' => order['Code'].to_s,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => orderType,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => nil
      }
      return result
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      response = self.privatePostListOrders
      return self.parse_orders(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      order = {
        'listingCurrency' => market['base'],
        'referenceCurrency' => market['quote'],
        'type' => side,
        'amount' => amount
      }
      if type == 'limit'
        order['limitPrice'] = price
      end
      response = self.privatePostPlaceOrder(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response.to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostCancelOrder(self.shallow_extend({
        'orderCode' => id
      }, params))
    end

    def create_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostGeneratenewaddress(self.shallow_extend({
        'currency' => currency['id']
      }, params))
      parts = response.split('|')
      numParts = parts.length
      address = parts[0]
      self.check_address(address)
      tag = nil
      if numParts > 1
        tag = parts[1]
      end
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'address' => address,
        'amount' => amount
      }
      if tag != nil
        request['address'] = address + '|' + tag
      end
      response = self.privatePostWithdraw(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => nil
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce
        query = self.shallow_extend({
          'key' => self.apiKey,
          'nonce' => nonce
        }, query)
        body = self.json(query)
        headers = {
          'Content-Type' => 'application/json',
          'Hash' => self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
