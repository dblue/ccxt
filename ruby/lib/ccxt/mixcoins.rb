# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Mixcoins < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'mixcoins',
        'name' => 'MixCoins',
        'countries' => ['GB', 'HK'],
        'rateLimit' => 1500,
        'version' => 'v1',
        'has' => {
          'CORS' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/30237212-ed29303c-9535-11e7-8af8-fcd381cfa20c.jpg',
          'api' => 'https://mixcoins.com/api',
          'www' => 'https://mixcoins.com',
          'doc' => 'https://mixcoins.com/help/api/'
        },
        'api' => {
          'public' => {
            'get' => [
              'ticker',
              'trades',
              'depth'
            ]
          },
          'private' => {
            'post' => [
              'cancel',
              'info',
              'orders',
              'order',
              'transactions',
              'trade'
            ]
          }
        },
        'markets' => {
          'BTC/USD' => { 'id' => 'btc_usd', 'symbol' => 'BTC/USD', 'base' => 'BTC', 'quote' => 'USD', 'maker' => 0.0015, 'taker' => 0.0025 },
          'ETH/BTC' => { 'id' => 'eth_btc', 'symbol' => 'ETH/BTC', 'base' => 'ETH', 'quote' => 'BTC', 'maker' => 0.001, 'taker' => 0.0015 },
          'BCH/BTC' => { 'id' => 'bch_btc', 'symbol' => 'BCH/BTC', 'base' => 'BCH', 'quote' => 'BTC', 'maker' => 0.001, 'taker' => 0.0015 },
          'LSK/BTC' => { 'id' => 'lsk_btc', 'symbol' => 'LSK/BTC', 'base' => 'LSK', 'quote' => 'BTC', 'maker' => 0.0015, 'taker' => 0.0025 },
          'BCH/USD' => { 'id' => 'bch_usd', 'symbol' => 'BCH/USD', 'base' => 'BCH', 'quote' => 'USD', 'maker' => 0.001, 'taker' => 0.0015 },
          'ETH/USD' => { 'id' => 'eth_usd', 'symbol' => 'ETH/USD', 'base' => 'ETH', 'quote' => 'USD', 'maker' => 0.001, 'taker' => 0.0015 }
        }
      })
    end

    def fetch_balance(params = {})
      response = self.privatePostInfo
      balance = response['result']['wallet']
      result = { 'info' => balance }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        lowercase = currency.downcase
        account = self.account
        if balance.include?(lowercase)
          account['free'] = parse_float(balance[lowercase]['avail'])
          account['used'] = parse_float(balance[lowercase]['lock'])
          account['total'] = self.sum(account['free'], account['used'])
        end
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      response = self.publicGetDepth(self.shallow_extend({
        'market' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(response['result'])
    end

    def fetch_ticker(symbol, params = {})
      response = self.publicGetTicker(self.shallow_extend({
        'market' => self.market_id(symbol)
      }, params))
      ticker = response['result']
      timestamp = self.milliseconds
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def parse_trade(trade, market)
      timestamp = parse_int(trade['date']) * 1000
      return {
        'id' => trade['id'].to_s,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => nil,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'amount')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetTrades(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_trades(response['result'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      order = {
        'market' => self.market_id(symbol),
        'op' => side,
        'amount' => amount
      }
      if type == 'market'
        order['order_type'] = 1
        order['price'] = price
      else
        order['order_type'] = 0
      end
      response = self.privatePostTrade(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['result']['id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancel({ 'id' => id })
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + path
      if api == 'public'
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({
          'nonce' => nonce
        }, params))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Key' => self.apiKey,
          'Sign' => self.hmac(self.encode(body), self.secret, 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('status')
        if response['status'] == 200
          return response
        end
      end
      raise(ExchangeError, self.id + ' ' + self.json(response))
    end
  end
end
