# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Virwox < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'virwox',
        'name' => 'VirWoX',
        'countries' => ['AT', 'EU'],
        'rateLimit' => 1000,
        'has' => {
          'CORS' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766894-6da9d360-5eea-11e7-90aa-41f2711b7405.jpg',
          'api' => {
            'public' => 'https://api.virwox.com/api/json.php',
            'private' => 'https://www.virwox.com/api/trading.php'
          },
          'www' => 'https://www.virwox.com',
          'doc' => 'https://www.virwox.com/developers.php'
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => false,
          'login' => true,
          'password' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'getInstruments',
              'getBestPrices',
              'getMarketDepth',
              'estimateMarketOrder',
              'getTradedPriceVolume',
              'getRawTradeData',
              'getStatistics',
              'getTerminalList',
              'getGridList',
              'getGridStatistics'
            ],
            'post' => [
              'getInstruments',
              'getBestPrices',
              'getMarketDepth',
              'estimateMarketOrder',
              'getTradedPriceVolume',
              'getRawTradeData',
              'getStatistics',
              'getTerminalList',
              'getGridList',
              'getGridStatistics'
            ]
          },
          'private' => {
            'get' => [
              'cancelOrder',
              'getBalances',
              'getCommissionDiscount',
              'getOrders',
              'getTransactions',
              'placeOrder'
            ],
            'post' => [
              'cancelOrder',
              'getBalances',
              'getCommissionDiscount',
              'getOrders',
              'getTransactions',
              'placeOrder'
            ]
          }
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetGetInstruments
      keys = markets['result'].keys
      result = []
      for p in (0...keys.length)
        market = markets['result'][keys[p]]
        id = market['instrumentID']
        symbol = market['symbol']
        base = market['longCurrency']
        quote = market['shortCurrency']
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostGetBalances
      balances = response['result']['accountList']
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency']
        total = balance['balance']
        account = {
          'free' => total,
          'used' => 0.0,
          'total' => total
        }
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_market_price(symbol, params = {})
      self.load_markets
      response = self.publicPostGetBestPrices(self.shallow_extend({
        'symbols' => [symbol]
      }, params))
      result = response['result']
      return {
        'bid' => self.safe_float(result[0], 'bestBuyPrice'),
        'ask' => self.safe_float(result[0], 'bestSellPrice')
      }
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'symbols' => [symbol]
      }
      if limit != nil
        request['buyDepth'] = limit # 100
        request['sellDepth'] = limit # 100
      end
      response = self.publicPostGetMarketDepth(self.shallow_extend(request, params))
      orderbook = response['result'][0]
      return self.parse_order_book(orderbook, nil, 'buy', 'sell', 'price', 'volume')
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      time_end = self.milliseconds
      time_start = time_end - 86400000
      response = self.publicGetGetTradedPriceVolume(self.shallow_extend({
        'instrument' => symbol,
        'endDate' => self.ymdhms(time_end),
        'startDate' => self.ymdhms(time_start),
        'HLOC' => 1
      }, params))
      tickers = response['result']['priceVolumeList']
      keys = tickers.keys
      length = keys.length
      lastKey = keys[length - 1]
      ticker = tickers[lastKey]
      timestamp = self.milliseconds
      close = self.safe_float(ticker, 'close')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => nil,
        'bidVolume' => nil,
        'ask' => nil,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'open'),
        'close' => close,
        'last' => close,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'longVolume'),
        'quoteVolume' => self.safe_float(ticker, 'shortVolume'),
        'info' => ticker
      }
    end

    def parse_trade(trade, symbol = nil)
      sec = self.safe_integer(trade, 'time')
      timestamp = sec * 1000
      return {
        'id' => trade['tid'],
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'order' => nil,
        'symbol' => symbol,
        'type' => nil,
        'side' => nil,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'vol'),
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetGetRawTradeData(self.shallow_extend({
        'instrument' => symbol,
        'timespan' => 3600
      }, params))
      result = self.safe_value(response, 'result', {})
      trades = self.safe_value(result, 'data', [])
      return self.parse_trades(trades, market)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      order = {
        'instrument' => market['symbol'],
        'orderType' => side.upcase,
        'amount' => amount
      }
      if type == 'limit'
        order['price'] = price
      end
      response = self.privatePostPlaceOrder(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['result']['orderID'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancelOrder(self.shallow_extend({
        'orderID' => id
      }, params))
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api]
      auth = {}
      if api == 'private'
        self.check_required_credentials
        auth['key'] = self.apiKey
        auth['user'] = self.login
        auth['pass'] = self.password
      end
      nonce = self.nonce
      if method == 'GET'
        url += '?' + self.urlencode(self.shallow_extend({
          'method' => path,
          'id' => nonce
        }, auth, params))
      else
        headers = { 'Content-Type' => 'application/json' }
        body = self.json({
          'method' => path,
          'params' => self.shallow_extend(auth, params),
          'id' => nonce
        })
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if code == 200
        if (body[0] == '{') || (body[0] == '[')
          if response.include?('result')
            result = response['result']
            if result.include?('errorCode')
              errorCode = result['errorCode']
              if errorCode != 'OK'
                raise(ExchangeError, self.id + ' error returned => ' + body)
              end
            end
          else
            raise(ExchangeError, self.id + ' malformed response => no result in response => ' + body)
          end
        else
          # if not a JSON response
          raise(ExchangeError, self.id + ' returned a non-JSON reply => ' + body)
        end
      end
    end
  end
end
