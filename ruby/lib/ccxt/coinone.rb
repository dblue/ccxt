# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coinone < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coinone',
        'name' => 'CoinOne',
        'countries' => ['KR'], # Korea
        'rateLimit' => 667,
        'version' => 'v2',
        'has' => {
          'CORS' => false,
          'createMarketOrder' => false,
          'fetchTickers' => true,
          'fetchOrder' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/38003300-adc12fba-323f-11e8-8525-725f53c4a659.jpg',
          'api' => 'https://api.coinone.co.kr',
          'www' => 'https://coinone.co.kr',
          'doc' => 'https://doc.coinone.co.kr'
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'orderbook/',
              'trades/',
              'ticker/'
            ]
          },
          'private' => {
            'post' => [
              'account/btc_deposit_address/',
              'account/balance/',
              'account/daily_balance/',
              'account/user_info/',
              'account/virtual_account/',
              'order/cancel_all/',
              'order/cancel/',
              'order/limit_buy/',
              'order/limit_sell/',
              'order/complete_orders/',
              'order/limit_orders/',
              'order/order_info/',
              'transaction/auth_number/',
              'transaction/history/',
              'transaction/krw/history/',
              'transaction/btc/',
              'transaction/coin/'
            ]
          }
        },
        'markets' => {
          'BCH/KRW' => { 'id' => 'bch', 'symbol' => 'BCH/KRW', 'base' => 'BCH', 'quote' => 'KRW', 'baseId' => 'bch', 'quoteId' => 'krw' },
          'BTC/KRW' => { 'id' => 'btc', 'symbol' => 'BTC/KRW', 'base' => 'BTC', 'quote' => 'KRW', 'baseId' => 'btc', 'quoteId' => 'krw' },
          'BTG/KRW' => { 'id' => 'btg', 'symbol' => 'BTG/KRW', 'base' => 'BTG', 'quote' => 'KRW', 'baseId' => 'btg', 'quoteId' => 'krw' },
          'ETC/KRW' => { 'id' => 'etc', 'symbol' => 'ETC/KRW', 'base' => 'ETC', 'quote' => 'KRW', 'baseId' => 'etc', 'quoteId' => 'krw' },
          'ETH/KRW' => { 'id' => 'eth', 'symbol' => 'ETH/KRW', 'base' => 'ETH', 'quote' => 'KRW', 'baseId' => 'eth', 'quoteId' => 'krw' },
          'IOTA/KRW' => { 'id' => 'iota', 'symbol' => 'IOTA/KRW', 'base' => 'IOTA', 'quote' => 'KRW', 'baseId' => 'iota', 'quoteId' => 'krw' },
          'LTC/KRW' => { 'id' => 'ltc', 'symbol' => 'LTC/KRW', 'base' => 'LTC', 'quote' => 'KRW', 'baseId' => 'ltc', 'quoteId' => 'krw' },
          'OMG/KRW' => { 'id' => 'omg', 'symbol' => 'OMG/KRW', 'base' => 'OMG', 'quote' => 'KRW', 'baseId' => 'omg', 'quoteId' => 'krw' },
          'QTUM/KRW' => { 'id' => 'qtum', 'symbol' => 'QTUM/KRW', 'base' => 'QTUM', 'quote' => 'KRW', 'baseId' => 'qtum', 'quoteId' => 'krw' },
          'XRP/KRW' => { 'id' => 'xrp', 'symbol' => 'XRP/KRW', 'base' => 'XRP', 'quote' => 'KRW', 'baseId' => 'xrp', 'quoteId' => 'krw' },
          'EOS/KRW' => { 'id' => 'eos', 'symbol' => 'EOS/KRW', 'base' => 'EOS', 'quote' => 'KRW', 'baseId' => 'eos', 'quoteId' => 'krw' },
          'DATA/KRW' => { 'id' => 'data', 'symbol' => 'DATA/KRW', 'base' => 'DATA', 'quote' => 'KRW', 'baseId' => 'data', 'quoteId' => 'krw' },
          'ZIL/KRW' => { 'id' => 'zil', 'symbol' => 'ZIL/KRW', 'base' => 'ZIL', 'quote' => 'KRW', 'baseId' => 'zil', 'quoteId' => 'krw' },
          'KNC/KRW' => { 'id' => 'knc', 'symbol' => 'KNC/KRW', 'base' => 'KNC', 'quote' => 'KRW', 'baseId' => 'knc', 'quoteId' => 'krw' },
          'ZRX/KRW' => { 'id' => 'zrx', 'symbol' => 'ZRX/KRW', 'base' => 'ZRX', 'quote' => 'KRW', 'baseId' => 'zrx', 'quoteId' => 'krw' },
          'LUNA/KRW' => { 'id' => 'luna', 'symbol' => 'LUNA/KRW', 'base' => 'LUNA', 'quote' => 'KRW', 'baseId' => 'luna', 'quoteId' => 'krw' },
          'ATOM/KRW' => { 'id' => 'atom', 'symbol' => 'ATOM/KRW', 'base' => 'ATOM', 'quote' => 'KRW', 'baseId' => 'atom', 'quoteId' => 'krw' },
          'VNT/KRW' => { 'id' => 'vnt', 'symbol' => 'vnt/KRW', 'base' => 'VNT', 'quote' => 'KRW', 'baseId' => 'vnt', 'quoteId' => 'krw' }
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'percentage' => true,
            'taker' => 0.001,
            'maker' => 0.001,
            'tiers' => {
              'taker' => [
                [0, 0.001],
                [100000000, 0.0009],
                [1000000000, 0.0008],
                [5000000000, 0.0007],
                [10000000000, 0.0006],
                [20000000000, 0.0005],
                [30000000000, 0.0004],
                [40000000000, 0.0003],
                [50000000000, 0.0002]
              ],
              'maker' => [
                [0, 0.001],
                [100000000, 0.0008],
                [1000000000, 0.0006],
                [5000000000, 0.0004],
                [10000000000, 0.0002],
                [20000000000, 0],
                [30000000000, 0],
                [40000000000, 0],
                [50000000000, 0]
              ]
            }
          }
        },
        'exceptions' => {
          '405' => ExchangeNotAvailable,
          '104' => OrderNotFound
        }
      })
    end

    def fetch_balance(params = {})
      response = self.privatePostAccountBalance
      result = { 'info' => response }
      balances = self.omit(response, [
        'errorCode',
        'result',
        'normalWallets'
      ])
      ids = balances.keys
      for i in (0...ids.length)
        id = ids[i]
        balance = balances[id]
        code = id.upcase
        if self.currencies_by_id.include?(id)
          code = self.currencies_by_id[id]['code']
        end
        free = parse_float(balance['avail'])
        total = parse_float(balance['balance'])
        used = total - free
        account = {
          'free' => free,
          'used' => used,
          'total' => total
        }
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetOrderbook(self.shallow_extend({
        'currency' => market['id'],
        'format' => 'json'
      }, params))
      return self.parse_order_book(response, nil, 'bid', 'ask', 'price', 'qty')
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetTicker(self.shallow_extend({
        'currency' => 'all',
        'format' => 'json'
      }, params))
      result = {}
      tickers = response
      ids = tickers.keys
      for i in (0...ids.length)
        id = ids[i]
        symbol = id
        market = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
          ticker = tickers[id]
          result[symbol] = self.parse_ticker(ticker, market)
        end
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      market = self.market(symbol)
      response = self.publicGetTicker(self.shallow_extend({
        'currency' => market['id'],
        'format' => 'json'
      }, params))
      return self.parse_ticker(response, market)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      last = self.safe_float(ticker, 'last')
      previousClose = self.safe_float(ticker, 'yesterday_last')
      change = nil
      if last != nil && previousClose != nil
        change = previousClose - last
      end
      symbol = (market != nil) ? market['symbol'] : nil
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => nil,
        'bidVolume' => nil,
        'ask' => nil,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'first'),
        'close' => last,
        'last' => last,
        'previousClose' => previousClose,
        'change' => change,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'volume'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      timestamp = parse_int(trade['timestamp']) * 1000
      symbol = (market != nil) ? market['symbol'] : nil
      is_ask = self.safe_string(trade, 'is_ask')
      side = nil
      if is_ask == '1'
        side = 'sell'
      elsif is_ask == '0'
        side = 'buy'
      end
      return {
        'id' => nil,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'order' => nil,
        'symbol' => symbol,
        'type' => nil,
        'side' => side,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'qty'),
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetTrades(self.shallow_extend({
        'currency' => market['id'],
        'period' => 'hour',
        'format' => 'json'
      }, params))
      return self.parse_trades(response['completeOrders'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type != 'limit'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      self.load_markets
      request = {
        'price' => price,
        'currency' => self.market_id(symbol),
        'qty' => amount
      }
      method = 'privatePostOrder' + self.capitalize(type) + self.capitalize(side)
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      id = self.safe_string(response, 'orderId')
      if id != nil
        id = id.upcase
      end
      timestamp = self.milliseconds
      cost = price * amount
      order = {
        'info' => response,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => nil,
        'amount' => amount,
        'filled' => nil,
        'remaining' => amount,
        'status' => 'open',
        'fee' => nil
      }
      self.orders[id] = order
      return order
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      result = nil
      market = nil
      if symbol.nil?
        if self.orders.include?(id)
          market = self.market(self.orders[id]['symbol'])
        else
          raise(ArgumentsRequired, self.id + ' fetchOrder requires a symbol argument for order ids missing in the .orders cache(the order was created with a different instance of self class or within a different run of self code).')
        end
      else
        market = self.market(symbol)
      end
      begin
        response = self.privatePostOrderOrderInfo(self.shallow_extend({
          'order_id' => id,
          'currency' => market['id']
        }, params))
        result = self.parse_order(response)
        self.orders[id] = result
      rescue BaseError => e
        if e.is_a?(OrderNotFound)
          if self.orders.include?(id)
            self.orders[id]['status'] = 'canceled'
            result = self.orders[id]
          else
            raise e
          end
        else
          raise e
        end
      end
      return result
    end

    def parse_order_status(status)
      statuses = {
        'live' => 'open',
        'partially_filled' => 'open',
        'filled' => 'closed'
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      info = self.safe_value(order, 'info')
      id = self.safe_string(info, 'orderId')
      if id != nil
        id = id.upcase
      end
      timestamp = parse_int(info['timestamp']) * 1000
      status = self.parse_order_status(self.safe_string(order, 'status'))
      cost = nil
      side = self.safe_string(info, 'type')
      if side.include?('ask')
        side = 'sell'
      else
        side = 'buy'
      end
      price = self.safe_float(info, 'price')
      amount = self.safe_float(info, 'qty')
      remaining = self.safe_float(info, 'remainQty')
      filled = nil
      if amount != nil
        if remaining != nil
          filled = amount - remaining
        end
        if price != nil
          cost = price * amount
        end
      end
      currency = self.safe_string(info, 'currency')
      fee = {
        'currency' => currency,
        'cost' => self.safe_float(info, 'fee'),
        'rate' => self.safe_float(info, 'feeRate')
      }
      symbol = nil
      if market.nil?
        marketId = currency.downcase
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee
      }
      return result
    end

    def cancel_order(id, symbol = nil, params = {})
      order = self.safe_value(self.orders, id)
      amount = nil
      price = nil
      side = nil
      if order.nil?
        if symbol.nil?
          # eslint-disable-next-line quotes
          raise(InvalidOrder, self.id + " cancelOrder could not find the order id " + id + " in orders cache. The order was probably created with a different instance of self class earlier. The `symbol` argument is missing. To cancel the order, pass a symbol argument and {'price' => 12345, 'qty' => 1.2345, 'is_ask' => 0} in the params argument of cancelOrder.")
        end
        price = self.safe_float(params, 'price')
        if price.nil?
          # eslint-disable-next-line quotes
          raise(InvalidOrder, self.id + " cancelOrder could not find the order id " + id + " in orders cache. The order was probably created with a different instance of self class earlier. The `price` parameter is missing. To cancel the order, pass a symbol argument and {'price' => 12345, 'qty' => 1.2345, 'is_ask' => 0} in the params argument of cancelOrder.")
        end
        amount = self.safe_float(params, 'qty')
        if amount.nil?
          # eslint-disable-next-line quotes
          raise(InvalidOrder, self.id + " cancelOrder could not find the order id " + id + " in orders cache. The order was probably created with a different instance of self class earlier. The `qty`(amount) parameter is missing. To cancel the order, pass a symbol argument and {'price' => 12345, 'qty' => 1.2345, 'is_ask' => 0} in the params argument of cancelOrder.")
        end
        side = self.safe_float(params, 'is_ask')
        if side.nil?
          # eslint-disable-next-line quotes
          raise(InvalidOrder, self.id + " cancelOrder could not find the order id " + id + " in orders cache. The order was probably created with a different instance of self class earlier. The `is_ask`(side) parameter is missing. To cancel the order, pass a symbol argument and {'price' => 12345, 'qty' => 1.2345, 'is_ask' => 0} in the params argument of cancelOrder.")
        end
      else
        price = order['price']
        amount = order['amount']
        side = (order['side'] == 'buy') ? 0 : 1
        symbol = order['symbol']
      end
      request = {
        'order_id' => id,
        'price' => price,
        'qty' => amount,
        'is_ask' => side,
        'currency' => self.market_id(symbol)
      }
      self.orders[id]['status'] = 'canceled'
      return self.privatePostOrderCancel(self.shallow_extend(request, params))
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      url = self.urls['api'] + '/'
      if api == 'public'
        url += request
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        url += self.version + '/' + request
        nonce = self.nonce.to_s
        json = self.json(self.shallow_extend({
          'access_token' => self.apiKey,
          'nonce' => nonce
        }, params))
        payload = Base64.encode64(self.encode(json))
        body = self.decode(payload)
        secret = self.secret.upcase
        signature = self.hmac(payload, self.encode(secret), 'sha512')
        headers = {
          'content-type' => 'application/json',
          'X-COINONE-PAYLOAD' => payload,
          'X-COINONE-SIGNATURE' => signature
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if (body[0] == '{') || (body[0] == '[')
        if response.include?('result')
          result = response['result']
          if result != 'success'
            #
            #    {  "errorCode" => "405",  "status" => "maintenance",  "result" => "error"}
            #
            code = self.safe_string(response, 'errorCode')
            feedback = self.id + ' ' + self.json(response)
            exceptions = self.exceptions
            if exceptions.include?(code)
              raise(exceptions[code], feedback)
            else
              raise(ExchangeError, feedback)
            end
          end
        else
          raise(ExchangeError, self.id + ' ' + body)
        end
      end
    end
  end
end
