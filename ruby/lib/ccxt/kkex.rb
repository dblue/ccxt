# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Kkex < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'kkex',
        'name' => 'KKEX',
        'countries' => ['CN', 'US', 'JP'],
        'version' => 'v2',
        'has' => {
          'CORS' => false,
          'fetchBalance' => true,
          'fetchTickers' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchMyTrades' => true,
          'fetchOHLCV' => true,
          'createMarketOrder' => true,
          'fetchOrder' => true
        },
        'timeframes' => {
          '1m' => '1min',
          '5m' => '5min',
          '15m' => '15min',
          '30m' => '30min',
          '1h' => '1hour',
          '4h' => '4hour',
          '12h' => '12hour',
          '1d' => '1day',
          '1w' => '1week',
          '1M' => '1month'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/47401462-2e59f800-d74a-11e8-814f-e4ae17b4968a.jpg',
          'api' => {
            'public' => 'https://kkex.com/api/v1',
            'private' => 'https://kkex.com/api/v2',
            'v1' => 'https://kkex.com/api/v1'
          },
          'www' => 'https://kkex.com',
          'doc' => 'https://kkex.com/api_wiki/cn/',
          'fees' => 'https://intercom.help/kkex/fee'
        },
        'api' => {
          'public' => {
            'get' => [
              'exchange_rate',
              'products',
              'assets',
              'tickers',
              'ticker',
              'depth',
              'trades',
              'kline'
            ]
          },
          'private' => {
            'post' => [
              'profile',
              'trade',
              'batch_trade',
              'cancel_order',
              'cancel_all_orders',
              'order_history',
              'userinfo',
              'order_info',
              'orders_info'
            ]
          },
          'v1' => {
            'post' => [
              'process_strategy'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'taker' => 0.002,
            'maker' => 0.002
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {},
            'deposit' => {}
          }
        },
        'options' => {
          'lastNonceTimestamp' => 0
        }
      })
    end

    def fetch_markets(params = {})
      tickers = self.publicGetTickers(params)
      tickers = tickers['tickers']
      products = self.publicGetProducts(params)
      products = products['products']
      markets = []
      for k in (0...tickers.length)
        keys = tickers[k].keys
        markets.push(keys[0])
      end
      result = []
      for i in (0...markets.length)
        id = markets[i]
        market = markets[i]
        baseId = ''
        quoteId = ''
        precision = {}
        limits = {}
        for j in (0...products.length)
          p = products[j]
          if p['mark_asset'] + p['base_asset'] == market
            quoteId = p['base_asset']
            baseId = p['mark_asset']
            price_scale_str = p['price_scale'].to_s
            scale = price_scale_str.length - 1
            precision = {
              'price' => scale,
              'amount' => scale
            }
            limits = {
              'amount' => {
                'min' => maximum_wrapper(self.safe_float(p, 'min_bid_size'), self.safe_float(p, 'min_ask_size')),
                'max' => minimum_wrapper(self.safe_float(p, 'max_bid_size'), self.safe_float(p, 'max_ask_size'))
              },
              'price' => {
                'min' => self.safe_float(p, 'min_price'),
                'max' => self.safe_float(p, 'max_price')
              }
            }
            limits['cost'] = {
              'min' => self.safe_float(p, 'min_bid_amount'),
              'max' => self.safe_float(p, 'max_bid_amount')
            }
          end
        end
        base = baseId.upcase
        quote = quoteId.upcase
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => limits,
          'info' => market
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.safe_integer(ticker, 'date')
      if timestamp != nil
        timestamp *= 1000
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.markets[symbol]
      response = self.publicGetTicker(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      ticker = self.shallow_extend(response['ticker'], self.omit(response, 'ticker'))
      return self.parse_ticker(ticker, market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetTickers(params)
      #
      #     {    date =>    1540350657,
      #       tickers => [{ ENUBTC => { sell => "0.00000256",
      #                               buy => "0.00000253",
      #                              last => "0.00000253",
      #                               vol => "138686.828804",
      #                              high => "0.00000278",
      #                               low => "0.00000253",
      #                              open => "0.0000027"      } },
      #                  { ENUEOS => { sell => "0.00335",
      #                               buy => "0.002702",
      #                              last => "0.0034",
      #                               vol => "15084.9",
      #                              high => "0.0034",
      #                               low => "0.003189",
      #                              open => "0.003189"  } }           ],
      #        result =>    true                                          }
      #
      tickers = response['tickers']
      result = {}
      for i in (0...tickers.length)
        ids = tickers[i].keys
        id = ids[0]
        market = self.safe_value(self.markets_by_id, id)
        if market != nil
          symbol = market['symbol']
          ticker = self.shallow_extend(tickers[i][id], self.omit(response, 'tickers'))
          result[symbol] = self.parse_ticker(ticker, market)
        end
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'symbol' => self.market_id(symbol)
      }
      if limit != nil
        request['size'] = limit
      end
      response = self.publicGetDepth(self.shallow_extend(request, params))
      return self.parse_order_book(response)
    end

    def parse_trade(trade, market = nil)
      timestamp = self.safe_integer(trade, 'date_ms')
      datetime = self.iso8601(timestamp)
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      cost = nil
      if price != nil
        if amount != nil
          cost = amount * price
        end
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      id = self.safe_string(trade, 'tid')
      type = nil
      side = self.safe_string(trade, 'type')
      return {
        'info' => trade,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => datetime,
        'symbol' => symbol,
        'order' => nil,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTrades(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privatePostUserinfo
      result = { 'info' => balances['info'] }
      funds = balances['info']['funds']
      assets = funds['free'].keys
      for i in (0...assets.length)
        currency = assets[i]
        uppercase = currency.upcase
        uppercase = self.common_currency_code(uppercase)
        account = self.account
        account['free'] = parse_float(funds['free'][currency])
        account['used'] = parse_float(funds['freezed'][currency])
        account['total'] = account['free'] + account['used']
        result[uppercase] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order(id, symbol = nil, params = {})
      if !symbol
        raise(ArgumentsRequired, self.id + ' fetchOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'order_id' => id,
        'symbol' => market['id']
      }
      response = self.privatePostOrderInfo(self.shallow_extend(request, params))
      if response['result']
        return self.parse_order(response['order'], market)
      end
      raise(OrderNotFound, self.id + ' order ' + id + ' not found')
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        parse_int(ohlcv[0]),
        parse_float(ohlcv[1]),
        parse_float(ohlcv[2]),
        parse_float(ohlcv[3]),
        parse_float(ohlcv[4]),
        parse_float(ohlcv[5])
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'type' => self.timeframes[timeframe]
      }
      if since != nil
        # since = self.milliseconds - self.parse_timeframe(timeframe) * limit * 1000
        request['since'] = since
      end
      if limit != nil
        request['size'] = limit
      end
      response = self.publicGetKline(self.shallow_extend(request, params))
      #
      #     [
      #         [
      #             "1521072000000",
      #             "0.000002",
      #             "0.00003",
      #             "0.000002",
      #             "0.00003",
      #             "3.106889"
      #         ],
      #         [
      #             "1517356800000",
      #             "0.1",
      #             "0.1",
      #             "0.00000013",
      #             "0.000001",
      #             "542832.83114"
      #         ]
      #     ]
      #
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    def parse_order_status(status)
      statuses = {
        '-1' => 'canceled',
        '0' => 'open',
        '1' => 'open',
        '2' => 'closed',
        '3' => 'open',
        '4' => 'canceled'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      side = self.safe_string(order, 'side')
      if side.nil?
        side = self.safe_string(order, 'type')
      end
      timestamp = self.safe_integer(order, 'create_date')
      id = self.safe_string_2(order, 'order_id', 'id')
      status = self.parse_order_status(self.safe_string(order, 'status'))
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'amount')
      filled = self.safe_float(order, 'deal_amount')
      average = self.safe_float(order, 'avg_price')
      average = self.safe_float(order, 'price_avg', average)
      remaining = nil
      cost = nil
      if filled != nil
        if amount != nil
          remaining = amount - filled
        end
        if average != nil
          cost = average * filled
        end
      end
      return {
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'average' => average,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'fee' => nil,
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'type' => side
      }
      if type == 'market'
        # for market buy it requires the amount of quote currency to spend
        if side == 'buy'
          if self.options['createMarketBuyOrderRequiresPrice']
            if price.nil?
              raise(InvalidOrder, self.id + " createOrder requires the price argument with market buy orders to calculate total order cost(amount to spend), where cost = amount * price. Supply a price argument to createOrder call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument(the exchange-specific behaviour)")
            else
              amount = amount * price
            end
          end
          request['price'] = self.amount_to_precision(symbol, amount)
        else
          request['amount'] = self.amount_to_precision(symbol, amount)
        end
        request['type'] += '_' + type
      else
        request['amount'] = self.amount_to_precision(symbol, amount)
        request['price'] = self.price_to_precision(symbol, price)
      end
      response = self.privatePostTrade(self.shallow_extend(request, params))
      id = self.safe_string(response, 'order_id')
      return {
        'info' => response,
        'id' => id,
        'datetime' => nil,
        'timestamp' => nil,
        'lastTradeTimestamp' => nil,
        'status' => 'open',
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => nil,
        'amount' => amount,
        'filled' => nil,
        'remaining' => nil,
        'trades' => nil,
        'fee' => nil
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' cancelOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'order_id' => id,
        'symbol' => market['id']
      }
      return self.privatePostCancelOrder(self.shallow_extend(request, params))
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id']
      }
      if limit != nil
        request['page_length'] = limit # 20 by default
      end
      response = self.privatePostOrderHistory(self.shallow_extend(request, params))
      return self.parse_orders(response['orders'], market, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'status' => 0
      }, params))
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'status' => 1
      }, params))
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + path
      if api == 'public'
        url += '?' + self.urlencode(params)
        headers = { 'Content-Type' => 'application/json' }
      else
        self.check_required_credentials
        nonce = self.nonce
        signature = self.shallow_extend({ 'nonce' => nonce, 'api_key' => self.apiKey }, params)
        signature = self.urlencode(self.keysort(signature))
        signature += '&secret_key=' + self.secret
        signature = self.hash(self.encode(signature), 'md5')
        signature = signature.upcase
        body = self.shallow_extend({
          'api_key' => self.apiKey,
          'sign' => signature,
          'nonce' => nonce
        }, params)
        body = self.urlencode(body)
        headers = { 'Content-Type' => 'application/x-www-form-urlencoded' }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
