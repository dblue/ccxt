# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bitbay < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bitbay',
        'name' => 'BitBay',
        'countries' => ['MT', 'EU'], # Malta
        'rateLimit' => 1000,
        'has' => {
          'CORS' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766132-978a7bd8-5ece-11e7-9540-bc96d1e9bbb8.jpg',
          'www' => 'https://bitbay.net',
          'api' => {
            'public' => 'https://bitbay.net/API/Public',
            'private' => 'https://bitbay.net/API/Trading/tradingApi.php'
          },
          'doc' => [
            'https://bitbay.net/public-api',
            'https://bitbay.net/account/tab-api',
            'https://github.com/BitBayNet/API'
          ],
          'fees' => 'https://bitbay.net/en/fees'
        },
        'api' => {
          'public' => {
            'get' => [
              '{id}/all',
              '{id}/market',
              '{id}/orderbook',
              '{id}/ticker',
              '{id}/trades'
            ]
          },
          'private' => {
            'post' => [
              'info',
              'trade',
              'cancel',
              'orderbook',
              'orders',
              'transfer',
              'withdraw',
              'history',
              'transactions'
            ]
          }
        },
        'markets' => {
          'BTC/USD' => { 'id' => 'BTCUSD', 'symbol' => 'BTC/USD', 'base' => 'BTC', 'quote' => 'USD', 'baseId' => 'BTC', 'quoteId' => 'USD' },
          'BTC/EUR' => { 'id' => 'BTCEUR', 'symbol' => 'BTC/EUR', 'base' => 'BTC', 'quote' => 'EUR', 'baseId' => 'BTC', 'quoteId' => 'EUR' },
          'BTC/PLN' => { 'id' => 'BTCPLN', 'symbol' => 'BTC/PLN', 'base' => 'BTC', 'quote' => 'PLN', 'baseId' => 'BTC', 'quoteId' => 'PLN' },
          'LTC/USD' => { 'id' => 'LTCUSD', 'symbol' => 'LTC/USD', 'base' => 'LTC', 'quote' => 'USD', 'baseId' => 'LTC', 'quoteId' => 'USD' },
          'LTC/EUR' => { 'id' => 'LTCEUR', 'symbol' => 'LTC/EUR', 'base' => 'LTC', 'quote' => 'EUR', 'baseId' => 'LTC', 'quoteId' => 'EUR' },
          'LTC/PLN' => { 'id' => 'LTCPLN', 'symbol' => 'LTC/PLN', 'base' => 'LTC', 'quote' => 'PLN', 'baseId' => 'LTC', 'quoteId' => 'PLN' },
          'LTC/BTC' => { 'id' => 'LTCBTC', 'symbol' => 'LTC/BTC', 'base' => 'LTC', 'quote' => 'BTC', 'baseId' => 'LTC', 'quoteId' => 'BTC' },
          'ETH/USD' => { 'id' => 'ETHUSD', 'symbol' => 'ETH/USD', 'base' => 'ETH', 'quote' => 'USD', 'baseId' => 'ETH', 'quoteId' => 'USD' },
          'ETH/EUR' => { 'id' => 'ETHEUR', 'symbol' => 'ETH/EUR', 'base' => 'ETH', 'quote' => 'EUR', 'baseId' => 'ETH', 'quoteId' => 'EUR' },
          'ETH/PLN' => { 'id' => 'ETHPLN', 'symbol' => 'ETH/PLN', 'base' => 'ETH', 'quote' => 'PLN', 'baseId' => 'ETH', 'quoteId' => 'PLN' },
          'ETH/BTC' => { 'id' => 'ETHBTC', 'symbol' => 'ETH/BTC', 'base' => 'ETH', 'quote' => 'BTC', 'baseId' => 'ETH', 'quoteId' => 'BTC' },
          'LSK/USD' => { 'id' => 'LSKUSD', 'symbol' => 'LSK/USD', 'base' => 'LSK', 'quote' => 'USD', 'baseId' => 'LSK', 'quoteId' => 'USD' },
          'LSK/EUR' => { 'id' => 'LSKEUR', 'symbol' => 'LSK/EUR', 'base' => 'LSK', 'quote' => 'EUR', 'baseId' => 'LSK', 'quoteId' => 'EUR' },
          'LSK/PLN' => { 'id' => 'LSKPLN', 'symbol' => 'LSK/PLN', 'base' => 'LSK', 'quote' => 'PLN', 'baseId' => 'LSK', 'quoteId' => 'PLN' },
          'LSK/BTC' => { 'id' => 'LSKBTC', 'symbol' => 'LSK/BTC', 'base' => 'LSK', 'quote' => 'BTC', 'baseId' => 'LSK', 'quoteId' => 'BTC' },
          'BCH/USD' => { 'id' => 'BCCUSD', 'symbol' => 'BCH/USD', 'base' => 'BCH', 'quote' => 'USD', 'baseId' => 'BCC', 'quoteId' => 'USD' },
          'BCH/EUR' => { 'id' => 'BCCEUR', 'symbol' => 'BCH/EUR', 'base' => 'BCH', 'quote' => 'EUR', 'baseId' => 'BCC', 'quoteId' => 'EUR' },
          'BCH/PLN' => { 'id' => 'BCCPLN', 'symbol' => 'BCH/PLN', 'base' => 'BCH', 'quote' => 'PLN', 'baseId' => 'BCC', 'quoteId' => 'PLN' },
          'BCH/BTC' => { 'id' => 'BCCBTC', 'symbol' => 'BCH/BTC', 'base' => 'BCH', 'quote' => 'BTC', 'baseId' => 'BCC', 'quoteId' => 'BTC' },
          'BTG/USD' => { 'id' => 'BTGUSD', 'symbol' => 'BTG/USD', 'base' => 'BTG', 'quote' => 'USD', 'baseId' => 'BTG', 'quoteId' => 'USD' },
          'BTG/EUR' => { 'id' => 'BTGEUR', 'symbol' => 'BTG/EUR', 'base' => 'BTG', 'quote' => 'EUR', 'baseId' => 'BTG', 'quoteId' => 'EUR' },
          'BTG/PLN' => { 'id' => 'BTGPLN', 'symbol' => 'BTG/PLN', 'base' => 'BTG', 'quote' => 'PLN', 'baseId' => 'BTG', 'quoteId' => 'PLN' },
          'BTG/BTC' => { 'id' => 'BTGBTC', 'symbol' => 'BTG/BTC', 'base' => 'BTG', 'quote' => 'BTC', 'baseId' => 'BTG', 'quoteId' => 'BTC' },
          'DASH/USD' => { 'id' => 'DASHUSD', 'symbol' => 'DASH/USD', 'base' => 'DASH', 'quote' => 'USD', 'baseId' => 'DASH', 'quoteId' => 'USD' },
          'DASH/EUR' => { 'id' => 'DASHEUR', 'symbol' => 'DASH/EUR', 'base' => 'DASH', 'quote' => 'EUR', 'baseId' => 'DASH', 'quoteId' => 'EUR' },
          'DASH/PLN' => { 'id' => 'DASHPLN', 'symbol' => 'DASH/PLN', 'base' => 'DASH', 'quote' => 'PLN', 'baseId' => 'DASH', 'quoteId' => 'PLN' },
          'DASH/BTC' => { 'id' => 'DASHBTC', 'symbol' => 'DASH/BTC', 'base' => 'DASH', 'quote' => 'BTC', 'baseId' => 'DASH', 'quoteId' => 'BTC' },
          'GAME/USD' => { 'id' => 'GAMEUSD', 'symbol' => 'GAME/USD', 'base' => 'GAME', 'quote' => 'USD', 'baseId' => 'GAME', 'quoteId' => 'USD' },
          'GAME/EUR' => { 'id' => 'GAMEEUR', 'symbol' => 'GAME/EUR', 'base' => 'GAME', 'quote' => 'EUR', 'baseId' => 'GAME', 'quoteId' => 'EUR' },
          'GAME/PLN' => { 'id' => 'GAMEPLN', 'symbol' => 'GAME/PLN', 'base' => 'GAME', 'quote' => 'PLN', 'baseId' => 'GAME', 'quoteId' => 'PLN' },
          'GAME/BTC' => { 'id' => 'GAMEBTC', 'symbol' => 'GAME/BTC', 'base' => 'GAME', 'quote' => 'BTC', 'baseId' => 'GAME', 'quoteId' => 'BTC' },
          'XRP/USD' => { 'id' => 'XRPUSD', 'symbol' => 'XRP/USD', 'base' => 'XRP', 'quote' => 'USD', 'baseId' => 'XRP', 'quoteId' => 'USD' },
          'XRP/EUR' => { 'id' => 'XRPEUR', 'symbol' => 'XRP/EUR', 'base' => 'XRP', 'quote' => 'EUR', 'baseId' => 'XRP', 'quoteId' => 'EUR' },
          'XRP/PLN' => { 'id' => 'XRPPLN', 'symbol' => 'XRP/PLN', 'base' => 'XRP', 'quote' => 'PLN', 'baseId' => 'XRP', 'quoteId' => 'PLN' },
          'XRP/BTC' => { 'id' => 'XRPBTC', 'symbol' => 'XRP/BTC', 'base' => 'XRP', 'quote' => 'BTC', 'baseId' => 'XRP', 'quoteId' => 'BTC' },
          # 'XIN/USD' => { 'id' => 'XINUSD', 'symbol' => 'XIN/USD', 'base' => 'XIN', 'quote' => 'USD', 'baseId' => 'XIN', 'quoteId' => 'USD' },
          # 'XIN/EUR' => { 'id' => 'XINEUR', 'symbol' => 'XIN/EUR', 'base' => 'XIN', 'quote' => 'EUR', 'baseId' => 'XIN', 'quoteId' => 'EUR' },
          # 'XIN/PLN' => { 'id' => 'XINPLN', 'symbol' => 'XIN/PLN', 'base' => 'XIN', 'quote' => 'PLN', 'baseId' => 'XIN', 'quoteId' => 'PLN' },
          'XIN/BTC' => { 'id' => 'XINBTC', 'symbol' => 'XIN/BTC', 'base' => 'XIN', 'quote' => 'BTC', 'baseId' => 'XIN', 'quoteId' => 'BTC' }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.3 / 100,
            'taker' => 0.0043
          },
          'funding' => {
            'withdraw' => {
              'BTC' => 0.0009,
              'LTC' => 0.005,
              'ETH' => 0.00126,
              'LSK' => 0.2,
              'BCH' => 0.0006,
              'GAME' => 0.005,
              'DASH' => 0.001,
              'BTG' => 0.0008,
              'PLN' => 4,
              'EUR' => 1.5
            }
          }
        },
        'exceptions' => {
          '400' => ExchangeError, # At least one parameter wasn't set
          '401' => InvalidOrder, # Invalid order type
          '402' => InvalidOrder, # No orders with specified currencies
          '403' => InvalidOrder, # Invalid payment currency name
          '404' => InvalidOrder, # Error. Wrong transaction type
          '405' => InvalidOrder, # Order with self id doesn't exist
          '406' => InsufficientFunds, # No enough money or crypto
          # code 407 not specified are not specified in their docs
          '408' => InvalidOrder, # Invalid currency name
          '501' => AuthenticationError, # Invalid public key
          '502' => AuthenticationError, # Invalid sign
          '503' => InvalidNonce, # Invalid moment parameter. Request time doesn't match current server time
          '504' => ExchangeError, # Invalid method
          '505' => AuthenticationError, # Key has no permission for self action
          '506' => AuthenticationError, # Account locked. Please contact with customer service
          # codes 507 and 508 are not specified in their docs
          '509' => ExchangeError, # The BIC/SWIFT is required for self currency
          '510' => ExchangeError, # Invalid market name
        }
      })
    end

    def fetch_balance(params = {})
      response = self.privatePostInfo
      if response.include?('balances')
        balance = response['balances']
        result = { 'info' => balance }
        codes = self.currencies.keys
        for i in (0...codes.length)
          code = codes[i]
          currency = self.currencies[code]
          id = currency['id']
          account = self.account
          if balance.include?(id)
            account['free'] = parse_float(balance[id]['available'])
            account['used'] = parse_float(balance[id]['locked'])
            account['total'] = self.sum(account['free'], account['used'])
          end
          result[code] = account
        end
        return self.parse_balance(result)
      end
      raise(ExchangeError, self.id + ' empty balance response ' + self.json(response))
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      orderbook = self.publicGetIdOrderbook(self.shallow_extend({
        'id' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook)
    end

    def fetch_ticker(symbol, params = {})
      ticker = self.publicGetIdTicker(self.shallow_extend({
        'id' => self.market_id(symbol)
      }, params))
      timestamp = self.milliseconds
      baseVolume = self.safe_float(ticker, 'volume')
      vwap = self.safe_float(ticker, 'vwap')
      quoteVolume = nil
      if baseVolume != nil && vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'max'),
        'low' => self.safe_float(ticker, 'min'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => self.safe_float(ticker, 'average'),
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def parse_trade(trade, market)
      timestamp = trade['date'] * 1000
      return {
        'id' => trade['tid'],
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => trade['type'],
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetIdTrades(self.shallow_extend({
        'id' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type != 'limit'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      market = self.market(symbol)
      return self.privatePostTrade(self.shallow_extend({
        'type' => side,
        'currency' => market['baseId'],
        'amount' => amount,
        'payment_currency' => market['quoteId'],
        'rate' => price
      }, params))
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancel({ 'id' => id })
    end

    def is_fiat(currency)
      fiatCurrencies = {
        'USD' => true,
        'EUR' => true,
        'PLN' => true
      }
      if fiatCurrencies.include?(currency)
        return true
      end
      return false
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      method = nil
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'quantity' => amount
      }
      if self.is_fiat(code)
        method = 'privatePostWithdraw'
        # request['account'] = params['account'] # they demand an account number
        # request['express'] = params['express'] # whatever it means, they don't explain
        # request['bic'] = ''
      else
        method = 'privatePostTransfer'
        if tag != nil
          address += '?dt=' + tag.to_s
        end
        request['address'] = address
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => nil
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api]
      if api == 'public'
        query = self.omit(params, self.extract_params(path))
        url += '/' + self.implode_params(path, params) + '.json'
        url += '?' + self.urlencode(query)
      else
        self.check_required_credentials
        body = self.urlencode(self.shallow_extend({
          'method' => path,
          'moment' => self.nonce
        }, params))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'API-Key' => self.apiKey,
          'API-Hash' => self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end
      if (body[0] == '{') || (body[0] == '[')
        if response.include?('code')
          #
          # bitbay returns the integer 'success' => 1 key from their private API
          # or an integer 'code' value from 0 to 510 and an error message
          #
          #      { 'success' => 1, ... }
          #      { 'code' => 502, 'message' => 'Invalid sign' }
          #      { 'code' => 0, 'message' => 'offer funds not exceeding minimums' }
          #
          #      400 At least one parameter wasn't set
          #      401 Invalid order type
          #      402 No orders with specified currencies
          #      403 Invalid payment currency name
          #      404 Error. Wrong transaction type
          #      405 Order with self id doesn't exist
          #      406 No enough money or crypto
          #      408 Invalid currency name
          #      501 Invalid public key
          #      502 Invalid sign
          #      503 Invalid moment parameter. Request time doesn't match current server time
          #      504 Invalid method
          #      505 Key has no permission for self action
          #      506 Account locked. Please contact with customer service
          #      509 The BIC/SWIFT is required for self currency
          #      510 Invalid market name
          #
          code = response['code'] # always an integer
          feedback = self.id + ' ' + self.json(response)
          exceptions = self.exceptions
          if self.exceptions.include?(code)
            raise(exceptions[code], feedback)
          else
            raise(ExchangeError, feedback)
          end
        end
      end
    end
  end
end
