# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Exx < Exchange
    def describe
      return self.class.deep_extend(super, {
        'id' => 'exx',
        'name' => 'EXX',
        'countries' => ['CN'],
        'rateLimit' => 1000 / 10,
        'userAgent' => self.userAgents['chrome'],
        'has' => {
          'fetchOrder' => true,
          'fetchTickers' => true,
          'fetchOpenOrders' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/37770292-fbf613d0-2de4-11e8-9f79-f2dc451b8ccb.jpg',
          'api' => {
            'public' => 'https://api.exx.com/data/v1',
            'private' => 'https://trade.exx.com/api'
          },
          'www' => 'https://www.exx.com/',
          'doc' => 'https://www.exx.com/help/restApi',
          'fees' => 'https://www.exx.com/help/rate',
          'referral' => 'https://www.exx.com/r/fde4260159e53ab8a58cc9186d35501f'
        },
        'api' => {
          'public' => {
            'get' => [
              'markets',
              'tickers',
              'ticker',
              'depth',
              'trades'
            ]
          },
          'private' => {
            'get' => [
              'order',
              'cancel',
              'getOrder',
              'getOpenOrders',
              'getBalance'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.1 / 100,
            'taker' => 0.1 / 100
          },
          'funding' => {
            'withdraw' => {
              'BCC' => 0.0003,
              'BCD' => 0.0,
              'BOT' => 10.0,
              'BTC' => 0.001,
              'BTG' => 0.0,
              'BTM' => 25.0,
              'BTS' => 3.0,
              'EOS' => 1.0,
              'ETC' => 0.01,
              'ETH' => 0.01,
              'ETP' => 0.012,
              'HPY' => 0.0,
              'HSR' => 0.001,
              'INK' => 20.0,
              'LTC' => 0.005,
              'MCO' => 0.6,
              'MONA' => 0.01,
              'QASH' => 5.0,
              'QCASH' => 5.0,
              'QTUM' => 0.01,
              'USDT' => 5.0
            }
          }
        },
        'commonCurrencies' => {
          'TV' => 'TIV', # Ti-Value
        },
        'exceptions' => {
          '103' => AuthenticationError
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetMarkets
      ids = markets.keys
      result = []
      for i in (0...ids.length)
        id = ids[i]
        market = markets[id]
        baseId, quoteId = id.split('_')
        upper = id.upcase
        base, quote = upper.split('_')
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        active = market['isOpen'] == true
        precision = {
          'amount' => (market['amountScale']).to_i,
          'price' => (market['priceScale']).to_i
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => 10**precision['amount']
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => 10**precision['price']
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => market
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      symbol = market['symbol']
      timestamp = (ticker['date']).to_i
      ticker = ticker['ticker']
      last = self.class.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.class.iso8601(timestamp),
        'high' => self.class.safe_float(ticker, 'high'),
        'low' => self.class.safe_float(ticker, 'low'),
        'bid' => self.class.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.class.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => self.class.safe_float(ticker, 'riseRate'),
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.class.safe_float(ticker, 'vol'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetTicker(self.class.shallow_extend({
        'currency' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTickers(params)
      result = {}
      timestamp = self.class.milliseconds
      ids = tickers.keys
      for i in (0...ids.length)
        id = ids[i]
        if self.marketsById.include?(!(id))
          continue
        end
        market = self.marketsById[id]
        symbol = market['symbol']
        ticker = {
          'date' => timestamp,
          'ticker' => tickers[id]
        }
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetDepth(self.class.shallow_extend({
        'currency' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook, orderbook['timestamp'])
    end

    def parse_trade(trade, market = nil)
      timestamp = trade['date'] * 1000
      price = self.class.safe_float(trade, 'price')
      amount = self.class.safe_float(trade, 'amount')
      symbol = market['symbol']
      cost = self.cost_to_precision(symbol, price * amount)
      return {
        'timestamp' => timestamp,
        'datetime' => self.class.iso8601(timestamp),
        'symbol' => symbol,
        'id' => self.class.safe_string(trade, 'tid'),
        'order' => nil,
        'type' => 'limit',
        'side' => trade['type'],
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      trades = self.publicGetTrades(self.class.shallow_extend({
        'currency' => market['id']
      }, params))
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privateGetGetBalance(params)
      result = { 'info' => balances }
      balances = balances['funds']
      currencies = balances.keys
      for i in (0...currencies.length)
        id = currencies[i]
        balance = balances[id]
        currency = self.common_currency_code(id)
        account = {
          'free' => balance['balance'].to_f,
          'used' => balance['freeze'].to_f,
          'total' => balance['total'].to_f
        }
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def parse_order(order, market = nil)
      symbol = market['symbol']
      timestamp = (order['trade_date']).to_i
      price = self.class.safe_float(order, 'price')
      cost = self.class.safe_float(order, 'trade_money')
      amount = self.class.safe_float(order, 'total_amount')
      filled = self.class.safe_float(order, 'trade_amount', 0.0)
      remaining = self.amount_to_precision(symbol, amount - filled.to_f)
      status = self.class.safe_integer(order, 'status')
      if status == 1
        status = 'canceled'
      elsif status == 2
        status = 'closed'
      else
        status = 'open'
      end
      fee = nil
      if order.include?('fees')
        fee = {
          'cost' => self.class.safe_float(order, 'fees'),
          'currency' => market['quote']
        }
      end
      return {
        'id' => self.class.safe_string(order, 'id'),
        'datetime' => self.class.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => order['type'],
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => fee,
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privateGetOrder(self.class.shallow_extend({
        'currency' => market['id'],
        'type' => side,
        'price' => price,
        'amount' => amount
      }, params))
      id = response['id']
      order = self.parse_order({
        'id' => id,
        'trade_date' => self.class.milliseconds,
        'total_amount' => amount,
        'price' => price,
        'type' => side,
        'info' => response
      }, market)
      self.orders[id] = order
      return order
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      result = self.privateGetCancel(self.class.shallow_extend({
        'id' => id,
        'currency' => market['id']
      }, params))
      return result
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      order = self.privateGetGetOrder(self.class.shallow_extend({
        'id' => id,
        'currency' => market['id']
      }, params))
      return self.parse_order(order, market)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      orders = self.privateGetGetOpenOrders(self.class.shallow_extend({
        'currency' => market['id']
      }, params))
      if !orders.is_a?(Array)
        return []
      end
      return self.parse_orders(orders, market, since, limit)
    end

    def nonce
      return self.class.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + path
      if api == 'public'
        if params
          url += '?' + self.class.urlencode(params)
        end
      else
        self.check_required_credentials
        query = self.class.urlencode(self.class.keysort(self.class.shallow_extend({
          'accesskey' => self.apiKey,
          'nonce' => self.nonce
        }, params)))
        signed = self.class.hmac(self.class.encode(query), self.class.encode(self.secret), 'sha512')
        url += '?' + query + '&signature=' + signed
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        #
        #  {"result":false,"message":"服务端忙碌"}
        #  ... and other formats
        #
        code = self.class.safe_string(response, 'code')
        message = self.class.safe_string(response, 'message')
        feedback = self.id + ' ' + self.class.json(response)
        if code == '100'
          return
        end
        if code != nil
          exceptions = self.exceptions
          if exceptions.include?(code)
            raise(exceptions[code], feedback)
          elsif code == '308'
            # self is returned by the exchange when there are no open orders
            # {"code":308,"message":"Not Found Transaction Record"}
            return
          else
            raise(ExchangeError, feedback)
          end
        end
        result = self.class.safe_value(response, 'result')
        if result != nil
          if !result
            if message == '服务端忙碌'
              raise(ExchangeNotAvailable, feedback)
            else
              raise(ExchangeError, feedback)
            end
          end
        end
      end
    end
  end
end
