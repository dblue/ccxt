# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Ccxt1btcxe < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => '_1btcxe',
        'name' => '1BTCXE',
        'countries' => ['PA'], # Panama
        'comment' => 'Crypto Capital API',
        'has' => {
          'CORS' => true,
          'withdraw' => true
        },
        'timeframes' => {
          '1d' => '1year'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766049-2b294408-5ecc-11e7-85cc-adaff013dc1a.jpg',
          'api' => 'https://1btcxe.com/api',
          'www' => 'https://1btcxe.com',
          'doc' => 'https://1btcxe.com/api-docs.php'
        },
        'api' => {
          'public' => {
            'get' => [
              'stats',
              'historical-prices',
              'order-book',
              'transactions'
            ]
          },
          'private' => {
            'post' => [
              'balances-and-info',
              'open-orders',
              'user-transactions',
              'btc-deposit-address/get',
              'btc-deposit-address/new',
              'deposits/get',
              'withdrawals/get',
              'orders/new',
              'orders/edit',
              'orders/cancel',
              'orders/status',
              'withdrawals/new'
            ]
          }
        }
      })
    end

    def fetch_markets(params = {})
      return [
        { 'id' => 'USD', 'symbol' => 'BTC/USD', 'base' => 'BTC', 'quote' => 'USD' },
        { 'id' => 'EUR', 'symbol' => 'BTC/EUR', 'base' => 'BTC', 'quote' => 'EUR' },
        { 'id' => 'CNY', 'symbol' => 'BTC/CNY', 'base' => 'BTC', 'quote' => 'CNY' },
        { 'id' => 'RUB', 'symbol' => 'BTC/RUB', 'base' => 'BTC', 'quote' => 'RUB' },
        { 'id' => 'CHF', 'symbol' => 'BTC/CHF', 'base' => 'BTC', 'quote' => 'CHF' },
        { 'id' => 'JPY', 'symbol' => 'BTC/JPY', 'base' => 'BTC', 'quote' => 'JPY' },
        { 'id' => 'GBP', 'symbol' => 'BTC/GBP', 'base' => 'BTC', 'quote' => 'GBP' },
        { 'id' => 'CAD', 'symbol' => 'BTC/CAD', 'base' => 'BTC', 'quote' => 'CAD' },
        { 'id' => 'AUD', 'symbol' => 'BTC/AUD', 'base' => 'BTC', 'quote' => 'AUD' },
        { 'id' => 'AED', 'symbol' => 'BTC/AED', 'base' => 'BTC', 'quote' => 'AED' },
        { 'id' => 'BGN', 'symbol' => 'BTC/BGN', 'base' => 'BTC', 'quote' => 'BGN' },
        { 'id' => 'CZK', 'symbol' => 'BTC/CZK', 'base' => 'BTC', 'quote' => 'CZK' },
        { 'id' => 'DKK', 'symbol' => 'BTC/DKK', 'base' => 'BTC', 'quote' => 'DKK' },
        { 'id' => 'HKD', 'symbol' => 'BTC/HKD', 'base' => 'BTC', 'quote' => 'HKD' },
        { 'id' => 'HRK', 'symbol' => 'BTC/HRK', 'base' => 'BTC', 'quote' => 'HRK' },
        { 'id' => 'HUF', 'symbol' => 'BTC/HUF', 'base' => 'BTC', 'quote' => 'HUF' },
        { 'id' => 'ILS', 'symbol' => 'BTC/ILS', 'base' => 'BTC', 'quote' => 'ILS' },
        { 'id' => 'INR', 'symbol' => 'BTC/INR', 'base' => 'BTC', 'quote' => 'INR' },
        { 'id' => 'MUR', 'symbol' => 'BTC/MUR', 'base' => 'BTC', 'quote' => 'MUR' },
        { 'id' => 'MXN', 'symbol' => 'BTC/MXN', 'base' => 'BTC', 'quote' => 'MXN' },
        { 'id' => 'NOK', 'symbol' => 'BTC/NOK', 'base' => 'BTC', 'quote' => 'NOK' },
        { 'id' => 'NZD', 'symbol' => 'BTC/NZD', 'base' => 'BTC', 'quote' => 'NZD' },
        { 'id' => 'PLN', 'symbol' => 'BTC/PLN', 'base' => 'BTC', 'quote' => 'PLN' },
        { 'id' => 'RON', 'symbol' => 'BTC/RON', 'base' => 'BTC', 'quote' => 'RON' },
        { 'id' => 'SEK', 'symbol' => 'BTC/SEK', 'base' => 'BTC', 'quote' => 'SEK' },
        { 'id' => 'SGD', 'symbol' => 'BTC/SGD', 'base' => 'BTC', 'quote' => 'SGD' },
        { 'id' => 'THB', 'symbol' => 'BTC/THB', 'base' => 'BTC', 'quote' => 'THB' },
        { 'id' => 'TRY', 'symbol' => 'BTC/TRY', 'base' => 'BTC', 'quote' => 'TRY' },
        { 'id' => 'ZAR', 'symbol' => 'BTC/ZAR', 'base' => 'BTC', 'quote' => 'ZAR' }
      ]
    end

    def fetch_balance(params = {})
      response = self.privatePostBalancesAndInfo
      balance = response['balances-and-info']
      result = { 'info' => balance }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        account = self.account
        account['free'] = self.safe_float(balance['available'], currency, 0.0)
        account['used'] = self.safe_float(balance['on_hold'], currency, 0.0)
        account['total'] = self.sum(account['free'], account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      response = self.publicGetOrderBook(self.shallow_extend({
        'currency' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(response['order-book'], nil, 'bid', 'ask', 'price', 'order_amount')
    end

    def fetch_ticker(symbol, params = {})
      response = self.publicGetStats(self.shallow_extend({
        'currency' => self.market_id(symbol)
      }, params))
      ticker = response['stats']
      last = self.safe_float(ticker, 'last_price')
      return {
        'symbol' => symbol,
        'timestamp' => nil,
        'datetime' => nil,
        'high' => self.safe_float(ticker, 'max'),
        'low' => self.safe_float(ticker, 'min'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'open'),
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => self.safe_float(ticker, 'daily_change'),
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => nil,
        'quoteVolume' => self.safe_float(ticker, 'total_btc_traded'),
        'info' => ticker
      }
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1d', since = nil, limit = nil)
      return [
        self.parse8601(ohlcv['date'] + ' 00:00:00'),
        nil,
        nil,
        nil,
        parse_float(ohlcv['price']),
        nil
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1d', since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetHistoricalPrices(self.shallow_extend({
        'currency' => market['id'],
        'timeframe' => self.timeframes[timeframe]
      }, params))
      ohlcvs = self.to_array(self.omit(response['historical-prices'], 'request_currency'))
      return self.parse_ohlcvs(ohlcvs, market, timeframe, since, limit)
    end

    def parse_trade(trade, market)
      timestamp = parse_int(trade['timestamp']) * 1000
      return {
        'id' => trade['id'],
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'order' => nil,
        'type' => nil,
        'side' => trade['maker_type'],
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'amount')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      request = {
        'currency' => market['id']
      }
      if limit != nil
        request['limit'] = limit
      end
      response = self.publicGetTransactions(self.shallow_extend(request, params))
      trades = self.to_array(self.omit(response['transactions'], 'request_currency'))
      return self.parse_trades(trades, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      order = {
        'side' => side,
        'type' => type,
        'currency' => self.market_id(symbol),
        'amount' => amount
      }
      if type == 'limit'
        order['limit_price'] = price
      end
      result = self.privatePostOrdersNew(self.shallow_extend(order, params))
      return {
        'info' => result,
        'id' => result
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostOrdersCancel({ 'id' => id })
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'amount' => parse_float(amount),
        'address' => address
      }
      response = self.privatePostWithdrawalsNew(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => response['result']['uuid']
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      if self.id == 'cryptocapital'
        raise(ExchangeError, self.id + ' is an abstract base API for _1btcxe')
      end
      url = self.urls['api'] + '/' + path
      if api == 'public'
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        query = self.shallow_extend({
          'api_key' => self.apiKey,
          'nonce' => self.nonce
        }, params)
        request = self.json(query)
        query['signature'] = self.hmac(self.encode(request), self.encode(self.secret))
        body = self.json(query)
        headers = { 'Content-Type' => 'application/json' }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.is_a?(String)
        if response.include?('Maintenance')
          raise(ExchangeNotAvailable, self.id + ' on maintenance')
        end
      end
      if response.include?('errors')
        errors = []
        for e in (0...response['errors'].length)
          error = response['errors'][e]
          errors.push(error['code'] + ' => ' + error['message'])
        end
        errors = errors.join(' ')
        raise(ExchangeError, self.id + ' ' + errors)
      end
      return response
    end
  end
end
