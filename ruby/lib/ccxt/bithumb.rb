# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bithumb < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bithumb',
        'name' => 'Bithumb',
        'countries' => ['KR'], # South Korea
        'rateLimit' => 500,
        'has' => {
          'CORS' => true,
          'fetchTickers' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg',
          'api' => {
            'public' => 'https://api.bithumb.com/public',
            'private' => 'https://api.bithumb.com'
          },
          'www' => 'https://www.bithumb.com',
          'doc' => 'https://apidocs.bithumb.com'
        },
        'api' => {
          'public' => {
            'get' => [
              'ticker/{currency}',
              'ticker/all',
              'orderbook/{currency}',
              'orderbook/all',
              'transaction_history/{currency}',
              'transaction_history/all'
            ]
          },
          'private' => {
            'post' => [
              'info/account',
              'info/balance',
              'info/wallet_address',
              'info/ticker',
              'info/orders',
              'info/user_transactions',
              'trade/place',
              'info/order_detail',
              'trade/cancel',
              'trade/btc_withdrawal',
              'trade/krw_deposit',
              'trade/krw_withdrawal',
              'trade/market_buy',
              'trade/market_sell'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.15 / 100,
            'taker' => 0.15 / 100
          }
        },
        'exceptions' => {
          'Bad Request(SSL)' => BadRequest,
          'Bad Request(Bad Method)' => BadRequest,
          'Bad Request.(Auth Data)' => AuthenticationError, # { "status" => "5100", "message" => "Bad Request.(Auth Data)" }
          'Not Member' => AuthenticationError,
          'Invalid Apikey' => AuthenticationError, # {"status":"5300","message":"Invalid Apikey"}
          'Method Not Allowed.(Access IP)' => PermissionDenied,
          'Method Not Allowed.(BTC Adress)' => InvalidAddress,
          'Method Not Allowed.(Access)' => PermissionDenied,
          'Database Fail' => ExchangeNotAvailable,
          'Invalid Parameter' => BadRequest,
          '5600' => ExchangeError,
          'Unknown Error' => ExchangeError,
          'After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions' => ExchangeError, # {"status":"5100","message":"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions"}
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetTickerAll
      currencies = markets['data'].keys
      result = []
      for i in (0...currencies.length)
        id = currencies[i]
        if id != 'date'
          market = markets['data'][id]
          base = id
          quote = 'KRW'
          symbol = id + '/' + quote
          active = true
          if market.is_a?(Array)
            numElements = market.length
            if numElements == 0
              active = false
            end
          end
          result.push({
            'id' => id,
            'symbol' => symbol,
            'base' => base,
            'quote' => quote,
            'info' => market,
            'active' => active,
            'precision' => {
              'amount' => nil,
              'price' => nil
            },
            'limits' => {
              'amount' => {
                'min' => nil,
                'max' => nil
              },
              'price' => {
                'min' => nil,
                'max' => nil
              },
              'cost' => {
                'min' => nil,
                'max' => nil
              }
            }
          })
        end
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostInfoBalance(self.shallow_extend({
        'currency' => 'ALL'
      }, params))
      result = { 'info' => response }
      balances = response['data']
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        account = self.account
        lowercase = currency.downcase
        account['total'] = self.safe_float(balances, 'total_' + lowercase)
        account['used'] = self.safe_float(balances, 'in_use_' + lowercase)
        account['free'] = self.safe_float(balances, 'available_' + lowercase)
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'currency' => market['base']
      }
      if limit != nil
        request['count'] = limit
      end # max = 50
      response = self.publicGetOrderbookCurrency(self.shallow_extend(request, params))
      orderbook = response['data']
      timestamp = parse_int(orderbook['timestamp'])
      return self.parse_order_book(orderbook, timestamp, 'bids', 'asks', 'price', 'quantity')
    end

    def parse_ticker(ticker, market = nil)
      timestamp = parse_int(ticker['date'])
      symbol = nil
      if market
        symbol = market['symbol']
      end
      open = self.safe_float(ticker, 'opening_price')
      close = self.safe_float(ticker, 'closing_price')
      change = nil
      percentage = nil
      average = nil
      if (close != nil) && (open != nil)
        change = close - open
        if open > 0
          percentage = change / open * 100
        end
        average = self.sum(open, close) / 2
      end
      vwap = self.safe_float(ticker, 'average_price')
      baseVolume = self.safe_float(ticker, 'volume_1day')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'max_price'),
        'low' => self.safe_float(ticker, 'min_price'),
        'bid' => self.safe_float(ticker, 'buy_price'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell_price'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => open,
        'close' => close,
        'last' => close,
        'previousClose' => nil,
        'change' => change,
        'percentage' => percentage,
        'average' => average,
        'baseVolume' => baseVolume,
        'quoteVolume' => baseVolume * vwap,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetTickerAll(params)
      result = {}
      timestamp = response['data']['date']
      tickers = self.omit(response['data'], 'date')
      ids = tickers.keys
      for i in (0...ids.length)
        id = ids[i]
        symbol = id
        market = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        end
        ticker = tickers[id]
        isArray = ticker.is_a?(Array)
        if !isArray
          ticker['date'] = timestamp
          result[symbol] = self.parse_ticker(ticker, market)
        end
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTickerCurrency(self.shallow_extend({
        'currency' => market['base']
      }, params))
      return self.parse_ticker(response['data'], market)
    end

    def parse_trade(trade, market)
      # a workaround for their bug in date format, hours are not 0-padded
      transaction_date, transaction_time = trade['transaction_date'].split(' ')
      if transaction_time.length < 8
        transaction_time = '0' + transaction_time
      end
      timestamp = self.parse8601(transaction_date + ' ' + transaction_time)
      timestamp -= 9 * 3600000 # they report UTC + 9 hours(Korean timezone.include?(server))
      side = (trade['type'] == 'ask') ? 'sell' : 'buy'
      return {
        'id' => self.safe_string(trade, 'cont_no'),
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'order' => nil,
        'type' => nil,
        'side' => side,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'units_traded')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTransactionHistoryCurrency(self.shallow_extend({
        'currency' => market['base'],
        'count' => 100, # max = 100
      }, params))
      return self.parse_trades(response['data'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = nil
      method = 'privatePostTrade'
      if type == 'limit'
        request = {
          'order_currency' => market['id'],
          'Payment_currency' => market['quote'],
          'units' => amount,
          'price' => price,
          'type' => (side == 'buy') ? 'bid' : 'ask'
        }
        method += 'Place'
      elsif type == 'market'
        request = {
          'currency' => market['id'],
          'units' => amount
        }
        method += 'Market' + self.capitalize(side)
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      id = nil
      if response.include?('order_id')
        if response['order_id']
          id = response['order_id'].to_s
        end
      end
      return {
        'info' => response,
        'id' => id
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      side_in_params = (params.include?('side'))
      if !side_in_params
        raise(ExchangeError, self.id + ' cancelOrder requires a side parameter(sell or buy) and a currency parameter')
      end
      currency = (params.include?('currency'))
      if !currency
        raise(ExchangeError, self.id + ' cancelOrder requires a currency parameter')
      end
      side = (params['side'] == 'buy') ? 'bid' : 'ask'
      return self.privatePostTradeCancel({
        'order_id' => id,
        'type' => side,
        'currency' => params['currency']
      })
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      request = {
        'units' => amount,
        'address' => address,
        'currency' => currency['id']
      }
      if currency == 'XRP' || currency == 'XMR'
        destination = self.safe_string(params, 'destination')
        if (tag.nil?) && (destination.nil?)
          raise(ExchangeError, self.id + ' ' + code + ' withdraw requires a tag argument or an extra destination param')
        elsif tag != nil
          request['destination'] = tag
        end
      end
      response = self.privatePostTradeBtcWithdrawal(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => nil
      }
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      endpoint = '/' + self.implode_params(path, params)
      url = self.urls['api'][api] + endpoint
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        body = self.urlencode(self.shallow_extend({
          'endpoint' => endpoint
        }, query))
        nonce = self.nonce.to_s
        auth = endpoint + "\0" + body + "\0" + nonce # eslint-disable-line quotes
        signature = self.hmac(self.encode(auth), self.encode(self.secret), 'sha512')
        signature64 = self.decode(Base64.encode64(self.encode(signature)))
        headers = {
          'Accept' => 'application/json',
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Api-Key' => self.apiKey,
          'Api-Sign' => signature64.to_s,
          'Api-Nonce' => nonce
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        if response.include?('status')
          #
          #     {"status":"5100","message":"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions"}
          #
          status = self.safe_string(response, 'status')
          message = self.safe_string(response, 'message')
          if status != nil
            if status == '0000'
              return
            end # no error
            feedback = self.id + ' ' + self.json(response)
            exceptions = self.exceptions
            if exceptions.include?(status)
              raise(exceptions[status], feedback)
            elsif exceptions.include?(message)
              raise(exceptions[message], feedback)
            else
              raise(ExchangeError, feedback)
            end
          end
        end
      end
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('status')
        if response['status'] == '0000'
          return response
        end
        raise(ExchangeError, self.id + ' ' + self.json(response))
      end
      return response
    end
  end
end
