# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

require_relative 'liqui'

module Ccxt
  class Dsx < Liqui
    def describe
      return self.deep_extend(super, {
        'id' => 'dsx',
        'name' => 'DSX',
        'countries' => ['UK'],
        'rateLimit' => 1500,
        'version' => 'v2',
        'has' => {
          'CORS' => false,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => false,
          'fetchOrderBooks' => false,
          'createDepositAddress' => true,
          'fetchDepositAddress' => true,
          'fetchTransactions' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27990275-1413158a-645a-11e7-931c-94717f7510e3.jpg',
          'api' => {
            'public' => 'https://dsx.uk/mapi', # market data
            'private' => 'https://dsx.uk/tapi', # trading
            'dwapi' => 'https://dsx.uk/dwapi', # deposit/withdraw
          },
          'www' => 'https://dsx.uk',
          'doc' => [
            'https://api.dsx.uk',
            'https://dsx.uk/api_docs/public',
            'https://dsx.uk/api_docs/private',
            ''
          ]
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'percentage' => true,
            'maker' => 0.15 / 100,
            'taker' => 0.25 / 100
          }
        },
        'api' => {
          # market data(public)
          'public' => {
            'get' => [
              'barsFromMoment/{id}/{period}/{start}', # empty reply :\
              'depth/{pair}',
              'info',
              'lastBars/{id}/{period}/{amount}', # period is(m, h or d)
              'periodBars/{id}/{period}/{start}/{end}',
              'ticker/{pair}',
              'trades/{pair}'
            ]
          },
          # trading(private)
          'private' => {
            'post' => [
              'info/account',
              'history/transactions',
              'history/trades',
              'history/orders',
              'orders',
              'order/cancel',
              'order/cancel/all',
              'order/status',
              'order/new',
              'volume',
              'fees', # trading fee schedule
            ]
          },
          # deposit / withdraw(private)
          'dwapi' => {
            'post' => [
              'deposit/cryptoaddress',
              'withdraw/crypto',
              'withdraw/fiat',
              'withdraw/submit',
              'withdraw/cancel',
              'transaction/status', # see 'history/transactions' in private tapi above
            ]
          }
        },
        'exceptions' => {
          'exact' => {
            "Order wasn't cancelled" => InvalidOrder, # non-existent order
          }
        },
        'options' => {
          'fetchOrderMethod' => 'privatePostOrderStatus',
          'fetchMyTradesMethod' => 'privatePostHistoryTrades',
          'cancelOrderMethod' => 'privatePostOrderCancel',
          'fetchTickersMaxLength' => 250
        }
      })
    end

    def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      currency = nil
      request = {}
      if code != nil
        currency = self.currency(code)
        request['currency'] = currency['id']
      end
      if since != nil
        request['since'] = since
      end
      if limit != nil
        request['count'] = limit
      end
      response = self.privatePostHistoryTransactions(self.shallow_extend(request, params))
      #
      #     {
      #         "success" => 1,
      #         "return" => [
      #             {
      #                 "id" => 1,
      #                 "timestamp" => 11,
      #                 "type" => "Withdraw",
      #                 "amount" => 1,
      #                 "currency" => "btc",
      #                 "confirmationsCount" => 6,
      #                 "address" => "address",
      #                 "status" => 2,
      #                 "commission" => 0.0001
      #             }
      #         ]
      #     }
      #
      transactions = self.safe_value(response, 'return', [])
      return self.parseTransactions(transactions, currency, since, limit)
    end

    def parse_transaction_status(status)
      statuses = {
        '1' => 'failed',
        '2' => 'ok',
        '3' => 'pending',
        '4' => 'failed'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction(transaction, currency = nil)
      #
      #     {
      #         "id" => 1,
      #         "timestamp" => 11, # 11 in their docs(
      #         "type" => "Withdraw",
      #         "amount" => 1,
      #         "currency" => "btc",
      #         "confirmationsCount" => 6,
      #         "address" => "address",
      #         "status" => 2,
      #         "commission" => 0.0001
      #     }
      #
      timestamp = self.safe_integer(transaction, 'timestamp')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      type = self.safe_string(transaction, 'type')
      if type != nil
        if type == 'Incoming'
          type = 'deposit'
        elsif type == 'Withdraw'
          type = 'withdrawal'
        end
      end
      currencyId = self.safe_string(transaction, 'currency')
      code = nil
      if self.currencies_by_id.include?(currencyId)
        ccy = self.currencies_by_id[currencyId]
        code = ccy['code']
      else
        code = self.common_currency_code(currencyId)
      end
      status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
      return {
        'id' => self.safe_string(transaction, 'id'),
        'txid' => self.safe_string(transaction, 'txid'),
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => self.safe_string(transaction, 'address'),
        'type' => type,
        'amount' => self.safe_float(transaction, 'amount'),
        'currency' => code,
        'status' => status,
        'fee' => {
          'currency' => code,
          'cost' => self.safe_float(transaction, 'commission'),
          'rate' => nil
        },
        'info' => transaction
      }
    end

    def fetch_markets(params = {})
      response = self.publicGetInfo
      markets = response['pairs']
      keys = markets.keys
      result = []
      for i in (0...keys.length)
        id = keys[i]
        market = markets[id]
        baseId = self.safe_string(market, 'base_currency')
        quoteId = self.safe_string(market, 'quoted_currency')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => self.safe_integer(market, 'decimal_places'),
          'price' => self.safe_integer(market, 'decimal_places')
        }
        amountLimits = {
          'min' => self.safe_float(market, 'min_amount'),
          'max' => self.safe_float(market, 'max_amount')
        }
        priceLimits = {
          'min' => self.safe_float(market, 'min_price'),
          'max' => self.safe_float(market, 'max_price')
        }
        costLimits = {
          'min' => self.safe_float(market, 'min_total')
        }
        limits = {
          'amount' => amountLimits,
          'price' => priceLimits,
          'cost' => costLimits
        }
        hidden = self.safe_integer(market, 'hidden')
        active = (hidden == 0)
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'precision' => precision,
          'limits' => limits,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostInfoAccount
      #
      #     {
      #       "success" : 1,
      #       "return" : {
      #         "funds" : {
      #           "BTC" : {
      #             "total" : 0,
      #             "available" : 0
      #           },
      #           "USD" : {
      #             "total" : 0,
      #             "available" : 0
      #           },
      #           "USDT" : {
      #             "total" : 0,
      #             "available" : 0
      #           }
      #         },
      #         "rights" : {
      #           "info" : 1,
      #           "trade" : 1
      #         },
      #         "transactionCount" : 0,
      #         "openOrders" : 0,
      #         "serverTime" : 1537451465
      #       }
      #     }
      #
      balances = response['return']
      result = { 'info' => balances }
      funds = balances['funds']
      ids = funds.keys
      for c in (0...ids.length)
        id = ids[c]
        code = self.common_currency_code(id)
        account = {
          'free' => funds[id]['available'],
          'used' => 0.0,
          'total' => funds[id]['total']
        }
        account['used'] = account['total'] - account['free']
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def create_deposit_address(code, params = {})
      request = {
        'new' => 1
      }
      response = self.fetch_deposit_address(code, self.shallow_extend(request, params))
      return response
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = self.dwapiPostDepositCryptoaddress(self.shallow_extend(request, params))
      result = self.safe_value(response, 'return', {})
      address = self.safe_string(result, 'address')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => nil, # not documented in DSX API
        'info' => response
      }
    end

    def parse_ticker(ticker, market = nil)
      #
      #   {    high =>  0.03492,
      #         low =>  0.03245,
      #         avg =>  29.46133,
      #         vol =>  500.8661,
      #     vol_cur =>  17.000797104,
      #        last =>  0.03364,
      #         buy =>  0.03362,
      #        sell =>  0.03381,
      #     updated =>  1537521993,
      #        pair => "ethbtc"       }
      #
      timestamp = ticker['updated'] * 1000
      symbol = nil
      # dsx has 'pair' in the ticker, liqui does not have it
      marketId = self.safe_string(ticker, 'pair')
      market = self.safe_value(self.markets_by_id, marketId, market)
      if market != nil
        symbol = market['symbol']
      end
      # dsx average is inverted, liqui average is not
      average = self.safe_float(ticker, 'avg')
      if average != nil
        if average > 0
          average = 1 / average
        end
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => average,
        'baseVolume' => self.safe_float(ticker, 'vol'), # dsx shows baseVolume in 'vol', liqui shows baseVolume in 'vol_cur'
        'quoteVolume' => self.safe_float(ticker, 'vol_cur'), # dsx shows baseVolume in 'vol_cur', liqui shows baseVolume in 'vol'
        'info' => ticker
      }
    end

    def sign_body_with_secret(body)
      return self.decode(self.hmac(self.encode(body), self.encode(self.secret), 'sha512', 'base64'))
    end

    def get_version_string
      return ''
    end

    def get_private_path(path, params)
      return '/' + self.version + '/' + self.implode_params(path, params)
    end

    def get_order_id_key
      return 'orderId'
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      if type == 'market' && price.nil?
        raise(ArgumentsRequired, self.id + ' createOrder requires a price argument even for market orders, that is the worst price that you agree to fill your order for')
      end
      request = {
        'pair' => market['id'],
        'type' => side,
        'volume' => self.amount_to_precision(symbol, amount),
        'rate' => self.price_to_precision(symbol, price),
        'orderType' => type
      }
      price = parse_float(price)
      amount = parse_float(amount)
      response = self.privatePostOrderNew(self.shallow_extend(request, params))
      #
      #     {
      #       "success" => 1,
      #       "return" => {
      #         "received" => 0,
      #         "remains" => 10,
      #         "funds" => {
      #           "BTC" => {
      #             "total" => 100,
      #             "available" => 95
      #           },
      #           "USD" => {
      #             "total" => 10000,
      #             "available" => 9995
      #           },
      #           "EUR" => {
      #             "total" => 1000,
      #             "available" => 995
      #           },
      #           "LTC" => {
      #             "total" => 1000,
      #             "available" => 995
      #           }
      #         },
      #         "orderId" => 0, # https://github.com/ccxt/ccxt/issues/3677
      #       }
      #     }
      #
      status = 'open'
      filled = 0.0
      remaining = amount
      responseReturn = self.safe_value(response, 'return')
      id = self.safe_string_2(responseReturn, 'orderId', 'order_id')
      if id == '0'
        id = self.safe_string(responseReturn, 'initOrderId', 'init_order_id')
        status = 'closed'
      end
      filled = self.safe_float(responseReturn, 'received', 0.0)
      remaining = self.safe_float(responseReturn, 'remains', amount)
      timestamp = self.milliseconds
      return {
        'info' => response,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => price * filled,
        'amount' => amount,
        'remaining' => remaining,
        'filled' => filled,
        'fee' => nil,
        # 'trades' => self.parse_trades(order['trades'], market)
      }
    end

    def parse_order_status(status)
      statuses = {
        '0' => 'open', # Active
        '1' => 'closed', # Filled
        '2' => 'canceled', # Killed
        '3' => 'canceling', # Killing
        '7' => 'canceled', # Rejected
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #     {
      #         "amount" : 0.0128,
      #         "price" : 6483.99000,
      #         "timestamp" : 1540334614,
      #         "tid" : 35684364,
      #         "type" : "ask"
      #     }
      #
      # fetchMyTrades(private)
      #
      #     {
      #         "number" => "36635882", # <-- self is present if the trade has come from the '/order/status' call
      #         "id" => "36635882", # <-- self may have been artifically added by the parseTrades method
      #         "pair" => "btcusd",
      #         "type" => "buy",
      #         "volume" => 0.0595,
      #         "rate" => 9750,
      #         "orderId" => 77149299,
      #         "timestamp" => 1519612317,
      #         "commission" => 0.00020825,
      #         "commissionCurrency" => "btc"
      #     }
      #
      timestamp = self.safe_integer(trade, 'timestamp')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      side = self.safe_string(trade, 'type')
      if side == 'ask'
        side = 'sell'
      elsif side == 'bid'
        side = 'buy'
      end
      price = self.safe_float_2(trade, 'rate', 'price')
      id = self.safe_string_2(trade, 'number', 'id')
      orderId = self.safe_string(trade, 'orderId')
      if trade.include?('pair')
        marketId = self.safe_string(trade, 'pair')
        market = self.safe_value(self.markets_by_id, marketId, market)
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      amount = self.safe_float_2(trade, 'amount', 'volume')
      type = 'limit' # all trades are still limit trades
      takerOrMaker = nil
      fee = nil
      feeCost = self.safe_float(trade, 'commission')
      if feeCost != nil
        feeCurrencyId = self.safe_string(trade, 'commissionCurrency')
        feeCurrencyId = feeCurrencyId.upcase
        feeCurrency = self.safe_value(self.currencies_by_id, feeCurrencyId)
        feeCurrencyCode = nil
        if feeCurrency != nil
          feeCurrencyCode = feeCurrency['code']
        else
          feeCurrencyCode = self.common_currency_code(feeCurrencyId)
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrencyCode
        }
      end
      isYourOrder = self.safe_value(trade, 'is_your_order')
      if isYourOrder != nil
        takerOrMaker = 'taker'
        if isYourOrder
          takerOrMaker = 'maker'
        end
        if fee.nil?
          fee = self.calculate_fee(symbol, type, side, amount, price, takerOrMaker)
        end
      end
      cost = nil
      if price != nil
        if amount != nil
          cost = price * amount
        end
      end
      return {
        'id' => id,
        'order' => orderId,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'takerOrMaker' => takerOrMaker,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee,
        'info' => trade
      }
    end

    def parse_order(order, market = nil)
      #
      # fetchOrder
      #
      #   {
      #     "number" => 36635882,
      #     "pair" => "btcusd",
      #     "type" => "buy",
      #     "remainingVolume" => 10,
      #     "volume" => 10,
      #     "rate" => 1000.0,
      #     "timestampCreated" => 1496670,
      #     "status" => 0,
      #     "orderType" => "limit",
      #     "deals" => [
      #       {
      #         "pair" => "btcusd",
      #         "type" => "buy",
      #         "amount" => 1,
      #         "rate" => 1000.0,
      #         "orderId" => 1,
      #         "timestamp" => 1496672724,
      #         "commission" => 0.001,
      #         "commissionCurrency" => "btc"
      #       }
      #     ]
      #   }
      #
      id = self.safe_string(order, 'id')
      status = self.parse_order_status(self.safe_string(order, 'status'))
      timestamp = self.safe_integer(order, 'timestampCreated')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      marketId = self.safe_string(order, 'pair')
      market = self.safe_value(self.markets_by_id, marketId, market)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      remaining = self.safe_float(order, 'remainingVolume')
      amount = self.safe_float(order, 'volume')
      price = self.safe_float(order, 'rate')
      filled = nil
      cost = nil
      if amount != nil
        if remaining != nil
          filled = amount - remaining
          cost = price * filled
        end
      end
      orderType = self.safe_string(order, 'orderType')
      side = self.safe_string(order, 'type')
      fee = nil
      deals = self.safe_value(order, 'deals', [])
      numDeals = deals.length
      trades = nil
      lastTradeTimestamp = nil
      if numDeals > 0
        trades = self.parse_trades(deals)
        feeCost = nil
        feeCurrency = nil
        for i in (0...trades.length)
          trade = trades[i]
          if feeCost.nil?
            feeCost = 0
          end
          feeCost += trade['fee']['cost']
          feeCurrency = trade['fee']['currency']
          lastTradeTimestamp = trade['timestamp']
        end
        if feeCost != nil
          fee = {
            'cost' => feeCost,
            'currency' => feeCurrency
          }
        end
      end
      return {
        'info' => order,
        'id' => id,
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'type' => orderType,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'remaining' => remaining,
        'filled' => filled,
        'status' => status,
        'fee' => fee,
        'trades' => trades
      }
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'orderId' => parse_int(id)
      }
      response = self.privatePostOrderStatus(self.shallow_extend(request, params))
      #
      #     {
      #       "success" => 1,
      #       "return" => {
      #         "pair" => "btcusd",
      #         "type" => "buy",
      #         "remainingVolume" => 10,
      #         "volume" => 10,
      #         "rate" => 1000.0,
      #         "timestampCreated" => 1496670,
      #         "status" => 0,
      #         "orderType" => "limit",
      #         "deals" => [
      #           {
      #             "pair" => "btcusd",
      #             "type" => "buy",
      #             "amount" => 1,
      #             "rate" => 1000.0,
      #             "orderId" => 1,
      #             "timestamp" => 1496672724,
      #             "commission" => 0.001,
      #             "commissionCurrency" => "btc"
      #           }
      #         ]
      #       }
      #     }
      #
      return self.parse_order(self.shallow_extend({
        'id' => id
      }, response['return']))
    end

    def parse_orders_by_id(orders, symbol = nil, since = nil, limit = nil)
      ids = orders.keys
      result = []
      for i in (0...ids.length)
        id = ids[i]
        order = self.parse_order(self.shallow_extend({
          'id' => id.to_s
        }, orders[id]))
        result.push(order)
      end
      return self.filter_by_symbol_since_limit(result, symbol, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {
        # 'count' => 10, # Decimal, The maximum number of orders to return
        # 'fromId' => 123, # Decimal, ID of the first order of the selection
        # 'endId' => 321, # Decimal, ID of the last order of the selection
        # 'order' => 'ASC', # String, Order in which orders shown. Possible values are "ASC" — from first to last, "DESC" — from last to first.
      }
      response = self.privatePostOrders(self.shallow_extend(request, params))
      #
      #     {
      #       "success" => 1,
      #       "return" => {
      #         "0" => {
      #           "pair" => "btcusd",
      #           "type" => "buy",
      #           "remainingVolume" => 10,
      #           "volume" => 10,
      #           "rate" => 1000.0,
      #           "timestampCreated" => 1496670,
      #           "status" => 0,
      #           "orderType" => "limit"
      #         }
      #       }
      #     }
      #
      return self.parse_orders_by_id(self.safe_value(response, 'return', {}), symbol, since, limit)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {
        # 'count' => 10, # Decimal, The maximum number of orders to return
        # 'fromId' => 123, # Decimal, ID of the first order of the selection
        # 'endId' => 321, # Decimal, ID of the last order of the selection
        # 'order' => 'ASC', # String, Order in which orders shown. Possible values are "ASC" — from first to last, "DESC" — from last to first.
      }
      response = self.privatePostHistoryOrders(self.shallow_extend(request, params))
      #
      #     {
      #       "success" => 1,
      #       "return" => {
      #         "0" => {
      #           "pair" => "btcusd",
      #           "type" => "buy",
      #           "remainingVolume" => 10,
      #           "volume" => 10,
      #           "rate" => 1000.0,
      #           "timestampCreated" => 1496670,
      #           "status" => 0,
      #           "orderType" => "limit"
      #         }
      #       }
      #     }
      #
      return self.parse_orders_by_id(self.safe_value(response, 'return', {}), symbol, since, limit)
    end

    def parse_trades(trades, market = nil, since = nil, limit = nil)
      result = []
      if trades.is_a?(Array)
        for i in (0...trades.length)
          result.push(self.parse_trade(trades[i], market))
        end
      else
        ids = trades.keys
        for i in (0...ids.length)
          id = ids[i]
          trade = self.parse_trade(trades[id], market)
          result.push(self.shallow_extend(trade, { 'id' => id }))
        end
      end
      result = self.sort_by(result, 'timestamp')
      symbol = (market != nil) ? market['symbol'] : nil
      return self.filter_by_symbol_since_limit(result, symbol, since, limit)
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api]
      query = self.omit(params, self.extract_params(path))
      if api == 'private' || api == 'dwapi'
        url += self.get_private_path(path, params)
        self.check_required_credentials
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({
          'nonce' => nonce,
          'method' => path
        }, query))
        signature = self.sign_body_with_secret(body)
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Key' => self.apiKey,
          'Sign' => signature
        }
      elsif api == 'public'
        url += self.get_version_string + '/' + self.implode_params(path, params)
        if query
          url += '?' + self.urlencode(query)
        end
      else
        url += '/' + self.implode_params(path, params)
        if method == 'GET'
          if query
            url += '?' + self.urlencode(query)
          end
        else
          if query
            body = self.json(query)
            headers = {
              'Content-Type' => 'application/json'
            }
          end
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
