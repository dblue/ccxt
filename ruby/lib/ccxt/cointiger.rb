# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

require_relative 'huobipro'

module Ccxt
  class Cointiger < Huobipro
    def describe
      return self.deep_extend(super, {
        'id' => 'cointiger',
        'name' => 'CoinTiger',
        'countries' => ['CN'],
        'hostname' => 'cointiger.pro',
        'has' => {
          'fetchCurrencies' => false,
          'fetchTickers' => true,
          'fetchTradingLimits' => false,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchOrderTrades' => false, # not tested yet
          'cancelOrders' => true
        },
        'headers' => {
          'Language' => 'en_US'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/39797261-d58df196-5363-11e8-9880-2ec78ec5bd25.jpg',
          'api' => {
            'public' => 'https://api.{hostname}/exchange/trading/api/market',
            'private' => 'https://api.{hostname}/exchange/trading/api',
            'exchange' => 'https://www.{hostname}/exchange',
            'v2public' => 'https://api.{hostname}/exchange/trading/api/v2',
            'v2' => 'https://api.{hostname}/exchange/trading/api/v2'
          },
          'www' => 'https://www.cointiger.pro',
          'referral' => 'https://www.cointiger.pro/exchange/register.html?refCode=FfvDtt',
          'doc' => 'https://github.com/cointiger/api-docs-en/wiki'
        },
        'api' => {
          'v2public' => {
            'get' => [
              'timestamp',
              'currencys'
            ]
          },
          'v2' => {
            'get' => [
              'order/orders',
              'order/match_results',
              'order/make_detail',
              'order/details'
            ],
            'post' => [
              'order',
              'order/batch_cancel'
            ]
          },
          'public' => {
            'get' => [
              'history/kline', # 获取K线数据
              'detail/merged', # 获取聚合行情(Ticker)
              'depth', # 获取 Market Depth 数据
              'trade', # 获取 Trade Detail 数据
              'history/trade', # 批量获取最近的交易记录
              'detail', # 获取 Market Detail 24小时成交量数据
            ]
          },
          'exchange' => {
            'get' => [
              'footer/tradingrule.html',
              'api/public/market/detail'
            ]
          },
          'private' => {
            'get' => [
              'user/balance',
              'order/new',
              'order/history',
              'order/trade'
            ],
            'post' => [
              'order'
            ],
            'delete' => [
              'order'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.0008,
            'taker' => 0.0015
          }
        },
        'exceptions' => {
          #    {"code":"1","msg":"系统错误","data":null}
          #    {"code":"1","msg":"Balance insufficient,余额不足","data":null}
          '1' => ExchangeError,
          '2' => BadRequest, # {"code":"2","msg":"Parameter error","data":null}
          '5' => InvalidOrder,
          '6' => InvalidOrder,
          '8' => OrderNotFound,
          '16' => AuthenticationError, # funding password not set
          '100001' => ExchangeError,
          '100002' => ExchangeNotAvailable,
          '100003' => ExchangeError,
          '100005' => AuthenticationError,
          '110030' => DDoSProtection
        },
        'commonCurrencies' => {
          'FGC' => 'FoundGameCoin',
          'TCT' => 'The Tycoon Chain Token'
        }
      })
    end

    def fetch_markets(params = {})
      response = self.v2publicGetCurrencys
      #
      #     {
      #         code => '0',
      #         msg => 'suc',
      #         data => {
      #             'bitcny-partition' => [
      #                 {
      #                     baseCurrency => 'btc',
      #                     quoteCurrency => 'bitcny',
      #                     pricePrecision => 2,
      #                     amountPrecision => 4,
      #                     withdrawFeeMin => 0.0005,
      #                     withdrawFeeMax => 0.005,
      #                     withdrawOneMin => 0.01,
      #                     withdrawOneMax => 10,
      #                     depthSelect => { step0 => '0.01', step1 => '0.1', step2 => '1' }
      #                 },
      #                 ...
      #             ],
      #             ...
      #         },
      #     }
      #
      keys = response['data'].keys
      result = []
      for i in (0...keys.length)
        key = keys[i]
        partition = response['data'][key]
        for j in (0...partition.length)
          market = partition[j]
          baseId = self.safe_string(market, 'baseCurrency')
          quoteId = self.safe_string(market, 'quoteCurrency')
          base = baseId.upcase
          quote = quoteId.upcase
          base = self.common_currency_code(base)
          quote = self.common_currency_code(quote)
          id = baseId + quoteId
          uppercaseId = id.upcase
          symbol = base + '/' + quote
          precision = {
            'amount' => market['amountPrecision'],
            'price' => market['pricePrecision']
          }
          active = true
          entry = {
            'id' => id,
            'uppercaseId' => uppercaseId,
            'symbol' => symbol,
            'base' => base,
            'quote' => quote,
            'baseId' => baseId,
            'quoteId' => quoteId,
            'info' => market,
            'active' => active,
            'precision' => precision,
            'limits' => {
              'amount' => {
                'min' => 10**-precision['amount'],
                'max' => nil
              },
              'price' => {
                'min' => 10**-precision['price'],
                'max' => nil
              },
              'cost' => {
                'min' => 0,
                'max' => nil
              }
            }
          }
          result.push(entry)
        end
      end
      self.options['marketsByUppercaseId'] = self.index_by(result, 'uppercaseId')
      return result
    end

    def parse_ticker(ticker, market = nil)
      symbol = nil
      if market
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(ticker, 'id')
      close = self.safe_float(ticker, 'last')
      percentage = self.safe_float(ticker, 'percentChange')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high24hr'),
        'low' => self.safe_float(ticker, 'low24hr'),
        'bid' => self.safe_float(ticker, 'highestBid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'lowestAsk'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => close,
        'last' => close,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => percentage,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'baseVolume'),
        'quoteVolume' => self.safe_float(ticker, 'quoteVolume'),
        'info' => ticker
      }
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetDepth(self.shallow_extend({
        'symbol' => market['id'], # self endpoint requires a lowercase market id
        'type' => 'step0'
      }, params))
      data = response['data']['depth_data']
      if data.include?('tick')
        if !data['tick']
          raise(ExchangeError, self.id + ' fetchOrderBook returned empty response => ' + self.json(response))
        end
        orderbook = data['tick']
        timestamp = data['ts']
        return self.parse_order_book(orderbook, timestamp, 'buys')
      end
      raise(ExchangeError, self.id + ' fetchOrderBook returned unrecognized response => ' + self.json(response))
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      marketId = market['uppercaseId']
      response = self.exchangeGetApiPublicMarketDetail(params)
      if response.include?(!(marketId))
        raise(ExchangeError, self.id + ' fetchTicker symbol ' + symbol + '(' + marketId + ') not found')
      end
      return self.parse_ticker(response[marketId], market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.exchangeGetApiPublicMarketDetail(params)
      result = {}
      ids = response.keys
      for i in (0...ids.length)
        id = ids[i]
        market = nil
        symbol = id
        if self.options['marketsByUppercaseId'].include?(id)
          # self endpoint returns uppercase ids
          symbol = self.options['marketsByUppercaseId'][id]['symbol']
          market = self.options['marketsByUppercaseId'][id]
        end
        result[symbol] = self.parse_ticker(response[id], market)
      end
      return result
    end

    def parse_trade(trade, market = nil)
      #
      #   {      volume => "0.014",
      #          symbol => "ethbtc",
      #         buy_fee => "0.00001400",
      #         orderId =>  32235710,
      #           price => "0.06923825",
      #         created =>  1531605169000,
      #              id =>  3785005,
      #          source =>  1,
      #            type => "buy-limit",
      #     bid_user_id =>  326317         }] }
      #
      # --------------------------------------------------------------------
      #
      #     {
      #         "volume" => {
      #             "amount" => "1.000",
      #             "icon" => "",
      #             "title" => "成交量"
      #                   },
      #         "price" => {
      #             "amount" => "0.04978883",
      #             "icon" => "",
      #             "title" => "委托价格"
      #                  },
      #         "created_at" => 1513245134000,
      #         "deal_price" => {
      #             "amount" => 0.04978883000000000000000000000000,
      #             "icon" => "",
      #             "title" => "成交价格"
      #                       },
      #         "id" => 138
      #     }
      #
      id = self.safe_string(trade, 'id')
      orderId = self.safe_string(trade, 'orderId')
      orderType = self.safe_string(trade, 'type')
      type = nil
      side = nil
      if orderType != nil
        parts = orderType.split('-')
        side = parts[0]
        type = parts[1]
      end
      side = self.safe_string(trade, 'side', side)
      amount = nil
      price = nil
      cost = nil
      if side.nil?
        price = self.safe_float(trade['price'], 'amount')
        amount = self.safe_float(trade['volume'], 'amount')
        cost = self.safe_float(trade['deal_price'], 'amount')
      else
        side = side.downcase
        price = self.safe_float(trade, 'price')
        amount = self.safe_float_2(trade, 'amount', 'volume')
      end
      fee = nil
      feeCost = self.safe_float(trade, 'fee')
      if feeCost != nil
        feeCurrency = nil
        if market != nil
          if side == 'buy'
            feeCurrency = market['base']
          elsif side == 'sell'
            feeCurrency = market['quote']
          end
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      if amount != nil
        if price != nil
          if cost.nil?
            cost = amount * price
          end
        end
      end
      timestamp = self.safe_integer_2(trade, 'created_at', 'ts')
      timestamp = self.safe_integer_2(trade, 'created', 'mtime', timestamp)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      return {
        'info' => trade,
        'id' => id,
        'order' => orderId,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = 1000, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id']
      }
      if limit != nil
        request['size'] = limit
      end
      response = self.publicGetHistoryTrade(self.shallow_extend(request, params))
      return self.parse_trades(response['data']['trade_data'], market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      if limit.nil?
        limit = 100
      end
      response = self.privateGetOrderTrade(self.shallow_extend({
        'symbol' => market['id'],
        'offset' => 1,
        'limit' => limit
      }, params))
      return self.parse_trades(response['data']['list'], market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv['id'] * 1000,
        ohlcv['open'],
        ohlcv['high'],
        ohlcv['low'],
        ohlcv['close'],
        ohlcv['vol']
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = 1000, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'period' => self.timeframes[timeframe]
      }
      if limit != nil
        request['size'] = limit
      end
      response = self.publicGetHistoryKline(self.shallow_extend(request, params))
      return self.parse_ohlcvs(response['data']['kline_data'], market, timeframe, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetUserBalance(params)
      #
      #     {
      #         "code" => "0",
      #         "msg" => "suc",
      #         "data" => [{
      #             "normal" => "1813.01144179",
      #             "lock" => "1325.42036785",
      #             "coin" => "btc"
      #         }, {
      #             "normal" => "9551.96692244",
      #             "lock" => "547.06506717",
      #             "coin" => "eth"
      #         }]
      #     }
      #
      balances = response['data']
      result = { 'info' => response }
      for i in (0...balances.length)
        balance = balances[i]
        id = balance['coin']
        code = id.upcase
        code = self.common_currency_code(code)
        if self.currencies_by_id.include?(id)
          code = self.currencies_by_id[id]['code']
        end
        account = self.account
        account['used'] = parse_float(balance['lock'])
        account['free'] = parse_float(balance['normal'])
        account['total'] = self.sum(account['used'], account['free'])
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_trades(id, symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrderTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'order_id' => id
      }
      response = self.v2GetOrderMakeDetail(self.shallow_extend(request, params))
      #
      # the above endpoint often returns an empty array
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => [{      volume => "0.014",
      #                      symbol => "ethbtc",
      #                     buy_fee => "0.00001400",
      #                     orderId =>  32235710,
      #                       price => "0.06923825",
      #                     created =>  1531605169000,
      #                          id =>  3785005,
      #                      source =>  1,
      #                        type => "buy-limit",
      #                 bid_user_id =>  326317         }] }
      #
      return self.parse_trades(response['data'], market, since, limit)
    end

    def fetch_orders_by_status_v1(status = nil, symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrders requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      if limit.nil?
        limit = 100
      end
      method = (status == 'open') ? 'privateGetOrderNew' : 'privateGetOrderHistory'
      response = self.send_wrapper(method, self.shallow_extend({
        'symbol' => market['id'],
        'offset' => 1,
        'limit' => limit
      }, params))
      orders = response['data']['list']
      result = []
      for i in (0...orders.length)
        order = self.shallow_extend(orders[i], {
          'status' => status
        })
        result.push(self.parse_order(order, market))
      end
      return result
    end

    def fetch_open_orders_v1(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_status_v1('open', symbol, since, limit, params)
    end

    def fetch_orders_v1(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_status_v1(nil, symbol, since, limit, params)
    end

    def fetch_orders_by_states_v2(states, symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrders requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      if limit.nil?
        limit = 50
      end
      response = self.v2GetOrderOrders(self.shallow_extend({
        'symbol' => market['id'],
        # 'types' => 'buy-market,sell-market,buy-limit,sell-limit',
        'states' => states, # 'new,part_filled,filled,canceled,expired'
        # 'from' => '0', # id
        'direct' => 'next', # or 'prev'
        'size' => limit
      }, params))
      return self.parse_orders(response['data'], market, since, limit)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_states_v2('new,part_filled,filled,canceled,expired', symbol, since, limit, params)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_states_v2('new,part_filled', symbol, since, limit, params)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_states_v2('filled,canceled', symbol, since, limit, params)
    end

    def fetch_order(id, symbol = nil, params = {})
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => {      symbol => "ethbtc",
      #                       fee => "0.00000200",
      #                 avg_price => "0.06863752",
      #                    source =>  1,
      #                      type => "buy-limit",
      #                     mtime =>  1531340305000,
      #                    volume => "0.002",
      #                   user_id =>  326317,
      #                     price => "0.06863752",
      #                     ctime =>  1531340304000,
      #               deal_volume => "0.00200000",
      #                        id =>  31920243,
      #                deal_money => "0.00013727",
      #                    status =>  2              } }
      #
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'order_id' => id.to_s
      }
      response = self.v2GetOrderDetails(self.shallow_extend(request, params))
      return self.parse_order(response['data'], market)
    end

    def parse_order_status(status)
      statuses = {
        '0' => 'open', # pending
        '1' => 'open',
        '2' => 'closed',
        '3' => 'open',
        '4' => 'canceled',
        '6' => 'error'
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      #
      #  v1
      #
      #      {
      #            volume => { "amount" => "0.054", "icon" => "", "title" => "volume" },
      #         age_price => { "amount" => "0.08377697", "icon" => "", "title" => "Avg price" },
      #              side => "BUY",
      #             price => { "amount" => "0.00000000", "icon" => "", "title" => "price" },
      #        created_at => 1525569480000,
      #       deal_volume => { "amount" => "0.64593598", "icon" => "", "title" => "Deal volume" },
      #   "remain_volume" => { "amount" => "1.00000000", "icon" => "", "title" => "尚未成交"
      #                id => 26834207,
      #             label => { go => "trade", title => "Traded", click => 1 },
      #          side_msg => "Buy"
      #      },
      #
      #  v2
      #
      #     { code =>   "0",
      #        msg =>   "suc",
      #       data => {      symbol => "ethbtc",
      #                       fee => "0.00000200",
      #                 avg_price => "0.06863752",
      #                    source =>  1,
      #                      type => "buy-limit",
      #                     mtime =>  1531340305000,
      #                    volume => "0.002",
      #                   user_id =>  326317,
      #                     price => "0.06863752",
      #                     ctime =>  1531340304000,
      #               deal_volume => "0.00200000",
      #                        id =>  31920243,
      #                deal_money => "0.00013727",
      #                    status =>  2              } }
      #
      id = self.safe_string(order, 'id')
      side = self.safe_string(order, 'side')
      type = nil
      orderType = self.safe_string(order, 'type')
      status = self.parse_order_status(self.safe_string(order, 'status'))
      timestamp = self.safe_integer_2(order, 'created_at', 'ctime')
      lastTradeTimestamp = self.safe_integer_2(order, 'mtime', 'finished-at')
      symbol = nil
      if market.nil?
        marketId = self.safe_string(order, 'symbol')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      remaining = nil
      amount = nil
      filled = nil
      price = nil
      cost = nil
      fee = nil
      average = nil
      if side != nil
        side = side.downcase
        amount = self.safe_float(order['volume'], 'amount')
        remaining = (order.include?('remain_volume')) ? self.safe_float(order['remain_volume'], 'amount') : nil
        filled = (order.include?('deal_volume')) ? self.safe_float(order['deal_volume'], 'amount') : nil
        price = (order.include?('price')) ? self.safe_float(order['price'], 'amount') : nil
        average = (order.include?('age_price')) ? self.safe_float(order['age_price'], 'amount') : nil
      else
        if orderType != nil
          parts = orderType.split('-')
          side = parts[0]
          type = parts[1]
          cost = self.safe_float(order, 'deal_money')
          price = self.safe_float(order, 'price')
          average = self.safe_float(order, 'avg_price')
          amount = self.safe_float_2(order, 'amount', 'volume')
          filled = self.safe_float(order, 'deal_volume')
          feeCost = self.safe_float(order, 'fee')
          if feeCost != nil
            feeCurrency = nil
            if market != nil
              if side == 'buy'
                feeCurrency = market['base']
              elsif side == 'sell'
                feeCurrency = market['quote']
              end
            end
            fee = {
              'cost' => feeCost,
              'currency' => feeCurrency
            }
          end
        end
      end
      if amount != nil
        if remaining != nil
          if filled.nil?
            filled = maximum_wrapper(0, amount - remaining)
          end
        elsif filled != nil
          cost = filled * price
          if remaining.nil?
            remaining = maximum_wrapper(0, amount - filled)
          end
        end
      end
      if status.nil?
        if remaining != nil
          if remaining == 0
            status = 'closed'
          end
        end
      end
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'average' => average,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee,
        'trades' => nil
      }
      return result
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      #
      # obsolete since v2
      # https://github.com/ccxt/ccxt/issues/4815
      #
      #     if !self.password
      #         raise(AuthenticationError, self.id + ' createOrder requires exchange.password to be set to user trading password(not login password!)')
      #     }
      #
      self.check_required_credentials
      market = self.market(symbol)
      orderType = (type == 'limit') ? 1 : 2
      order = {
        'symbol' => market['id'],
        'side' => side.upcase,
        'type' => orderType,
        'volume' => self.amount_to_precision(symbol, amount),
        # 'capital_password' => self.password, # obsolete since v2, https://github.com/ccxt/ccxt/issues/4815
      }
      if (type == 'market') && (side == 'buy')
        if price.nil?
          raise(InvalidOrder, self.id + ' createOrder requires price argument for market buy orders to calculate total cost according to exchange rules')
        end
        order['volume'] = self.amount_to_precision(symbol, parse_float(amount) * parse_float(price))
      end
      if type == 'limit'
        order['price'] = self.price_to_precision(symbol, price)
      else
        if price.nil?
          order['price'] = self.price_to_precision(symbol, 0)
        else
          order['price'] = self.price_to_precision(symbol, price)
        end
      end
      response = self.v2PostOrder(self.shallow_extend(order, params))
      #
      #     {
      #         "code" => "0",
      #         "msg" => "suc",
      #         "data" => {
      #             "order_id" => 481
      #         }
      #     }
      #
      timestamp = self.milliseconds
      return {
        'info' => response,
        'id' => self.safe_string(response['data'], 'order_id'),
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => nil,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'filled' => nil,
        'remaining' => nil,
        'cost' => nil,
        'trades' => nil,
        'fee' => nil
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' cancelOrder requires a symbol argument')
      end
      market = self.market(symbol)
      response = self.privateDeleteOrder(self.shallow_extend({
        'symbol' => market['id'],
        'order_id' => id
      }, params))
      return {
        'id' => id,
        'symbol' => symbol,
        'info' => response
      }
    end

    def cancel_orders(ids, symbol = nil, params = {})
      self.load_markets
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' cancelOrders requires a symbol argument')
      end
      market = self.market(symbol)
      marketId = market['id']
      orderIdList = {}
      orderIdList[marketId] = ids
      request = {
        'orderIdList' => self.json(orderIdList)
      }
      response = self.v2PostOrderBatchCancel(self.shallow_extend(request, params))
      return {
        'info' => response
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      self.check_required_credentials
      url = self.implode_params(self.urls['api'][api], {
        'hostname' => self.hostname
      })
      url += '/' + self.implode_params(path, params)
      if api == 'private' || api == 'v2'
        timestamp = self.milliseconds.to_s
        query = self.keysort(self.shallow_extend({
          'time' => timestamp
        }, params))
        keys = query.keys
        auth = ''
        for i in (0...keys.length)
          auth += keys[i] + query[keys[i]].to_s
        end
        auth += self.secret
        signature = self.hmac(self.encode(auth), self.encode(self.secret), 'sha512')
        urlParams = (method == 'POST') ? {} : query
        url += '?' + self.urlencode(self.keysort(self.shallow_extend({
          'api_key' => self.apiKey,
          'time' => timestamp
        }, urlParams)))
        url += '&sign=' + signature
        if method == 'POST'
          body = self.urlencode(query)
          headers = {
            'Content-Type' => 'application/x-www-form-urlencoded'
          }
        end
      elsif api == 'public' || api == 'v2public'
        url += '?' + self.urlencode(self.shallow_extend({
          'api_key' => self.apiKey
        }, params))
      else
        if params
          url += '?' + self.urlencode(params)
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        if response.include?('code')
          #
          #     { "code" => "100005", "msg" => "request sign illegal", "data" => null }
          #
          code = self.safe_string(response, 'code')
          if code != nil
            message = self.safe_string(response, 'msg')
            feedback = self.id + ' ' + self.json(response)
            if code != '0'
              exceptions = self.exceptions
              if exceptions.include?(code)
                if code == '1'
                  #
                  #    {"code":"1","msg":"系统错误","data":null}
                  #    {“code”:“1",“msg”:“Balance insufficient,余额不足“,”data”:null}
                  #
                  if message.include?('Balance insufficient')
                    raise(InsufficientFunds, feedback)
                  end
                elsif code == '2'
                  if message == 'offsetNot Null'
                    raise(ExchangeError, feedback)
                  elsif message == 'api_keyNot EXIST'
                    raise(AuthenticationError, feedback)
                  elsif message == 'price precision exceed the limit'
                    raise(InvalidOrder, feedback)
                  elsif message == 'Parameter error'
                    raise(BadRequest, feedback)
                  end
                end
                raise(exceptions[code], feedback)
              else
                raise(ExchangeError, self.id + ' unknown "error" value => ' + self.json(response))
              end
            else
              #
              # Google Translate:
              # 订单状态不能取消,订单取消失败 = Order status cannot be canceled
              # 根据订单号没有查询到订单,订单取消失败 = The order was not queried according to the order number
              #
              # {"code":"0","msg":"suc","data":{"success":[],"failed":[{"err-msg":"订单状态不能取消,订单取消失败","order-id":32857051,"err-code":"8"}]}}
              # {"code":"0","msg":"suc","data":{"success":[],"failed":[{"err-msg":"Parameter error","order-id":32857050,"err-code":"2"},{"err-msg":"订单状态不能取消,订单取消失败","order-id":32857050,"err-code":"8"}]}}
              # {"code":"0","msg":"suc","data":{"success":[],"failed":[{"err-msg":"Parameter error","order-id":98549677,"err-code":"2"},{"err-msg":"根据订单号没有查询到订单,订单取消失败","order-id":98549677,"err-code":"8"}]}}
              #
              if feedback.include?('订单状态不能取消,订单取消失败')
                if feedback.include?('Parameter error')
                  raise(OrderNotFound, feedback)
                else
                  raise(InvalidOrder, feedback)
                end
              elsif feedback.include?('根据订单号没有查询到订单,订单取消失败')
                raise(OrderNotFound, feedback)
              end
            end
          end
        end
      end
    end
  end
end
