# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coinnest < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coinnest',
        'name' => 'coinnest',
        'countries' => ['KR'],
        'rateLimit' => 1000,
        'has' => {
          'fetchOpenOrders' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/38065728-7289ff5c-330d-11e8-9cc1-cf0cbcb606bc.jpg',
          'api' => {
            'public' => 'https://api.coinnest.co.kr/api',
            'private' => 'https://api.coinnest.co.kr/api',
            'web' => 'https://www.coinnest.co.kr'
          },
          'www' => 'https://www.coinnest.co.kr',
          'doc' => 'https://www.coinnest.co.kr/doc/intro.html',
          'fees' => [
            'https://coinnesthelp.zendesk.com/hc/ko/articles/115002110252-%EA%B1%B0%EB%9E%98-%EC%88%98%EC%88%98%EB%A3%8C%EB%8A%94-%EC%96%BC%EB%A7%88%EC%9D%B8%EA%B0%80%EC%9A%94-',
            'https://coinnesthelp.zendesk.com/hc/ko/articles/115002110272-%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8-%EC%88%98%EC%88%98%EB%A3%8C%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94-'
          ]
        },
        'api' => {
          'web' => {
            'get' => [
              'coin/allcoin'
            ]
          },
          'public' => {
            'get' => [
              'pub/ticker',
              'pub/depth',
              'pub/trades'
            ]
          },
          'private' => {
            'post' => [
              'account/balance',
              'trade/add',
              'trade/cancel',
              'trade/fetchtrust',
              'trade/trust'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.1 / 100,
            'taker' => 0.1 / 100
          },
          'funding' => {
            'withdraw' => {
              'BTC' => '0.002'
            }
          }
        },
        'precision' => {
          'amount' => 8,
          'price' => 8
        }
      })
    end

    def fetch_markets(params = {})
      quote = 'KRW'
      quoteId = quote.downcase
      # todo => rewrite self for web endpoint
      coins = [
        'btc',
        'bch',
        'btg',
        'bcd',
        'ubtc',
        'btn',
        'kst',
        'ltc',
        'act',
        'eth',
        'etc',
        'ada',
        'qtum',
        'xlm',
        'neo',
        'gas',
        'rpx',
        'hsr',
        'knc',
        'tsl',
        'tron',
        'omg',
        'wtc',
        'mco',
        'storm',
        'gto',
        'pxs',
        'chat',
        'ink',
        'oc',
        'hlc',
        'ent',
        'qbt',
        'spc',
        'put'
      ]
      result = []
      for i in (0...coins.length)
        baseId = coins[i]
        id = baseId + '/' + quoteId
        base = self.common_currency_code(baseId.upcase)
        symbol = base + '/' + quote
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'info' => nil
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = ticker['time'] * 1000
      symbol = market['symbol']
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetPubTicker(self.shallow_extend({
        'coin' => market['baseId']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      orderbook = self.publicGetPubDepth(self.shallow_extend({
        'coin' => market['baseId']
      }, params))
      return self.parse_order_book(orderbook)
    end

    def parse_trade(trade, market = nil)
      timestamp = parse_int(trade['date']) * 1000
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      symbol = market['symbol']
      cost = self.price_to_precision(symbol, amount * price)
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => self.safe_string(trade, 'tid'),
        'order' => nil,
        'type' => 'limit',
        'side' => trade['type'],
        'price' => price,
        'amount' => amount,
        'cost' => parse_float(cost),
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      trades = self.publicGetPubTrades(self.shallow_extend({
        'coin' => market['baseId']
      }, params))
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostAccountBalance(params)
      result = { 'info' => response }
      balancKeys = response.keys
      for i in (0...balancKeys.length)
        key = balancKeys[i]
        parts = key.split('_')
        if parts.length != 2
          next
        end
        type = parts[1]
        if type != 'reserved' && type != 'balance'
          next
        end
        currency = parts[0].upcase
        currency = self.common_currency_code(currency)
        if result.include?(!(currency))
          result[currency] = {
            'free' => 0.0,
            'used' => 0.0,
            'total' => 0.0
          }
        end
        type = (type == 'reserved' ? 'used' : 'free')
        result[currency][type] = parse_float(response[key])
        otherType = (type == 'used' ? 'free' : 'used')
        if result[currency].include?(otherType)
          result[currency]['total'] = self.sum(result[currency]['free'], result[currency]['used'])
        end
      end
      return self.parse_balance(result)
    end

    def parse_order(order, market)
      symbol = market['symbol']
      timestamp = parse_int(order['time']) * 1000
      status = parse_int(order['status'])
      # 1 => newly created, 2 => ready for dealing, 3 => canceled, 4 => completed.
      if status == 4
        status = 'closed'
      elsif status == 3
        status = 'canceled'
      else
        status = 'open'
      end
      amount = self.safe_float(order, 'amount_total')
      remaining = self.safe_float(order, 'amount_over')
      filled = self.safe_value(order, 'deals')
      if filled
        filled = self.safe_float(filled, 'sum_amount')
      else
        filled = amount - remaining
      end
      return {
        'id' => self.safe_string(order, 'id'),
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => order['type'],
        'price' => self.safe_float(order, 'price'),
        'cost' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => nil,
        'info' => self.safe_value(order, 'info', order)
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostTradeAdd(self.shallow_extend({
        'coin' => market['baseId'],
        'type' => side,
        'number' => amount,
        'price' => price
      }, params))
      order = {
        'id' => response['id'],
        'time' => self.seconds,
        'type' => side,
        'price' => price,
        'amount_total' => amount,
        'amount_over' => amount,
        'info' => response
      }
      id = order['id']
      self.orders[id] = self.parse_order(order, market)
      return order
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostTradeCancel(self.shallow_extend({
        'id' => id,
        'coin' => market['baseId']
      }, params))
      return response
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      order = self.privatePostTradeFetchtrust(self.shallow_extend({
        'id' => id,
        'coin' => market['baseId']
      }, params))
      return self.parse_order(order, market)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'coin' => market['baseId']
      }
      if since != nil
        request['since'] = parse_int(since / 1000)
      end
      if limit != nil
        request['limit'] = limit
      end
      response = self.privatePostTradeTrust(self.shallow_extend(request, params))
      return self.parse_orders(response, market)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'type' => '1'
      }, params))
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + path
      query = nil
      if api == 'public'
        query = self.urlencode(params)
        if query.length
          url += '?' + query
        end
      else
        self.check_required_credentials
        body = self.urlencode(self.shallow_extend(params, {
          'key' => self.apiKey,
          'nonce' => self.nonce
        }))
        secret = self.hash(self.secret)
        body += '&signature=' + self.hmac(self.encode(body), self.encode(secret))
        headers = { 'Content-type' => 'application/x-www-form-urlencoded' }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      status = self.safe_string(response, 'status')
      if !response || response == 'nil' || status
        errorClass = self.safe_value({
          '100' => DDoSProtection,
          '101' => DDoSProtection,
          '104' => AuthenticationError,
          '105' => AuthenticationError,
          '106' => DDoSProtection
        }, status, ExchangeError)
        message = self.safe_string(response, 'msg', self.json(response))
        raise(errorClass, message)
      end
      return response
    end
  end
end
