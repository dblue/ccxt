# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coinspot < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coinspot',
        'name' => 'CoinSpot',
        'countries' => ['AU'], # Australia
        'rateLimit' => 1000,
        'has' => {
          'CORS' => false,
          'createMarketOrder' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg',
          'api' => {
            'public' => 'https://www.coinspot.com.au/pubapi',
            'private' => 'https://www.coinspot.com.au/api'
          },
          'www' => 'https://www.coinspot.com.au',
          'doc' => 'https://www.coinspot.com.au/api'
        },
        'api' => {
          'public' => {
            'get' => [
              'latest'
            ]
          },
          'private' => {
            'post' => [
              'orders',
              'orders/history',
              'my/coin/deposit',
              'my/coin/send',
              'quote/buy',
              'quote/sell',
              'my/balances',
              'my/orders',
              'my/buy',
              'my/sell',
              'my/buy/cancel',
              'my/sell/cancel'
            ]
          }
        },
        'markets' => {
          'BTC/AUD' => { 'id' => 'BTC', 'symbol' => 'BTC/AUD', 'base' => 'BTC', 'quote' => 'AUD' },
          'LTC/AUD' => { 'id' => 'LTC', 'symbol' => 'LTC/AUD', 'base' => 'LTC', 'quote' => 'AUD' },
          'DOGE/AUD' => { 'id' => 'DOGE', 'symbol' => 'DOGE/AUD', 'base' => 'DOGE', 'quote' => 'AUD' }
        }
      })
    end

    def fetch_balance(params = {})
      response = self.privatePostMyBalances
      result = { 'info' => response }
      if response.include?('balance')
        balances = response['balance']
        currencies = balances.keys
        for c in (0...currencies.length)
          currency = currencies[c]
          uppercase = currency.upcase
          account = {
            'free' => balances[currency],
            'used' => 0.0,
            'total' => balances[currency]
          }
          if uppercase == 'DRK'
            uppercase = 'DASH'
          end
          result[uppercase] = account
        end
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      market = self.market(symbol)
      orderbook = self.privatePostOrders(self.shallow_extend({
        'cointype' => market['id']
      }, params))
      return self.parse_order_book(orderbook, nil, 'buyorders', 'sellorders', 'rate', 'amount')
    end

    def fetch_ticker(symbol, params = {})
      response = self.publicGetLatest(params)
      id = self.market_id(symbol)
      id = id.downcase
      ticker = response['prices'][id]
      timestamp = self.milliseconds
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => nil,
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      return self.privatePostOrdersHistory(self.shallow_extend({
        'cointype' => self.market_id(symbol)
      }, params))
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      method = 'privatePostMy' + self.capitalize(side)
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      order = {
        'cointype' => self.market_id(symbol),
        'amount' => amount,
        'rate' => price
      }
      return self.send_wrapper(method, self.shallow_extend(order, params))
    end

    def cancel_order(id, symbol = nil, params = {})
      raise(NotSupported, self.id + ' cancelOrder is not fully implemented yet')
      # method = 'privatePostMyBuy'
      # return self.send_wrapper(method, { 'id' => id })
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      if !self.apiKey
        raise(AuthenticationError, self.id + ' requires apiKey for all requests')
      end
      url = self.urls['api'][api] + '/' + path
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce
        body = self.json(self.shallow_extend({ 'nonce' => nonce }, params))
        headers = {
          'Content-Type' => 'application/json',
          'key' => self.apiKey,
          'sign' => self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
