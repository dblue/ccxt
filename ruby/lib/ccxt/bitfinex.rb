# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bitfinex < Exchange
    def describe
      return self.class.deep_extend(super, {
        'id' => 'bitfinex',
        'name' => 'Bitfinex',
        'countries' => ['VG'],
        'version' => 'v1',
        'rateLimit' => 1500,
        'certified' => true,
        # new metainfo interface
        'has' => {
          'CORS' => false,
          'cancelAllOrders' => true,
          'createDepositAddress' => true,
          'deposit' => true,
          'fetchClosedOrders' => true,
          'fetchDepositAddress' => true,
          'fetchTradingFee' => true,
          'fetchTradingFees' => true,
          'fetchFundingFees' => true,
          'fetchMyTrades' => true,
          'fetchOHLCV' => true,
          'fetchOpenOrders' => true,
          'fetchOrder' => true,
          'fetchTickers' => true,
          'fetchTransactions' => true,
          'fetchDeposits' => false,
          'fetchWithdrawals' => false,
          'withdraw' => true
        },
        'timeframes' => {
          '1m' => '1m',
          '5m' => '5m',
          '15m' => '15m',
          '30m' => '30m',
          '1h' => '1h',
          '3h' => '3h',
          '6h' => '6h',
          '12h' => '12h',
          '1d' => '1D',
          '1w' => '7D',
          '2w' => '14D',
          '1M' => '1M'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
          'api' => 'https://api.bitfinex.com',
          'www' => 'https://www.bitfinex.com',
          'doc' => [
            'https://docs.bitfinex.com/v1/docs',
            'https://github.com/bitfinexcom/bitfinex-api-node'
          ]
        },
        'api' => {
          'v2' => {
            'get' => [
              'candles/trade:{timeframe}:{symbol}/{section}',
              'candles/trade:{timeframe}:{symbol}/last',
              'candles/trade:{timeframe}:{symbol}/hist'
            ]
          },
          'public' => {
            'get' => [
              'book/{symbol}',
              # 'candles/{symbol}',
              'lendbook/{currency}',
              'lends/{currency}',
              'pubticker/{symbol}',
              'stats/{symbol}',
              'symbols',
              'symbols_details',
              'tickers',
              'today',
              'trades/{symbol}'
            ]
          },
          'private' => {
            'post' => [
              'account_fees',
              'account_infos',
              'balances',
              'basket_manage',
              'credits',
              'deposit/new',
              'funding/close',
              'history',
              'history/movements',
              'key_info',
              'margin_infos',
              'mytrades',
              'mytrades_funding',
              'offer/cancel',
              'offer/new',
              'offer/status',
              'offers',
              'offers/hist',
              'order/cancel',
              'order/cancel/all',
              'order/cancel/multi',
              'order/cancel/replace',
              'order/new',
              'order/new/multi',
              'order/status',
              'orders',
              'orders/hist',
              'position/claim',
              'position/close',
              'positions',
              'summary',
              'taken_funds',
              'total_taken_funds',
              'transfer',
              'unused_taken_funds',
              'withdraw'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'percentage' => true,
            'maker' => 0.1 / 100,
            'taker' => 0.2 / 100,
            'tiers' => {
              'taker' => [
                [0, 0.2 / 100],
                [500000, 0.2 / 100],
                [1000000, 0.2 / 100],
                [2500000, 0.2 / 100],
                [5000000, 0.2 / 100],
                [7500000, 0.2 / 100],
                [10000000, 0.18 / 100],
                [15000000, 0.16 / 100],
                [20000000, 0.14 / 100],
                [25000000, 0.12 / 100],
                [30000000, 0.1 / 100]
              ],
              'maker' => [
                [0, 0.1 / 100],
                [500000, 0.08 / 100],
                [1000000, 0.06 / 100],
                [2500000, 0.04 / 100],
                [5000000, 0.02 / 100],
                [7500000, 0],
                [10000000, 0],
                [15000000, 0],
                [20000000, 0],
                [25000000, 0],
                [30000000, 0]
              ]
            }
          },
          'funding' => {
            'tierBased' => false, # true for tier-based/progressive
            'percentage' => false, # fixed commission
            # Actually deposit fees are free for larger deposits(> $1000 USD equivalent)
            # these values below are deprecated, we should not hardcode fees and limits anymore
            # to be reimplemented with bitfinex funding fees from their API or web endpoints
            'deposit' => {
              'BTC' => 0.0004,
              'IOTA' => 0.5,
              'ETH' => 0.0027,
              'BCH' => 0.0001,
              'LTC' => 0.001,
              'EOS' => 0.24279,
              'XMR' => 0.04,
              'SAN' => 0.99269,
              'DASH' => 0.01,
              'ETC' => 0.01,
              'XRP' => 0.02,
              'YYW' => 16.915,
              'NEO' => 0,
              'ZEC' => 0.001,
              'BTG' => 0,
              'OMG' => 0.14026,
              'DATA' => 20.773,
              'QASH' => 1.9858,
              'ETP' => 0.01,
              'QTUM' => 0.01,
              'EDO' => 0.95001,
              'AVT' => 1.3045,
              'USDT' => 0,
              'TRX' => 28.184,
              'ZRX' => 1.9947,
              'RCN' => 10.793,
              'TNB' => 31.915,
              'SNT' => 14.976,
              'RLC' => 1.414,
              'GNT' => 5.8952,
              'SPK' => 10.893,
              'REP' => 0.041168,
              'BAT' => 6.1546,
              'ELF' => 1.8753,
              'FUN' => 32.336,
              'SNG' => 18.622,
              'AID' => 8.08,
              'MNA' => 16.617,
              'NEC' => 1.6504,
              'XTZ' => 0.2
            },
            'withdraw' => {
              'BTC' => 0.0004,
              'IOTA' => 0.5,
              'ETH' => 0.0027,
              'BCH' => 0.0001,
              'LTC' => 0.001,
              'EOS' => 0.24279,
              'XMR' => 0.04,
              'SAN' => 0.99269,
              'DASH' => 0.01,
              'ETC' => 0.01,
              'XRP' => 0.02,
              'YYW' => 16.915,
              'NEO' => 0,
              'ZEC' => 0.001,
              'BTG' => 0,
              'OMG' => 0.14026,
              'DATA' => 20.773,
              'QASH' => 1.9858,
              'ETP' => 0.01,
              'QTUM' => 0.01,
              'EDO' => 0.95001,
              'AVT' => 1.3045,
              'USDT' => 20,
              'TRX' => 28.184,
              'ZRX' => 1.9947,
              'RCN' => 10.793,
              'TNB' => 31.915,
              'SNT' => 14.976,
              'RLC' => 1.414,
              'GNT' => 5.8952,
              'SPK' => 10.893,
              'REP' => 0.041168,
              'BAT' => 6.1546,
              'ELF' => 1.8753,
              'FUN' => 32.336,
              'SNG' => 18.622,
              'AID' => 8.08,
              'MNA' => 16.617,
              'NEC' => 1.6504,
              'XTZ' => 0.2
            }
          }
        },
        'commonCurrencies' => {
          'ABS' => 'ABYSS',
          'AIO' => 'AION',
          'ATM' => 'ATMI',
          'BAB' => 'BCH',
          'CTX' => 'CTXC',
          'DAD' => 'DADI',
          'DAT' => 'DATA',
          'DSH' => 'DASH',
          'GSD' => 'GUSD',
          'HOT' => 'Hydro Protocol',
          'IOS' => 'IOST',
          'IOT' => 'IOTA',
          'IQX' => 'IQ',
          'MIT' => 'MITH',
          'MNA' => 'MANA',
          'NCA' => 'NCASH',
          'ORS' => 'ORS Group', # conflict with Origin Sport #3230
          'POY' => 'POLY',
          'QSH' => 'QASH',
          'QTM' => 'QTUM',
          'SEE' => 'SEER',
          'SNG' => 'SNGLS',
          'SPK' => 'SPANK',
          'STJ' => 'STORJ',
          'TSD' => 'TUSD',
          'YYW' => 'YOYOW',
          'UDC' => 'USDC',
          'UST' => 'USDT',
          'UTN' => 'UTNP',
          'XCH' => 'XCHF'
        },
        'exceptions' => {
          'exact' => {
            'temporarily_unavailable' => ExchangeNotAvailable, # Sorry, the service is temporarily unavailable. See https://www.bitfinex.com/ for more info.
            'Order could not be cancelled.' => OrderNotFound, # non-existent order
            'No such order found.' => OrderNotFound, # ?
            'Order price must be positive.' => InvalidOrder, # on price <= 0
            'Could not find a key matching the given X-BFX-APIKEY.' => AuthenticationError,
            'Key price should be a decimal number, e.g. "123.456"' => InvalidOrder, # on isNaN(price)
            'Key amount should be a decimal number, e.g. "123.456"' => InvalidOrder, # on isNaN(amount)
            'ERR_RATE_LIMIT' => DDoSProtection,
            'Ratelimit' => DDoSProtection,
            'Nonce is too small.' => InvalidNonce,
            'No summary found.' => ExchangeError, # fetchTradingFees(summary) endpoint can give self vague error message
            'Cannot evaluate your available balance, please try again' => ExchangeNotAvailable
          },
          'broad' => {
            'This API key does not have permission' => PermissionDenied, # authenticated but not authorized
            'Invalid order => not enough exchange balance for ' => InsufficientFunds, # when buying cost is greater than the available quote currency
            'Invalid order => minimum size for ' => InvalidOrder, # when amount below limits.amount.min
            'Invalid order' => InvalidOrder, # ?
            'The available balance is only' => InsufficientFunds, # {"status":"error","message":"Cannot withdraw 1.0027 ETH from your exchange wallet. The available balance is only 0.0 ETH. If you have limit orders, open positions, unused or active margin funding, self will decrease your available balance. To increase it, you can cancel limit orders or reduce/close your positions.","withdrawal_id":0,"fees":"0.0027"}
          }
        },
        'precisionMode' => SIGNIFICANT_DIGITS,
        'options' => {
          'currencyNames' => {
            'AGI' => 'agi',
            'AID' => 'aid',
            'AIO' => 'aio',
            'ANT' => 'ant',
            'AVT' => 'aventus', # #1811
            'BAT' => 'bat',
            'BCH' => 'bcash', # undocumented
            'BCI' => 'bci',
            'BFT' => 'bft',
            'BTC' => 'bitcoin',
            'BTG' => 'bgold',
            'CFI' => 'cfi',
            'DAI' => 'dai',
            'DADI' => 'dad',
            'DASH' => 'dash',
            'DATA' => 'datacoin',
            'DTH' => 'dth',
            'EDO' => 'eidoo', # #1811
            'ELF' => 'elf',
            'EOS' => 'eos',
            'ETC' => 'ethereumc',
            'ETH' => 'ethereum',
            'ETP' => 'metaverse',
            'FUN' => 'fun',
            'GNT' => 'golem',
            'IOST' => 'ios',
            'IOTA' => 'iota',
            'LRC' => 'lrc',
            'LTC' => 'litecoin',
            'LYM' => 'lym',
            'MANA' => 'mna',
            'MIT' => 'mit',
            'MKR' => 'mkr',
            'MTN' => 'mtn',
            'NEO' => 'neo',
            'ODE' => 'ode',
            'OMG' => 'omisego',
            'OMNI' => 'mastercoin',
            'QASH' => 'qash',
            'QTUM' => 'qtum', # #1811
            'RCN' => 'rcn',
            'RDN' => 'rdn',
            'REP' => 'rep',
            'REQ' => 'req',
            'RLC' => 'rlc',
            'SAN' => 'santiment',
            'SNGLS' => 'sng',
            'SNT' => 'status',
            'SPANK' => 'spk',
            'STORJ' => 'stj',
            'TNB' => 'tnb',
            'TRX' => 'trx',
            'USD' => 'wire',
            'UTK' => 'utk',
            'USDT' => 'tetheruso', # undocumented
            'VEE' => 'vee',
            'WAX' => 'wax',
            'XLM' => 'xlm',
            'XMR' => 'monero',
            'XRP' => 'ripple',
            'XVG' => 'xvg',
            'YOYOW' => 'yoyow',
            'ZEC' => 'zcash',
            'ZRX' => 'zrx',
            'XTZ' => 'tezos'
          },
          'orderTypes' => {
            'limit' => 'exchange limit',
            'market' => 'exchange market'
          }
        }
      })
    end

    def fetch_funding_fees(params = {})
      self.load_markets
      response = self.privatePostAccountFees(params)
      fees = response['withdraw']
      withdraw = {}
      ids = fees.keys
      for i in (0...ids.length)
        id = ids[i]
        code = id
        if self.currencies_by_id.include?(id)
          currency = self.currencies_by_id[id]
          code = currency['code']
        end
        withdraw[code] = self.class.safe_float(fees, id)
      end
      return {
        'info' => response,
        'withdraw' => withdraw,
        'deposit' => withdraw,  # only for deposits of less than $1000
      }
    end

    def fetch_trading_fees(params = {})
      self.load_markets
      response = self.privatePostSummary(params)
      #
      #     {
      #         time => '2019-02-20T15:50:19.152000Z',
      #         trade_vol_30d => [
      #             {
      #                 curr => 'Total(USD)',
      #                 vol => 0,
      #                 vol_maker => 0,
      #                 vol_BFX => 0,
      #                 vol_BFX_maker => 0,
      #                 vol_ETHFX => 0,
      #                 vol_ETHFX_maker => 0
      #             }
      #         ],
      #         fees_funding_30d => {},
      #         fees_funding_total_30d => 0,
      #         fees_trading_30d => {},
      #         fees_trading_total_30d => 0,
      #         maker_fee => 0.001,
      #         taker_fee => 0.002
      #     }
      #
      return {
        'info' => response,
        'maker' => self.class.safe_float(response, 'maker_fee'),
        'taker' => self.class.safe_float(response, 'taker_fee')
      }
    end

    def fetch_markets(params = {})
      markets = self.publicGetSymbolsDetails
      result = []
      for p in (0...markets.length)
        market = markets[p]
        id = market['pair'].upcase
        baseId = id[0...3]
        quoteId = id[3...6]
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'price' => market['price_precision'],
          'amount' => nil
        }
        limits = {
          'amount' => {
            'min' => self.class.safe_float(market, 'minimum_order_size'),
            'max' => self.class.safe_float(market, 'maximum_order_size')
          },
          'price' => {
            'min' => 10**-precision['price'],
            'max' => 10**precision['price']
          }
        }
        limits['cost'] = {
          'min' => limits['amount']['min'] * limits['price']['min'],
          'max' => nil
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => limits,
          'info' => market
        })
      end
      return result
    end

    def calculate_fee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {})
      market = self.markets[symbol]
      rate = market[takerOrMaker]
      cost = amount * rate
      key = 'quote'
      if side == 'sell'
        cost *= price
      else
        key = 'base'
      end
      return {
        'type' => takerOrMaker,
        'currency' => market[key],
        'rate' => rate,
        'cost' => self.currency_to_precision(market[key], cost.to_f)
      }
    end

    def fetch_balance(params = {})
      self.load_markets
      balanceType = self.class.safe_string(params, 'type', 'exchange')
      query = self.class.omit(params, 'type')
      balances = self.privatePostBalances(query)
      result = { 'info' => balances }
      for i in (0...balances.length)
        balance = balances[i]
        if balance['type'] == balanceType
          currency = balance['currency']
          uppercase = currency.upcase
          uppercase = self.common_currency_code(uppercase)
          # bitfinex had BCH previously, now it's BAB, but the old
          # BCH symbol is kept for backward-compatibility
          # we need a workaround here so that the old BCH balance
          # would not override the new BAB balance(BAB is unified to BCH)
          # https://github.com/ccxt/ccxt/issues/4989
          if result.include?(!(uppercase))
            account = self.account
            account['free'] = balance['available'].to_f
            account['total'] = balance['amount'].to_f
            account['used'] = account['total'] - account['free']
            result[uppercase] = account
          end
        end
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'symbol' => self.market_id(symbol)
      }
      if limit != nil
        request['limit_bids'] = limit
        request['limit_asks'] = limit
      end
      orderbook = self.publicGetBookSymbol(self.class.shallow_extend(request, params))
      return self.parse_order_book(orderbook, nil, 'bids', 'asks', 'price', 'amount')
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTickers(params)
      result = {}
      for i in (0...tickers.length)
        ticker = self.parse_ticker(tickers[i])
        symbol = ticker['symbol']
        result[symbol] = ticker
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetPubtickerSymbol(self.class.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.class.safe_float(ticker, 'timestamp') * 1000
      symbol = nil
      if market != nil
        symbol = market['symbol']
      elsif ticker.include?('pair')
        id = ticker['pair']
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
        end
        if market != nil
          symbol = market['symbol']
        else
          baseId = id[0...3]
          quoteId = id[3...6]
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
      end
      last = self.class.safe_float(ticker, 'last_price')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.class.iso8601(timestamp),
        'high' => self.class.safe_float(ticker, 'high'),
        'low' => self.class.safe_float(ticker, 'low'),
        'bid' => self.class.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.class.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => self.class.safe_float(ticker, 'mid'),
        'baseVolume' => self.class.safe_float(ticker, 'volume'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def parse_trade(trade, market)
      timestamp = (trade['timestamp'].to_f).to_i * 1000
      side = trade['type'].downcase
      orderId = self.class.safe_string(trade, 'order_id')
      price = self.class.safe_float(trade, 'price')
      amount = self.class.safe_float(trade, 'amount')
      cost = price * amount
      fee = nil
      if trade.include?('fee_amount')
        feeCost = -self.class.safe_float(trade, 'fee_amount')
        feeCurrency = self.class.safe_string(trade, 'fee_currency')
        if self.currencies_by_id.include?(feeCurrency)
          feeCurrency = self.currencies_by_id[feeCurrency]['code']
        else
          feeCurrency = self.common_currency_code(feeCurrency)
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      return {
        'id' => trade['tid'].to_s,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.class.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'order' => orderId,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = 50, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'limit_trades' => limit
      }
      if since != nil
        request['timestamp'] = (since / 1000).to_i
      end
      response = self.publicGetTradesSymbol(self.class.shallow_extend(request, params))
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = { 'symbol' => market['id'] }
      if limit != nil
        request['limit_trades'] = limit
      end
      if since != nil
        request['timestamp'] = (since / 1000).to_i
      end
      response = self.privatePostMytrades(self.class.shallow_extend(request, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      order = {
        'symbol' => self.market_id(symbol),
        'side' => side,
        'amount' => self.number_to_string(amount),
        'type' => self.class.safe_string(self.options['orderTypes'], type, type),
        'ocoorder' => false,
        'buy_price_oco' => 0,
        'sell_price_oco' => 0
      }
      if type == 'market'
        order['price'] = self.nonce.to_s
      else
        order['price'] = self.price_to_precision(symbol, price)
      end
      result = self.privatePostOrderNew(self.class.shallow_extend(order, params))
      return self.parse_order(result)
    end

    def edit_order(id, symbol, type, side, amount = nil, price = nil, params = {})
      self.load_markets
      order = {
        'order_id' => id
      }
      if price != nil
        order['price'] = self.price_to_precision(symbol, price)
      end
      if amount != nil
        order['amount'] = self.number_to_string(amount)
      end
      if symbol != nil
        order['symbol'] = self.market_id(symbol)
      end
      if side != nil
        order['side'] = side
      end
      if type != nil
        order['type'] = self.class.safe_string(self.options['orderTypes'], type, type)
      end
      result = self.privatePostOrderCancelReplace(self.class.shallow_extend(order, params))
      return self.parse_order(result)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostOrderCancel({ 'order_id' => (id).to_i })
    end

    def cancel_all_orders(symbol = nil, params = {})
      return self.privatePostOrderCancelAll(params)
    end

    def parse_order(order, market = nil)
      side = order['side']
      open = order['is_live']
      canceled = order['is_cancelled']
      status = nil
      if open
        status = 'open'
      elsif canceled
        status = 'canceled'
      else
        status = 'closed'
      end
      symbol = nil
      if market.nil?
        exchange = order['symbol'].upcase
        if self.markets_by_id.include?(exchange)
          market = self.markets_by_id[exchange]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      orderType = order['type']
      exchange = orderType.index('exchange ') >= 0
      if exchange
        parts = order['type'].split(' ')
        orderType = parts[1]
      end
      timestamp = (order['timestamp'].to_f * 1000).to_i
      result = {
        'info' => order,
        'id' => order['id'].to_s,
        'timestamp' => timestamp,
        'datetime' => self.class.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => orderType,
        'side' => side,
        'price' => self.class.safe_float(order, 'price'),
        'average' => self.class.safe_float(order, 'avg_execution_price'),
        'amount' => self.class.safe_float(order, 'original_amount'),
        'remaining' => self.class.safe_float(order, 'remaining_amount'),
        'filled' => self.class.safe_float(order, 'executed_amount'),
        'status' => status,
        'fee' => nil
      }
      return result
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if symbol != nil
        if self.markets.include?(!(symbol))
          raise(ExchangeError, self.id + ' has no symbol ' + symbol)
        end
      end
      response = self.privatePostOrders(params)
      orders = self.parse_orders(response, nil, since, limit)
      if symbol != nil
        orders = self.class.filter_by(orders, 'symbol', symbol)
      end
      return orders
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      if limit != nil
        request['limit'] = limit
      end
      response = self.privatePostOrdersHist(self.class.shallow_extend(request, params))
      orders = self.parse_orders(response, nil, since, limit)
      if symbol != nil
        orders = self.class.filter_by(orders, 'symbol', symbol)
      end
      orders = self.class.filter_by(orders, 'status', 'closed')
      return orders
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePostOrderStatus(self.class.shallow_extend({
        'order_id' => (id).to_i
      }, params))
      return self.parse_order(response)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv[0],
        ohlcv[1],
        ohlcv[3],
        ohlcv[4],
        ohlcv[2],
        ohlcv[5]
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      if limit.nil?
        limit = 100
      end
      market = self.market(symbol)
      v2id = 't' + market['id']
      request = {
        'symbol' => v2id,
        'timeframe' => self.timeframes[timeframe],
        'sort' => 1,
        'limit' => limit
      }
      if since != nil
        request['start'] = since
      end
      response = self.v2GetCandlesTradeTimeframeSymbolHist(self.class.shallow_extend(request, params))
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    def get_currency_name(code)
      if self.options['currencyNames'].include?(code)
        return self.options['currencyNames'][code]
      end
      raise(NotSupported, self.id + ' ' + code + ' not supported for withdrawal')
    end

    def create_deposit_address(code, params = {})
      response = self.fetch_deposit_address(code, self.class.shallow_extend({
        'renew' => 1
      }, params))
      address = self.class.safe_string(response, 'address')
      self.check_address(address)
      return {
        'info' => response['info'],
        'currency' => code,
        'address' => address,
        'tag' => nil
      }
    end

    def fetch_deposit_address(code, params = {})
      name = self.get_currency_name(code)
      request = {
        'method' => name,
        'wallet_name' => 'exchange',
        'renew' => 0, # a value of 1 will generate a new address
      }
      response = self.privatePostDepositNew(self.class.shallow_extend(request, params))
      address = response['address']
      tag = nil
      if response.include?('address_pool')
        tag = address
        address = response['address_pool']
      end
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      if code.nil?
        raise(ArgumentsRequired, self.id + ' fetchTransactions requires a currency code argument')
      end
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      if since != nil
        request['since'] = (since / 1000).to_i
      end
      response = self.privatePostHistoryMovements(self.class.shallow_extend(request, params))
      #
      #     [
      #         {
      #             "id":581183,
      #             "txid" => 123456,
      #             "currency":"BTC",
      #             "method":"BITCOIN",
      #             "type":"WITHDRAWAL",
      #             "amount":".01",
      #             "description":"3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ, offchain transfer ",
      #             "address":"3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ",
      #             "status":"COMPLETED",
      #             "timestamp":"1443833327.0",
      #             "timestamp_created" => "1443833327.1",
      #             "fee" => 0.1,
      #         }
      #     ]
      #
      return self.parseTransactions(response, currency, since, limit)
    end

    def parse_transaction(transaction, currency = nil)
      timestamp = self.class.safe_float(transaction, 'timestamp_created')
      if timestamp != nil
        timestamp = (timestamp * 1000).to_i
      end
      updated = self.class.safe_float(transaction, 'timestamp')
      if updated != nil
        updated = (updated * 1000).to_i
      end
      code = nil
      if currency.nil?
        currencyId = self.class.safe_string(transaction, 'currency')
        if self.currencies_by_id.include?(currencyId)
          currency = self.currencies_by_id[currencyId]
        else
          code = self.common_currency_code(currencyId)
        end
      end
      if currency != nil
        code = currency['code']
      end
      type = self.class.safe_string(transaction, 'type') # DEPOSIT or WITHDRAWAL
      if type != nil
        type = type.downcase
      end
      status = self.parse_transaction_status(self.class.safe_string(transaction, 'status'))
      feeCost = self.class.safe_float(transaction, 'fee')
      if feeCost != nil
        feeCost = feeCost.abs
      end
      return {
        'info' => transaction,
        'id' => self.class.safe_string(transaction, 'id'),
        'txid' => self.class.safe_string(transaction, 'txid'),
        'timestamp' => timestamp,
        'datetime' => self.class.iso8601(timestamp),
        'address' => self.class.safe_string(transaction, 'address'),
        'tag' => nil, # refix it properly for the tag from description
        'type' => type,
        'amount' => self.class.safe_float(transaction, 'amount'),
        'currency' => code,
        'status' => status,
        'updated' => updated,
        'fee' => {
          'currency' => code,
          'cost' => feeCost,
          'rate' => nil
        }
      }
    end

    def parse_transaction_status(status)
      statuses = {
        'CANCELED' => 'canceled',
        'ZEROCONFIRMED' => 'failed', # ZEROCONFIRMED happens e.g. in a double spend attempt(I had one in my movements!)
        'COMPLETED' => 'ok'
      }
      return(statuses.include?(status)) ? statuses[status] : status
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      name = self.get_currency_name(code)
      request = {
        'withdraw_type' => name,
        'walletselected' => 'exchange',
        'amount' => amount.to_s,
        'address' => address
      }
      if tag
        request['payment_id'] = tag
      end
      responses = self.privatePostWithdraw(self.class.shallow_extend(request, params))
      response = responses[0]
      id = response['withdrawal_id']
      message = response['message']
      errorMessage = self.findBroadlyMatchedKey(self.exceptions['broad'], message)
      if id == 0
        if errorMessage != nil
          # ExceptionClass = self.exceptions['broad'][errorMessage]
          # raise(ExceptionClass, self.id + ' ' + message)
          raise(self.exceptions['broad'][errorMessage], self.id + ' ' + message)
        end
        raise(ExchangeError, self.id + ' withdraw returned an id of zero => ' + self.class.json(response))
      end
      return {
        'info' => response,
        'id' => id
      }
    end

    def nonce
      return self.class.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = '/' + self.class.implode_params(path, params)
      if api == 'v2'
        request = '/' + api + request
      else
        request = '/' + self.version + request
      end
      query = self.class.omit(params, self.class.extract_params(path))
      url = self.urls['api'] + request
      if (api == 'public') || (path.index('/hist') >= 0)
        if query
          suffix = '?' + self.class.urlencode(query)
          url += suffix
          request += suffix
        end
      end
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce
        query = self.class.shallow_extend({
          'nonce' => nonce.to_s,
          'request' => request
        }, query)
        body = self.class.json(query)
        query = self.class.encode(body)
        payload = Base64.encode64(query)
        secret = self.class.encode(self.secret)
        signature = self.class.hmac(payload, secret, 'sha384')
        headers = {
          'X-BFX-APIKEY' => self.apiKey,
          'X-BFX-PAYLOAD' => self.class.decode(payload),
          'X-BFX-SIGNATURE' => signature
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if body.length < 2
        return
      end
      if code >= 400
        if body[0] == '{'
          feedback = self.id + ' ' + self.class.json(response)
          message = nil
          if response.include?('message')
            message = response['message']
          elsif response.include?('error')
            message = response['error']
          else
            raise(ExchangeError, feedback) # malformed(to our knowledge) response
          end
          exact = self.exceptions['exact']
          if exact.include?(message)
            raise(exact[message], feedback)
          end
          broad = self.exceptions['broad']
          broadKey = self.findBroadlyMatchedKey(broad, message)
          if broadKey != nil
            raise(broad[broadKey], feedback)
          end
          raise(ExchangeError, feedback) # unknown message
        end
      end
    end
  end
end
