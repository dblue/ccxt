# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Kucoin < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'kucoin',
        'name' => 'KuCoin',
        'countries' => ['SC'],
        'rateLimit' => 334,
        'version' => 'v2',
        'certified' => true,
        'comment' => 'Platform 2.0',
        'has' => {
          'fetchMarkets' => true,
          'fetchCurrencies' => true,
          'fetchTicker' => true,
          'fetchTickers' => true,
          'fetchOrderBook' => true,
          'fetchOrder' => true,
          'fetchClosedOrders' => true,
          'fetchOpenOrders' => true,
          'fetchDepositAddress' => true,
          'createDepositAddress' => true,
          'withdraw' => true,
          'fetchDeposits' => true,
          'fetchWithdrawals' => true,
          'fetchBalance' => true,
          'fetchTrades' => true,
          'fetchMyTrades' => true,
          'createOrder' => true,
          'cancelOrder' => true,
          'fetchAccounts' => true,
          'fetchFundingFee' => true,
          'fetchOHLCV' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/57369448-3cc3aa80-7196-11e9-883e-5ebeb35e4f57.jpg',
          'referral' => 'https://www.kucoin.com/ucenter/signup?rcode=E5wkqe',
          'api' => {
            'public' => 'https://openapi-v2.kucoin.com',
            'private' => 'https://openapi-v2.kucoin.com'
          },
          'test' => {
            'public' => 'https://openapi-sandbox.kucoin.com',
            'private' => 'https://openapi-sandbox.kucoin.com'
          },
          'www' => 'https://www.kucoin.com',
          'doc' => [
            'https://docs.kucoin.com'
          ]
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true,
          'password' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'timestamp',
              'symbols',
              'market/allTickers',
              'market/orderbook/level{level}',
              'market/histories',
              'market/candles',
              'market/stats',
              'currencies',
              'currencies/{currency}'
            ],
            'post' => [
              'bullet-public'
            ]
          },
          'private' => {
            'get' => [
              'accounts',
              'accounts/{accountId}',
              'accounts/{accountId}/ledgers',
              'accounts/{accountId}/holds',
              'deposit-addresses',
              'deposits',
              'hist-deposits',
              'hist-orders',
              'hist-withdrawals',
              'withdrawals',
              'withdrawals/quotas',
              'orders',
              'orders/{orderId}',
              'fills',
              'limit/fills'
            ],
            'post' => [
              'accounts',
              'accounts/inner-transfer',
              'deposit-addresses',
              'withdrawals',
              'orders',
              'bullet-private'
            ],
            'delete' => [
              'withdrawals/{withdrawalId}',
              'orders/{orderId}'
            ]
          }
        },
        'timeframes' => {
          '1m' => '1min',
          '3m' => '3min',
          '5m' => '5min',
          '15m' => '15min',
          '30m' => '30min',
          '1h' => '1hour',
          '2h' => '2hour',
          '4h' => '4hour',
          '6h' => '6hour',
          '8h' => '8hour',
          '12h' => '12hour',
          '1d' => '1day',
          '1w' => '1week'
        },
        'exceptions' => {
          'order_not_exist' => OrderNotFound, # {"code":"order_not_exist","msg":"order_not_exist"} ¯\_(ツ)_/¯
          'order_not_exist_or_not_allow_to_cancel' => InvalidOrder, # {"code":"400100","msg":"order_not_exist_or_not_allow_to_cancel"}
          'Order size below the minimum requirement.' => InvalidOrder, # {"code":"400100","msg":"Order size below the minimum requirement."}
          'The withdrawal amount is below the minimum requirement.' => ExchangeError, # {"code":"400100","msg":"The withdrawal amount is below the minimum requirement."}
          '400' => BadRequest,
          '401' => AuthenticationError,
          '403' => NotSupported,
          '404' => NotSupported,
          '405' => NotSupported,
          '429' => DDoSProtection,
          '500' => ExchangeError,
          '503' => ExchangeNotAvailable,
          '200004' => InsufficientFunds,
          '260100' => InsufficientFunds, # {"code":"260100","msg":"account.noBalance"}
          '300000' => InvalidOrder,
          '400001' => AuthenticationError,
          '400002' => InvalidNonce,
          '400003' => AuthenticationError,
          '400004' => AuthenticationError,
          '400005' => AuthenticationError,
          '400006' => AuthenticationError,
          '400007' => AuthenticationError,
          '400008' => NotSupported,
          '400100' => ArgumentsRequired,
          '411100' => AccountSuspended,
          '500000' => ExchangeError
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'taker' => 0.001,
            'maker' => 0.001
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {},
            'deposit' => {}
          }
        },
        'commonCurrencies' => {
          'HOT' => 'HOTNOW'
        },
        'options' => {
          'version' => 'v1',
          'symbolSeparator' => '-'
        }
      })
    end

    def nonce
      return self.milliseconds
    end

    async def load_time_difference
      response = await{ self.publicGetTimestamp }
      after = self.milliseconds
      kucoinTime = self.safe_integer(response, 'data')
      self.options['timeDifference'] = (after - kucoinTime).to_i
      return self.options['timeDifference']
    end

    async def fetch_markets(params = {})
      response = await{ self.publicGetSymbols(params) }
      #
      # { quoteCurrency => 'BTC',
      #   symbol => 'KCS-BTC',
      #   quoteMaxSize => '9999999',
      #   quoteIncrement => '0.000001',
      #   baseMinSize => '0.01',
      #   quoteMinSize => '0.00001',
      #   enableTrading => true,
      #   priceIncrement => '0.00000001',
      #   name => 'KCS-BTC',
      #   baseIncrement => '0.01',
      #   baseMaxSize => '9999999',
      #   baseCurrency => 'KCS' }
      #
      data = response['data']
      result = []
      for i in (0...data.length)
        market = data[i]
        id = market['name']
        baseId = market['baseCurrency']
        quoteId = market['quoteCurrency']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        active = market['enableTrading']
        baseMaxSize = self.safe_float(market, 'baseMaxSize')
        baseMinSize = self.safe_float(market, 'baseMinSize')
        quoteMaxSize = self.safe_float(market, 'quoteMaxSize')
        quoteMinSize = self.safe_float(market, 'quoteMinSize')
        # quoteIncrement = self.safe_float(market, 'quoteIncrement')
        precision = {
          'amount' => self.precision_from_string(self.safe_string(market, 'baseIncrement')),
          'price' => self.precision_from_string(self.safe_string(market, 'priceIncrement'))
        }
        limits = {
          'amount' => {
            'min' => baseMinSize,
            'max' => baseMaxSize
          },
          'price' => {
            'min' => self.safe_float(market, 'priceIncrement'),
            'max' => quoteMaxSize / baseMinSize
          },
          'cost' => {
            'min' => quoteMinSize,
            'max' => quoteMaxSize
          }
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'base' => base,
          'quote' => quote,
          'active' => active,
          'precision' => precision,
          'limits' => limits,
          'info' => market
        })
      end
      return result
    end

    async def fetch_currencies(params = {})
      response = await{ self.publicGetCurrencies(params) }
      #
      # { precision => 10,
      #   name => 'KCS',
      #   fullName => 'KCS shares',
      #   currency => 'KCS' }
      #
      responseData = response['data']
      result = {}
      for i in (0...responseData.length)
        entry = responseData[i]
        id = self.safe_string(entry, 'name')
        name = entry['fullName']
        code = self.common_currency_code(id)
        precision = self.safe_integer(entry, 'precision')
        result[code] = {
          'id' => id,
          'name' => name,
          'code' => code,
          'precision' => precision,
          'info' => entry
        }
      end
      return result
    end

    async def fetch_accounts(params = {})
      response = await{ self.privateGetAccounts(params) }
      #
      #     { code =>   "200000",
      #       data => [{   balance => "0.00009788",
      #                 available => "0.00009788",
      #                     holds => "0",
      #                  currency => "BTC",
      #                        id => "5c6a4fd399a1d81c4f9cc4d0",
      #                      type => "trade"                     },
      #               ...,
      #               {   balance => "0.00000001",
      #                 available => "0.00000001",
      #                     holds => "0",
      #                  currency => "ETH",
      #                        id => "5c6a49ec99a1d819392e8e9f",
      #                      type => "trade"                     }  ] }
      #
      data = self.safe_value(response, 'data')
      result = []
      for i in (0...data.length)
        account = data[i]
        accountId = self.safe_string(account, 'id')
        currencyId = self.safe_string(account, 'currency')
        code = self.common_currency_code(currencyId)
        type = self.safe_string(account, 'type')  # main or trade
        result.push({
          'id' => accountId,
          'type' => type,
          'currency' => code,
          'info' => account
        })
      end
      return result
    end

    async def fetch_funding_fee(code, params = {})
      currencyId = self.currencyId(code)
      request = {
        'currency' => currencyId
      }
      response = await{ self.privateGetWithdrawalsQuotas(self.shallow_extend(request, params)) }
      data = response['data']
      withdrawFees = {}
      withdrawFees[code] = self.safe_float(data, 'withdrawMinFee')
      return {
        'info' => response,
        'withdraw' => withdrawFees,
        'deposit' => {}
      }
    end

    def parse_ticker(ticker, market = nil)
      #
      #     {
      #         'buy' => '0.00001168',
      #         'changePrice' => '-0.00000018',
      #         'changeRate' => '-0.0151',
      #         'datetime' => 1550661146316,
      #         'high' => '0.0000123',
      #         'last' => '0.00001169',
      #         'low' => '0.00001159',
      #         'sell' => '0.00001182',
      #         'symbol' => 'LOOM-BTC',
      #         'vol' => '44399.5669'
      #     }
      #
      percentage = self.safe_float(ticker, 'changeRate')
      if percentage != nil
        percentage = percentage * 100
      end
      last = self.safe_float(ticker, 'last')
      symbol = nil
      marketId = self.safe_string(ticker, 'symbol')
      if marketId != nil
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
          symbol = market['symbol']
        else
          baseId, quoteId = marketId.split('-')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
      end
      if symbol.nil?
        if market != nil
          symbol = market['symbol']
        end
      end
      return {
        'symbol' => symbol,
        'timestamp' => nil,
        'datetime' => nil,
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'open'),
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => self.safe_float(ticker, 'changePrice'),
        'percentage' => percentage,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => self.safe_float(ticker, 'volValue'),
        'info' => ticker
      }
    end

    async def fetch_tickers(symbols = nil, params = {})
      await{ self.load_markets }
      response = await{ self.publicGetMarketAllTickers(params) }
      #
      #     {
      #         "code" => "200000",
      #         "data" => {
      #             "date" => 1550661940645,
      #             "ticker" => [
      #                 'buy' => '0.00001168',
      #                 'changePrice' => '-0.00000018',
      #                 'changeRate' => '-0.0151',
      #                 'datetime' => 1550661146316,
      #                 'high' => '0.0000123',
      #                 'last' => '0.00001169',
      #                 'low' => '0.00001159',
      #                 'sell' => '0.00001182',
      #                 'symbol' => 'LOOM-BTC',
      #                 'vol' => '44399.5669'
      #             },
      #         ]
      #     }
      #
      data = self.safe_value(response, 'data', {})
      tickers = self.safe_value(data, 'ticker', [])
      result = {}
      for i in (0...tickers.length)
        ticker = self.parse_ticker(tickers[i])
        symbol = self.safe_string(ticker, 'symbol')
        if symbol != nil
          result[symbol] = ticker
        end
      end
      return result
    end

    async def fetch_ticker(symbol, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      request = {
        'symbol' => market['id']
      }
      response = await{ self.publicGetMarketStats(self.shallow_extend(request, params)) }
      #
      #     {
      #         "code" => "200000",
      #         "data" => {
      #             'buy' => '0.00001168',
      #             'changePrice' => '-0.00000018',
      #             'changeRate' => '-0.0151',
      #             'datetime' => 1550661146316,
      #             'high' => '0.0000123',
      #             'last' => '0.00001169',
      #             'low' => '0.00001159',
      #             'sell' => '0.00001182',
      #             'symbol' => 'LOOM-BTC',
      #             'vol' => '44399.5669'
      #         },
      #     }
      #
      return self.parse_ticker(response['data'], market)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      #
      #     [
      #         "1545904980",             # Start time of the candle cycle
      #         "0.058",                  # opening price
      #         "0.049",                  # closing price
      #         "0.058",                  # highest price
      #         "0.049",                  # lowest price
      #         "0.018",                  # base volume
      #         "0.000945",               # quote volume
      #     ]
      #
      return [
        (ohlcv[0]).to_i * 1000,
        ohlcv[1].to_f,
        ohlcv[3].to_f,
        ohlcv[4].to_f,
        ohlcv[2].to_f,
        ohlcv[5].to_f
      ]
    end

    async def fetch_ohlcv(symbol, timeframe = '15m', since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      marketId = market['id']
      request = {
        'symbol' => marketId,
        'endAt' => self.seconds, # required param
        'type' => self.timeframes[timeframe]
      }
      if since != nil
        request['startAt'] = since / 1000.floor
      end
      response = await{ self.publicGetMarketCandles(self.shallow_extend(request, params)) }
      responseData = response['data']
      return self.parse_ohlcvs(responseData, market, timeframe, since, limit)
    end

    async def create_deposit_address(code, params = {})
      await{ self.load_markets }
      currencyId = self.currencyId(code)
      request = { 'currency' => currencyId }
      response = await{ self.privatePostDepositAddresses(self.shallow_extend(request, params)) }
      # BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
      # BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
      data = self.safe_value(response, 'data', {})
      address = self.safe_string(data, 'address')
      # BCH/BSV is returned with a "bitcoincash:" prefix, which we cut off here and only keep the address
      address = address.gsub('bitcoincash:', '')
      tag = self.safe_string(data, 'memo')
      self.check_address(address)
      return {
        'info' => response,
        'currency' => code,
        'address' => address,
        'tag' => tag
      }
    end

    async def fetch_deposit_address(code, params = {})
      await{ self.load_markets }
      currencyId = self.currencyId(code)
      request = { 'currency' => currencyId }
      response = await{ self.privateGetDepositAddresses(self.shallow_extend(request, params)) }
      # BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
      # BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
      data = self.safe_value(response, 'data', {})
      address = self.safe_string(data, 'address')
      # BCH/BSV is returned with a "bitcoincash:" prefix, which we cut off here and only keep the address
      if address != nil
        address = address.gsub('bitcoincash:', '')
      end
      tag = self.safe_string(data, 'memo')
      self.check_address(address)
      return {
        'info' => response,
        'currency' => code,
        'address' => address,
        'tag' => tag
      }
    end

    async def fetch_order_book(symbol, limit = nil, params = {})
      await{ self.load_markets }
      marketId = self.market_id(symbol)
      request = self.shallow_extend({ 'symbol' => marketId, 'level' => 2 }, params)
      response = await{ self.publicGetMarketOrderbookLevelLevel(request) }
      #
      # { sequence => '1547731421688',
      #   asks => [['5c419328ef83c75456bd615c', '0.9', '0.09'], ...],
      #   bids => [['5c419328ef83c75456bd615c', '0.9', '0.09'], ...] }
      #
      data = response['data']
      timestamp = self.safe_integer(data, 'sequence')
      # level can be a string such as 2_20 or 2_100
      levelString = self.safe_string(request, 'level')
      levelParts = levelString.split('_')
      level = (levelParts[0]).to_i
      return self.parse_order_book(data, timestamp, 'bids', 'asks', level - 2, level - 1)
    end

    async def create_order(symbol, type, side, amount, price = nil, params = {})
      await{ self.load_markets }
      marketId = self.market_id(symbol)
      # required param, cannot be used twice
      clientOid = self.uuid
      request = {
        'clientOid' => clientOid,
        'side' => side,
        'size' => self.amount_to_precision(symbol, amount),
        'symbol' => marketId,
        'type' => type
      }
      if type != 'market'
        request['price'] = self.price_to_precision(symbol, price)
      end
      response = await{ self.privatePostOrders(self.shallow_extend(request, params)) }
      responseData = response['data']
      return {
        'id' => responseData['orderId'],
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'status' => 'open',
        'clientOid' => clientOid,
        'info' => responseData
      }
    end

    async def cancel_order(id, symbol = nil, params = {})
      request = { 'orderId' => id }
      response = await{ self.privateDeleteOrdersOrderId(self.shallow_extend(request, params)) }
      return response
    end

    async def fetch_orders_by_status(status, symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      request = {
        'status' => status
      }
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['symbol'] = market['id']
      end
      if since != nil
        request['startAt'] = since
      end
      if limit != nil
        request['pageSize'] = limit
      end
      response = await{ self.privateGetOrders(self.shallow_extend(request, params)) }
      #
      #     {
      #         code => '200000',
      #         data => {
      #             "currentPage" => 1,
      #             "pageSize" => 1,
      #             "totalNum" => 153408,
      #             "totalPage" => 153408,
      #             "items" => [
      #                 {
      #                     "id" => "5c35c02703aa673ceec2a168",   #orderid
      #                     "symbol" => "BTC-USDT",   #symbol
      #                     "opType" => "DEAL",      # operation type,deal is pending order,cancel is cancel order
      #                     "type" => "limit",       # order type,e.g. limit,markrt,stop_limit.
      #                     "side" => "buy",         # transaction direction,include buy and sell
      #                     "price" => "10",         # order price
      #                     "size" => "2",           # order quantity
      #                     "funds" => "0",          # order funds
      #                     "dealFunds" => "0.166",  # deal funds
      #                     "dealSize" => "2",       # deal quantity
      #                     "fee" => "0",            # fee
      #                     "feeCurrency" => "USDT", # charge fee currency
      #                     "stp" => "",             # self trade prevention,include CN,CO,DC,CB
      #                     "stop" => "",            # stop type
      #                     "stopTriggered" => false,  # stop order is triggered
      #                     "stopPrice" => "0",      # stop price
      #                     "timeInForce" => "GTC",  # time InForce,include GTC,GTT,IOC,FOK
      #                     "postOnly" => false,     # postOnly
      #                     "hidden" => false,       # hidden order
      #                     "iceberg" => false,      # iceberg order
      #                     "visibleSize" => "0",    # display quantity for iceberg order
      #                     "cancelAfter" => 0,      # cancel orders time，requires timeInForce to be GTT
      #                     "channel" => "IOS",      # order source
      #                     "clientOid" => "",       # user-entered order unique mark
      #                     "remark" => "",          # remark
      #                     "tags" => "",            # tag order source
      #                     "isActive" => false,     # status before unfilled or uncancelled
      #                     "cancelExist" => false,   # order cancellation transaction record
      #                     "createdAt" => 1547026471000  # time
      #                 },
      #             ]
      #         }
      #    }
      responseData = self.safe_value(response, 'data', {})
      orders = self.safe_value(responseData, 'items', [])
      return self.parse_orders(orders, market, since, limit)
    end

    async def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return await{ self.fetch_orders_by_status('done', symbol, since, limit, params) }
    end

    async def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return await{ self.fetch_orders_by_status('active', symbol, since, limit, params) }
    end

    async def fetch_order(id, symbol = nil, params = {})
      await{ self.load_markets }
      request = {
        'orderId' => id
      }
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      response = await{ self.privateGetOrdersOrderId(self.shallow_extend(request, params)) }
      responseData = response['data']
      return self.parse_order(responseData, market)
    end

    def parse_order(order, market = nil)
      #
      # fetchOpenOrders, fetchClosedOrders
      #
      #     {
      #         "id" => "5c35c02703aa673ceec2a168",   #orderid
      #         "symbol" => "BTC-USDT",   #symbol
      #         "opType" => "DEAL",      # operation type,deal is pending order,cancel is cancel order
      #         "type" => "limit",       # order type,e.g. limit,markrt,stop_limit.
      #         "side" => "buy",         # transaction direction,include buy and sell
      #         "price" => "10",         # order price
      #         "size" => "2",           # order quantity
      #         "funds" => "0",          # order funds
      #         "dealFunds" => "0.166",  # deal funds
      #         "dealSize" => "2",       # deal quantity
      #         "fee" => "0",            # fee
      #         "feeCurrency" => "USDT", # charge fee currency
      #         "stp" => "",             # self trade prevention,include CN,CO,DC,CB
      #         "stop" => "",            # stop type
      #         "stopTriggered" => false,  # stop order is triggered
      #         "stopPrice" => "0",      # stop price
      #         "timeInForce" => "GTC",  # time InForce,include GTC,GTT,IOC,FOK
      #         "postOnly" => false,     # postOnly
      #         "hidden" => false,       # hidden order
      #         "iceberg" => false,      # iceberg order
      #         "visibleSize" => "0",    # display quantity for iceberg order
      #         "cancelAfter" => 0,      # cancel orders time，requires timeInForce to be GTT
      #         "channel" => "IOS",      # order source
      #         "clientOid" => "",       # user-entered order unique mark
      #         "remark" => "",          # remark
      #         "tags" => "",            # tag order source
      #         "isActive" => false,     # status before unfilled or uncancelled
      #         "cancelExist" => false,   # order cancellation transaction record
      #         "createdAt" => 1547026471000  # time
      #     }
      #
      symbol = nil
      marketId = self.safe_string(order, 'symbol')
      if marketId != nil
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
          symbol = market['symbol']
        else
          baseId, quoteId = marketId.split('-')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
        market = self.safe_value(self.markets_by_id, marketId)
      end
      if symbol.nil?
        if market != nil
          symbol = market['symbol']
        end
      end
      orderId = self.safe_string(order, 'id')
      type = self.safe_string(order, 'type')
      timestamp = self.safe_integer(order, 'createdAt')
      datetime = self.iso8601(timestamp)
      price = self.safe_float(order, 'price')
      side = self.safe_string(order, 'side')
      feeCurrencyId = self.safe_string(order, 'feeCurrency')
      feeCurrency = self.common_currency_code(feeCurrencyId)
      feeCost = self.safe_float(order, 'fee')
      amount = self.safe_float(order, 'size')
      filled = self.safe_float(order, 'dealSize')
      cost = self.safe_float(order, 'dealFunds')
      remaining = amount - filled
      # bool
      status = order['isActive'] ? 'open' : 'closed'
      fee = {
        'currency' => feeCurrency,
        'cost' => feeCost
      }
      if type == 'market'
        if price == 0.0
          if (cost != nil) && (filled != nil)
            if (cost > 0) && (filled > 0)
              price = cost / filled
            end
          end
        end
      end
      return {
        'id' => orderId,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'amount' => amount,
        'price' => price,
        'cost' => cost,
        'filled' => filled,
        'remaining' => remaining,
        'timestamp' => timestamp,
        'datetime' => datetime,
        'fee' => fee,
        'status' => status,
        'info' => order
      }
    end

    async def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      request = {}
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['symbol'] = market['id']
      end
      if limit != nil
        request['pageSize'] = limit
      end
      method = 'privateGetFills'
      if since != nil
        # if since is earlier than 2019-02-18T00:00:00Z
        if since < 1550448000000
          request['startAt'] = (since / 1000).to_i
          # despite that self endpoint is called `HistOrders`
          # it returns historical trades instead of orders
          method = 'privateGetHistOrders'
        else
          request['startAt'] = since
        end
      end
      response = await{ self.send_wrapper(method, self.shallow_extend(request, params)) }
      #
      #     {
      #         "currentPage" => 1,
      #         "pageSize" => 50,
      #         "totalNum" => 1,
      #         "totalPage" => 1,
      #         "items" => [
      #             {
      #                 "symbol":"BTC-USDT",       # symbol
      #                 "tradeId":"5c35c02709e4f67d5266954e",        # trade id
      #                 "orderId":"5c35c02703aa673ceec2a168",        # order id
      #                 "counterOrderId":"5c1ab46003aa676e487fa8e3", # counter order id
      #                 "side":"buy",              # transaction direction,include buy and sell
      #                 "liquidity":"taker",       # include taker and maker
      #                 "forceTaker":true,         # forced to become taker
      #                 "price":"0.083",           # order price
      #                 "size":"0.8424304",        # order quantity
      #                 "funds":"0.0699217232",    # order funds
      #                 "fee":"0",                 # fee
      #                 "feeRate":"0",             # fee rate
      #                 "feeCurrency":"USDT",      # charge fee currency
      #                 "stop":"",                 # stop type
      #                 "type":"limit",            # order type, e.g. limit, market, stop_limit.
      #                 "createdAt":1547026472000  # time
      #             },
      #             #------------------------------------------------------
      #             # v1(historical) trade response structure
      #             {
      #                 "symbol" => "SNOV-ETH",
      #                 "dealPrice" => "0.0000246",
      #                 "dealValue" => "0.018942",
      #                 "amount" => "770",
      #                 "fee" => "0.00001137",
      #                 "side" => "sell",
      #                 "createdAt" => 1540080199
      #                 "id":"5c4d389e4c8c60413f78e2e5",
      #             }
      #         ]
      #     }
      #
      data = self.safe_value(response, 'data', {})
      trades = self.safe_value(data, 'items', [])
      return self.parse_trades(trades, market, since, limit)
    end

    async def fetch_trades(symbol, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      request = {
        'symbol' => market['id']
      }
      if since != nil
        request['startAt'] = since / 1000.floor
      end
      if limit != nil
        request['pageSize'] = limit
      end
      response = await{ self.publicGetMarketHistories(self.shallow_extend(request, params)) }
      #
      #     {
      #         "code" => "200000",
      #         "data" => [
      #             {
      #                 "sequence" => "1548764654235",
      #                 "side" => "sell",
      #                 "size":"0.6841354",
      #                 "price":"0.03202",
      #                 "time":1548848575203567174
      #             }
      #         ]
      #     }
      #
      trades = self.safe_value(response, 'data', [])
      return self.parse_trades(trades, market, since, limit)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #     {
      #         "sequence" => "1548764654235",
      #         "side" => "sell",
      #         "size":"0.6841354",
      #         "price":"0.03202",
      #         "time":1548848575203567174
      #     }
      #
      # fetchMyTrades(private) v2
      #
      #     {
      #         "symbol":"BTC-USDT",
      #         "tradeId":"5c35c02709e4f67d5266954e",
      #         "orderId":"5c35c02703aa673ceec2a168",
      #         "counterOrderId":"5c1ab46003aa676e487fa8e3",
      #         "side":"buy",
      #         "liquidity":"taker",
      #         "forceTaker":true,
      #         "price":"0.083",
      #         "size":"0.8424304",
      #         "funds":"0.0699217232",
      #         "fee":"0",
      #         "feeRate":"0",
      #         "feeCurrency":"USDT",
      #         "stop":"",
      #         "type":"limit",
      #         "createdAt":1547026472000
      #     }
      #
      # fetchMyTrades(private) v1(historical)
      #
      #     {
      #         "symbol" => "SNOV-ETH",
      #         "dealPrice" => "0.0000246",
      #         "dealValue" => "0.018942",
      #         "amount" => "770",
      #         "fee" => "0.00001137",
      #         "side" => "sell",
      #         "createdAt" => 1540080199
      #         "id":"5c4d389e4c8c60413f78e2e5",
      #     }
      #
      symbol = nil
      marketId = self.safe_string(trade, 'symbol')
      if marketId != nil
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
          symbol = market['symbol']
        else
          baseId, quoteId = marketId.split('-')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
      end
      if symbol.nil?
        if market != nil
          symbol = market['symbol']
        end
      end
      id = self.safe_string_2(trade, 'tradeId', 'id')
      if id != nil
        id = id.to_s
      end
      orderId = self.safe_string(trade, 'orderId')
      takerOrMaker = self.safe_string(trade, 'liquidity')
      amount = self.safe_float_2(trade, 'size', 'amount')
      timestamp = self.safe_integer(trade, 'time')
      if timestamp != nil
        timestamp = (timestamp / 1000000).to_i
      else
        timestamp = self.safe_integer(trade, 'createdAt')
        # if it's a historical v1 trade, the exchange returns timestamp in seconds
        if takerOrMaker.nil? && timestamp != nil
          timestamp = timestamp * 1000
        end
      end
      price = self.safe_float_2(trade, 'price', 'dealPrice')
      side = self.safe_string(trade, 'side')
      fee = nil
      feeCost = self.safe_float(trade, 'fee')
      if feeCost != nil
        feeCurrencyId = self.safe_string(trade, 'feeCurrency')
        feeCurrency = self.common_currency_code(feeCurrencyId)
        if feeCurrency.nil?
          if market != nil
            feeCurrency = (side == 'sell') ? market['quote'] : market['base']
          end
        end
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency,
          'rate' => self.safe_float(trade, 'feeRate')
        }
      end
      type = self.safe_string(trade, 'type')
      cost = self.safe_float_2(trade, 'funds', 'dealValue')
      if cost.nil?
        if amount != nil
          if price != nil
            cost = amount * price
          end
        end
      end
      return {
        'info' => trade,
        'id' => id,
        'order' => orderId,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => type,
        'takerOrMaker' => takerOrMaker,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    async def withdraw(code, amount, address, tag = nil, params = {})
      await{ self.load_markets }
      self.check_address(address)
      currency = self.currencyId(code)
      request = {
        'currency' => currency,
        'address' => address,
        'amount' => amount
      }
      if tag != nil
        request['memo'] = tag
      end
      response = await{ self.privatePostWithdrawals(self.shallow_extend(request, params)) }
      #
      # { "withdrawalId" => "5bffb63303aa675e8bbe18f9" }
      #
      return {
        'id' => self.safe_string(response, 'withdrawalId'),
        'info' => response
      }
    end

    def parse_transaction_status(status)
      statuses = {
        'SUCCESS' => 'ok',
        'PROCESSING' => 'ok',
        'FAILURE' => 'failed'
      }
      return self.safe_string(statuses, status)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchDeposits
      #
      #     {
      #         "address" => "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
      #         "memo" => "5c247c8a03aa677cea2a251d",
      #         "amount" => 1,
      #         "fee" => 0.0001,
      #         "currency" => "KCS",
      #         "isInner" => false,
      #         "walletTxId" => "5bbb57386d99522d9f954c5a@test004",
      #         "status" => "SUCCESS",
      #         "createdAt" => 1544178843000,
      #         "updatedAt" => 1544178891000
      #     }
      #
      # fetchWithdrawals
      #
      #     {
      #         "id" => "5c2dc64e03aa675aa263f1ac",
      #         "address" => "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
      #         "memo" => "",
      #         "currency" => "ETH",
      #         "amount" => 1.0000000,
      #         "fee" => 0.0100000,
      #         "walletTxId" => "3e2414d82acce78d38be7fe9",
      #         "isInner" => false,
      #         "status" => "FAILURE",
      #         "createdAt" => 1546503758000,
      #         "updatedAt" => 1546504603000
      #     }
      #
      code = nil
      currencyId = self.safe_string(transaction, 'currency')
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency != nil
        code = currency['code']
      else
        code = self.common_currency_code(currencyId)
      end
      address = self.safe_string(transaction, 'address')
      amount = self.safe_float(transaction, 'amount')
      txid = self.safe_string(transaction, 'walletTxId')
      if txid != nil
        txidParts = txid.split('@')
        numTxidParts = txidParts.length
        if numTxidParts > 1
          if address.nil?
            if txidParts[1].length > 1
              address = txidParts[1]
            end
          end
        end
        txid = txidParts[0]
      end
      type = txid.nil? ? 'withdrawal' : 'deposit'
      rawStatus = self.safe_string(transaction, 'status')
      status = self.parse_transaction_status(rawStatus)
      fee = nil
      feeCost = self.safe_float(transaction, 'fee')
      if feeCost != nil
        rate = nil
        if amount != nil
          rate = feeCost / amount
        end
        fee = {
          'cost' => feeCost,
          'rate' => rate,
          'currency' => code
        }
      end
      tag = self.safe_string(transaction, 'memo')
      timestamp = self.safe_integer_2(transaction, 'createdAt', 'createAt')
      id = self.safe_string(transaction, 'id')
      updated = self.safe_integer(transaction, 'updatedAt')
      isV1 = !(transaction.include?('createdAt'))
      # if it's a v1 structure
      if isV1
        type = (transaction.include?('address')) ? 'withdrawal' : 'deposit'
        if timestamp != nil
          timestamp = timestamp * 1000
        end
        if updated != nil
          updated = updated * 1000
        end
      end
      return {
        'id' => id,
        'address' => address,
        'tag' => tag,
        'currency' => code,
        'amount' => amount,
        'txid' => txid,
        'type' => type,
        'status' => status,
        'fee' => fee,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'updated' => updated,
        'info' => transaction
      }
    end

    async def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      request = {}
      currency = nil
      if code != nil
        currency = self.currency(code)
        request['currency'] = currency['id']
      end
      if limit != nil
        request['pageSize'] = limit
      end
      method = 'privateGetDeposits'
      if since != nil
        # if since is earlier than 2019-02-18T00:00:00Z
        if since < 1550448000000
          request['startAt'] = (since / 1000).to_i
          method = 'privateGetHistDeposits'
        else
          request['startAt'] = since
        end
      end
      response = await{ self.send_wrapper(method, self.shallow_extend(request, params)) }
      #
      #     {
      #         code => '200000',
      #         data => {
      #             "currentPage" => 1,
      #             "pageSize" => 5,
      #             "totalNum" => 2,
      #             "totalPage" => 1,
      #             "items" => [
      #                 #--------------------------------------------------
      #                 # version 2 deposit response structure
      #                 {
      #                     "address" => "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
      #                     "memo" => "5c247c8a03aa677cea2a251d",
      #                     "amount" => 1,
      #                     "fee" => 0.0001,
      #                     "currency" => "KCS",
      #                     "isInner" => false,
      #                     "walletTxId" => "5bbb57386d99522d9f954c5a@test004",
      #                     "status" => "SUCCESS",
      #                     "createdAt" => 1544178843000,
      #                     "updatedAt" => 1544178891000
      #                 },
      #                 #--------------------------------------------------
      #                 # version 1(historical) deposit response structure
      #                 {
      #                     "currency" => "BTC",
      #                     "createAt" => 1528536998,
      #                     "amount" => "0.03266638",
      #                     "walletTxId" => "55c643bc2c68d6f17266383ac1be9e454038864b929ae7cee0bc408cc5c869e8@12ffGWmMMD1zA1WbFm7Ho3JZ1w6NYXjpFk@234",
      #                     "isInner" => false,
      #                     "status" => "SUCCESS",
      #                 }
      #             ]
      #         }
      #     }
      #
      responseData = response['data']['items']
      return self.parseTransactions(responseData, currency, since, limit, { 'type' => 'deposit' })
    end

    async def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      request = {}
      currency = nil
      if code != nil
        currency = self.currency(code)
        request['currency'] = currency['id']
      end
      if limit != nil
        request['pageSize'] = limit
      end
      method = 'privateGetWithdrawals'
      if since != nil
        # if since is earlier than 2019-02-18T00:00:00Z
        if since < 1550448000000
          request['startAt'] = (since / 1000).to_i
          method = 'privateGetHistWithdrawals'
        else
          request['startAt'] = since
        end
      end
      response = await{ self.send_wrapper(method, self.shallow_extend(request, params)) }
      #
      #     {
      #         code => '200000',
      #         data => {
      #             "currentPage" => 1,
      #             "pageSize" => 5,
      #             "totalNum" => 2,
      #             "totalPage" => 1,
      #             "items" => [
      #                 #--------------------------------------------------
      #                 # version 2 withdrawal response structure
      #                 {
      #                     "id" => "5c2dc64e03aa675aa263f1ac",
      #                     "address" => "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
      #                     "memo" => "",
      #                     "currency" => "ETH",
      #                     "amount" => 1.0000000,
      #                     "fee" => 0.0100000,
      #                     "walletTxId" => "3e2414d82acce78d38be7fe9",
      #                     "isInner" => false,
      #                     "status" => "FAILURE",
      #                     "createdAt" => 1546503758000,
      #                     "updatedAt" => 1546504603000
      #                 },
      #                 #--------------------------------------------------
      #                 # version 1(historical) withdrawal response structure
      #                 {
      #                     "currency" => "BTC",
      #                     "createAt" => 1526723468,
      #                     "amount" => "0.534",
      #                     "address" => "33xW37ZSW4tQvg443Pc7NLCAs167Yc2XUV",
      #                     "walletTxId" => "aeacea864c020acf58e51606169240e96774838dcd4f7ce48acf38e3651323f4",
      #                     "isInner" => false,
      #                     "status" => "SUCCESS"
      #                 }
      #             ]
      #         }
      #     }
      #
      responseData = response['data']['items']
      return self.parseTransactions(responseData, currency, since, limit, { 'type' => 'withdrawal' })
    end

    async def fetch_balance(params = {})
      await{ self.load_markets }
      request = {
        'type' => 'trade'
      }
      response = await{ self.privateGetAccounts(self.shallow_extend(request, params)) }
      responseData = response['data']
      result = { 'info' => responseData }
      for i in (0...responseData.length)
        entry = responseData[i]
        currencyId = entry['currency']
        code = self.common_currency_code(currencyId)
        account = {}
        account['total'] = self.safe_float(entry, 'balance', 0)
        account['free'] = self.safe_float(entry, 'available', 0)
        account['used'] = self.safe_float(entry, 'holds', 0)
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      #
      # the v2 URL is https://openapi-v2.kucoin.com/api/v1/endpoint
      #                                †                 ↑
      #
      endpoint = '/api/' + self.options['version'] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      endpart = ''
      headers = headers != nil ? headers : {}
      if query
        if method != 'GET'
          body = self.json(query)
          endpart = body
          headers['Content-Type'] = 'application/json'
        else
          endpoint += '?' + self.urlencode(query)
        end
      end
      url = self.urls['api'][api] + endpoint
      if api == 'private'
        self.check_required_credentials
        timestamp = self.nonce.to_s
        headers = self.shallow_extend({
          'KC-API-KEY' => self.apiKey,
          'KC-API-TIMESTAMP' => timestamp,
          'KC-API-PASSPHRASE' => self.password
        }, headers)
        payload = timestamp + method + endpoint + endpart
        signature = self.hmac(self.encode(payload), self.encode(self.secret), 'sha256', 'base64')
        headers['KC-API-SIGN'] = self.decode(signature)
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if !response
        return
      end
      #
      # bad
      #     { "code" => "400100", "msg" => "validation.createOrder.clientOidIsRequired" }
      # good
      #     { code => '200000', data => { ... }}
      #
      errorCode = self.safe_string(response, 'code')
      message = self.safe_string(response, 'msg')
      exceptionClass = self.safe_value_2(self.exceptions, message, errorCode)
      if exceptionClass != nil
        raise(exceptionClass, self.id + ' ' + message)
      end
    end
  end
end
