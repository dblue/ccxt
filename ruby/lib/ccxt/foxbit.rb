# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Foxbit < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'foxbit',
        'name' => 'FoxBit',
        'countries' => ['BR'],
        'has' => {
          'CORS' => false,
          'createMarketOrder' => false
        },
        'rateLimit' => 1000,
        'version' => 'v1',
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27991413-11b40d42-647f-11e7-91ee-78ced874dd09.jpg',
          'api' => {
            'public' => 'https://api.blinktrade.com/api',
            'private' => 'https://api.blinktrade.com/tapi'
          },
          'www' => 'https://foxbit.exchange',
          'doc' => 'https://blinktrade.com/docs'
        },
        'comment' => 'Blinktrade API',
        'api' => {
          'public' => {
            'get' => [
              '{currency}/ticker',    # ?crypto_currency=BTC
              '{currency}/orderbook', # ?crypto_currency=BTC
              '{currency}/trades',    # ?crypto_currency=BTC&since=<TIMESTAMP>&limit=<NUMBER>
            ]
          },
          'private' => {
            'post' => [
              'D',   # order
              'F',   # cancel order
              'U2',  # balance
              'U4',  # my orders
              'U6',  # withdraw
              'U18', # deposit
              'U24', # confirm withdrawal
              'U26', # list withdrawals
              'U30', # list deposits
              'U34', # ledger
              'U70', # cancel withdrawal
            ]
          }
        },
        'markets' => {
          'BTC/VEF' => { 'id' => 'BTCVEF', 'symbol' => 'BTC/VEF', 'base' => 'BTC', 'quote' => 'VEF', 'brokerId' => 1, 'broker' => 'SurBitcoin' },
          'BTC/VND' => { 'id' => 'BTCVND', 'symbol' => 'BTC/VND', 'base' => 'BTC', 'quote' => 'VND', 'brokerId' => 3, 'broker' => 'VBTC' },
          'BTC/BRL' => { 'id' => 'BTCBRL', 'symbol' => 'BTC/BRL', 'base' => 'BTC', 'quote' => 'BRL', 'brokerId' => 4, 'broker' => 'FoxBit' },
          'BTC/PKR' => { 'id' => 'BTCPKR', 'symbol' => 'BTC/PKR', 'base' => 'BTC', 'quote' => 'PKR', 'brokerId' => 8, 'broker' => 'UrduBit' },
          'BTC/CLP' => { 'id' => 'BTCCLP', 'symbol' => 'BTC/CLP', 'base' => 'BTC', 'quote' => 'CLP', 'brokerId' => 9, 'broker' => 'ChileBit' }
        },
        'options' => {
          'brokerId' => '4', # https://blinktrade.com/docs/#brokers
        }
      })
    end

    def fetch_balance(params = {})
      response = self.privatePostU2({
        'BalanceReqID' => self.nonce
      })
      balances = self.safe_value(response['Responses'], self.options['brokerId'])
      result = { 'info' => response }
      if balances != nil
        currencyIds = self.currencies_by_id.keys
        for i in (0...currencyIds.length)
          currencyId = currencyIds[i]
          currency = self.currencies_by_id[currencyId]
          code = currency['code']
          # we only set the balance for the currency if that currency is present in response
          # otherwise we will lose the info if the currency balance has been funded or traded or not
          if balances.include?(currencyId)
            account = self.account
            account['used'] = parse_float(balances[currencyId + '_locked']) * 1e-8
            account['total'] = parse_float(balances[currencyId]) * 1e-8
            account['free'] = account['total'] - account['used']
            result[code] = account
          end
        end
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      market = self.market(symbol)
      orderbook = self.publicGetCurrencyOrderbook(self.shallow_extend({
        'currency' => market['quote'],
        'crypto_currency' => market['base']
      }, params))
      return self.parse_order_book(orderbook)
    end

    def fetch_ticker(symbol, params = {})
      market = self.market(symbol)
      ticker = self.publicGetCurrencyTicker(self.shallow_extend({
        'currency' => market['quote'],
        'crypto_currency' => market['base']
      }, params))
      timestamp = self.milliseconds
      lowercaseQuote = market['quote'].downcase
      quoteVolume = 'vol_' + lowercaseQuote
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => parse_float(ticker[quoteVolume]),
        'info' => ticker
      }
    end

    def parse_trade(trade, market)
      timestamp = trade['date'] * 1000
      return {
        'id' => self.safe_string(trade, 'tid'),
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => trade['side'],
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetCurrencyTrades(self.shallow_extend({
        'currency' => market['quote'],
        'crypto_currency' => market['base']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      market = self.market(symbol)
      orderSide = (side == 'buy') ? '1' : '2'
      order = {
        'ClOrdID' => self.nonce,
        'Symbol' => market['id'],
        'Side' => orderSide,
        'OrdType' => '2',
        'Price' => price,
        'OrderQty' => amount,
        'BrokerID' => market['brokerId']
      }
      response = self.privatePostD(self.shallow_extend(order, params))
      indexed = self.index_by(response['Responses'], 'MsgType')
      execution = indexed['8']
      return {
        'info' => response,
        'id' => execution['OrderID']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostF(self.shallow_extend({
        'ClOrdID' => id
      }, params))
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        request = self.shallow_extend({ 'MsgType' => path }, query)
        body = self.json(request)
        headers = {
          'APIKey' => self.apiKey,
          'Nonce' => nonce,
          'Signature' => self.hmac(self.encode(nonce), self.encode(self.secret)),
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('Status')
        if response['Status'] != 200
          raise(ExchangeError, self.id + ' ' + self.json(response))
        end
      end
      return response
    end
  end
end
