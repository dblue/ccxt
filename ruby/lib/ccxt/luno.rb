# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Luno < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'luno',
        'name' => 'luno',
        'countries' => ['GB', 'SG', 'ZA'],
        'rateLimit' => 1000,
        'version' => '1',
        'has' => {
          'CORS' => false,
          'fetchTickers' => true,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchMyTrades' => true,
          'fetchTradingFee' => true,
          'fetchTradingFees' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg',
          'api' => 'https://api.mybitx.com/api',
          'www' => 'https://www.luno.com',
          'doc' => [
            'https://www.luno.com/en/api',
            'https://npmjs.org/package/bitx',
            'https://github.com/bausmeier/node-bitx'
          ]
        },
        'api' => {
          'public' => {
            'get' => [
              'orderbook',
              'orderbook_top',
              'ticker',
              'tickers',
              'trades'
            ]
          },
          'private' => {
            'get' => [
              'accounts/{id}/pending',
              'accounts/{id}/transactions',
              'balance',
              'fee_info',
              'funding_address',
              'listorders',
              'listtrades',
              'orders/{id}',
              'quotes/{id}',
              'withdrawals',
              'withdrawals/{id}'
            ],
            'post' => [
              'accounts',
              'postorder',
              'marketorder',
              'stoporder',
              'funding_address',
              'withdrawals',
              'send',
              'quotes',
              'oauth2/grant'
            ],
            'put' => [
              'quotes/{id}'
            ],
            'delete' => [
              'quotes/{id}',
              'withdrawals/{id}'
            ]
          }
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetTickers
      result = []
      for p in (0...markets['tickers'].length)
        market = markets['tickers'][p]
        id = market['pair']
        base = id[0...3]
        quote = id[3...6]
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetBalance
      wallets = response['balance']
      result = { 'info' => response }
      for b in (0...wallets.length)
        wallet = wallets[b]
        currency = self.common_currency_code(wallet['asset'])
        reserved = parse_float(wallet['reserved'])
        unconfirmed = parse_float(wallet['unconfirmed'])
        balance = parse_float(wallet['balance'])
        account = {
          'free' => 0.0,
          'used' => self.sum(reserved, unconfirmed),
          'total' => self.sum(balance, unconfirmed)
        }
        account['free'] = account['total'] - account['used']
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      method = 'publicGetOrderbook'
      if limit != nil
        if limit <= 100
          method += 'Top' # get just the top of the orderbook when limit is low
        end
      end
      orderbook = self.send_wrapper(method, self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      timestamp = orderbook['timestamp']
      return self.parse_order_book(orderbook, timestamp, 'bids', 'asks', 'price', 'volume')
    end

    def parse_order(order, market = nil)
      timestamp = order['creation_timestamp']
      status = (order['state'] == 'PENDING') ? 'open' : 'closed'
      side = (order['type'] == 'ASK') ? 'sell' : 'buy'
      if market.nil?
        market = self.find_market(order['pair'])
      end
      symbol = market['symbol']
      price = self.safe_float(order, 'limit_price')
      amount = self.safe_float(order, 'limit_volume')
      quoteFee = self.safe_float(order, 'fee_counter')
      baseFee = self.safe_float(order, 'fee_base')
      filled = self.safe_float(order, 'base')
      cost = self.safe_float(order, 'counter')
      remaining = nil
      if amount != nil
        if filled != nil
          remaining = maximum_wrapper(0, amount - filled)
        end
      end
      fee = { 'currency' => nil }
      if quoteFee
        fee['side'] = 'quote'
        fee['cost'] = quoteFee
      else
        fee['side'] = 'base'
        fee['cost'] = baseFee
      end
      return {
        'id' => order['order_id'],
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'filled' => filled,
        'cost' => cost,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => fee,
        'info' => order
      }
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privateGetOrdersId(self.shallow_extend({
        'id' => id
      }, params))
      return self.parse_order(response)
    end

    def fetch_orders_by_state(state = nil, symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      market = nil
      if state != nil
        request['state'] = state
      end
      if symbol != nil
        market = self.market(symbol)
        request['pair'] = market['id']
      end
      response = self.privateGetListorders(self.shallow_extend(request, params))
      orders = self.safe_value(response, 'orders', [])
      return self.parse_orders(orders, market, since, limit)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_state(nil, symbol, since, limit, params)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_state('PENDING', symbol, since, limit, params)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_state('COMPLETE', symbol, since, limit, params)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = ticker['timestamp']
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last_trade')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'rolling_24_hour_volume'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetTickers(params)
      tickers = self.index_by(response['tickers'], 'pair')
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        market = self.markets_by_id[id]
        symbol = market['symbol']
        ticker = tickers[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetTicker(self.shallow_extend({
        'pair' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      # For public trade data(is_buy == True) indicates 'buy' side but for private trade data
      # is_buy indicates maker or taker. The value of "type"(ASK/BID) indicate sell/buy side.
      # Private trade data includes ID field which public trade data does not.
      order = self.safe_string(trade, 'order_id')
      takerOrMaker = nil
      side = nil
      if order != nil
        side = (trade['type'] == 'ASK') ? 'sell' : 'buy'
        if side == 'sell' && trade['is_buy']
          takerOrMaker = 'maker'
        elsif side == 'buy' && !trade['is_buy']
          takerOrMaker = 'maker'
        else
          takerOrMaker = 'taker'
        end
      else
        side = (trade['is_buy']) ? 'buy' : 'sell'
      end
      feeBase = self.safe_float(trade, 'fee_base')
      feeCounter = self.safe_float(trade, 'fee_counter')
      feeCurrency = nil
      feeCost = nil
      if feeBase != nil
        if feeBase != 0.0
          feeCurrency = market['base']
          feeCost = feeBase
        end
      elsif feeCounter != nil
        if feeCounter != 0.0
          feeCurrency = market['quote']
          feeCost = feeCounter
        end
      end
      return {
        'info' => trade,
        'id' => nil,
        'timestamp' => trade['timestamp'],
        'datetime' => self.iso8601(trade['timestamp']),
        'symbol' => market['symbol'],
        'order' => order,
        'type' => nil,
        'side' => side,
        'takerOrMaker' => takerOrMaker,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'volume'),
        # Does not include potential fee costs
        'cost' => self.safe_float(trade, 'counter'),
        'fee' => {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'pair' => market['id']
      }
      if since != nil
        request['since'] = since
      end
      response = self.publicGetTrades(self.shallow_extend(request, params))
      trades = self.safe_value(response, 'trades', [])
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'pair' => market['id']
      }
      if since != nil
        request['since'] = since
      end
      if limit != nil
        request['limit'] = limit
      end
      response = self.privateGetListtrades(self.shallow_extend(request, params))
      trades = self.safe_value(response, 'trades', [])
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_trading_fees(params = {})
      self.load_markets
      response = self.privateGetFeeInfo(params)
      return {
        'info' => response,
        'maker' => self.safe_float(response, 'maker_fee'),
        'taker' => self.safe_float(response, 'taker_fee')
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      method = 'privatePost'
      order = { 'pair' => self.market_id(symbol) }
      if type == 'market'
        method += 'Marketorder'
        order['type'] = side.upcase
        if side == 'buy'
          order['counter_volume'] = amount
        else
          order['base_volume'] = amount
        end
      else
        method += 'Postorder'
        order['volume'] = amount
        order['price'] = price
        if side == 'buy'
          order['type'] = 'BID'
        else
          order['type'] = 'ASK'
        end
      end
      response = self.send_wrapper(method, self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['order_id']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostStoporder({ 'order_id' => id })
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if query
        url += '?' + self.urlencode(query)
      end
      if api == 'private'
        self.check_required_credentials
        auth = self.encode(self.apiKey + ':' + self.secret)
        auth = Base64.encode64(auth)
        headers = { 'Authorization' => 'Basic ' + self.decode(auth) }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('error')
        raise(ExchangeError, self.id + ' ' + self.json(response))
      end
      return response
    end
  end
end
