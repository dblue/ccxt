# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Stronghold < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'stronghold',
        'name' => 'Stronghold',
        'country' => ['US'],
        'rateLimit' => 1000,
        'version' => 'v1',
        'comment' => 'This comment is optional',
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/52160042-98c1f300-26be-11e9-90dd-da8473944c83.jpg',
          'api' => {
            'public' => 'https://api.stronghold.co',
            'private' => 'https://api.stronghold.co'
          },
          'www' => 'https://stronghold.co',
          'doc' => [
            'https://docs.stronghold.co'
          ]
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true,
          'password' => true
        },
        'has' => {
          'fetchMarkets' => true,
          'fetchCurrencies' => true,
          'fetchOrderBook' => true,
          'fetchOpenOrders' => true,
          'fetchTrades' => true,
          'fetchMyTrades' => true,
          'fetchDepositAddress' => false,
          'createDepositAddress' => true,
          'withdraw' => true,
          'fetchTicker' => false,
          'fetchTickers' => false,
          'fetchAccounts' => true,
          'fetchTransactions' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'utilities/time',
              'utilities/uuid',
              'venues',
              'venues/{venueId}/assets',
              'venues/{venueId}/markets',
              'venues/{venueId}/markets/{marketId}/orderbook',
              'venues/{venueId}/markets/{marketId}/trades'
            ],
            'post' => [
              'venues/{venueId}/assets',
              'iam/credentials',
              'identities'
            ],
            'patch' => [
              'identities'
            ],
            'put' => [
              'iam/credentials/{credentialId}'
            ],
            'delete' => [
              'iam/credentials/{credentialId}'
            ]
          },
          'private' => {
            'get' => [
              'venues',
              'venues/{venueId}/accounts',
              'venues/{venueId}/accounts/{accountId}',
              'venues/{venueId}/accounts/{accountId}/payments/{paymentId}',
              'venues/{venueId}/accounts/{accountId}/orders',
              'venues/{venueId}/accounts/{accountId}/trades',
              'venues/{venueId}/accounts/{accountId}/transactions'
            ],
            'post' => [
              'venues/{venueId}/accounts',
              'venues/{venueId}/accounts/{accountId}/orders',
              'venues/{venueId}/accounts/{accountId}/deposit',
              'venues/{venueId}/accounts/{accountId}/withdrawal',
              'venues/{venueId}/accounts/{accountId}/payments',
              'venues/{venueId}/accounts/{accountId}/payments/{paymentId}/stop',
              'venues/{venueId}/custody/accounts/{accountId}/operations/{operationId}/signatures',
              'venues/{venueId}/anchor/withdrawal',
              'venues/{venueId}/testing/friendbot'
            ],
            'delete' => [
              'venues/{venueId}/accounts/{accountId}/orders/{orderId}'
            ]
          }
        },
        'options' => {
          'accountId' => nil,
          'venueId' => 'trade-public',
          'venues' => {
            'trade' => 'trade-public',
            'sandbox' => 'sandbox-public'
          },
          'paymentMethods' => {
            'ETH' => 'ethereum',
            'BTC' => 'bitcoin',
            'XLM' => 'stellar',
            'XRP' => 'ripple',
            'LTC' => 'litecoin',
            'SHX' => 'stellar'
          }
        },
        'exceptions' => {
          'CREDENTIAL_MISSING' => AuthenticationError,
          'CREDENTIAL_INVALID' => AuthenticationError,
          'CREDENTIAL_REVOKED' => AccountSuspended,
          'CREDENTIAL_NO_IDENTITY' => AuthenticationError,
          'PASSPHRASE_INVALID' => AuthenticationError,
          'SIGNATURE_INVALID' => AuthenticationError,
          'TIME_INVALID' => InvalidNonce,
          'BYPASS_INVALID' => AuthenticationError,
          'INSUFFICIENT_FUNDS' => InsufficientFunds
        }
      })
    end

    def get_active_account
      if self.options['accountId'] != nil
        return self.options['accountId']
      end
      self.loadAccounts
      numAccounts = self.accounts.length
      if numAccounts > 0
        return self.accounts[0]['id']
      end
      raise(ExchangeError, self.id + ' requires an accountId.')
    end

    def fetch_accounts(params = {})
      request = {
        'venueId' => self.options['venueId']
      }
      response = self.privateGetVenuesVenueIdAccounts(self.shallow_extend(request, params))
      #
      #   [{ id => '34080200-b25a-483d-a734-255d30ba324d',
      #       venueSpecificId => '' } ...]
      #
      return response['result']
    end

    def fetch_time(params = {})
      response = self.publicGetUtilitiesTime(params)
      #
      #     {
      #         "requestId" => "6de8f506-ad9d-4d0d-94f3-ec4d55dfcdb9",
      #         "timestamp" => 1536436649207281,
      #         "success" => true,
      #         "statusCode" => 200,
      #         "result" => {
      #             "timestamp" => "2018-09-08T19:57:29.207282Z"
      #         }
      #     }
      #
      return self.parse8601(self.safe_string(response['result'], 'timestamp'))
    end

    def fetch_markets(params = {})
      request = {
        'venueId' => self.options['venueId']
      }
      response = self.publicGetVenuesVenueIdMarkets(self.shallow_extend(request, params))
      data = response['result']
      #
      #     [
      #         {
      #             id => 'SHXUSD',
      #             baseAssetId => 'SHX/stronghold.co',
      #             counterAssetId => 'USD/stronghold.co',
      #             minimumOrderSize => '1.0000000',
      #             minimumOrderIncrement => '1.0000000',
      #             minimumPriceIncrement => '0.00010000',
      #             displayDecimalsPrice => 4,
      #             displayDecimalsAmount => 0
      #         },
      #         ...
      #     ]
      #
      result = {}
      for i in (0...data.length)
        entry = data[i]
        marketId = entry['id']
        baseId = entry['baseAssetId']
        quoteId = entry['counterAssetId']
        baseAssetId = baseId.split('/')[0]
        quoteAssetId = quoteId.split('/')[0]
        base = self.common_currency_code(baseAssetId)
        quote = self.common_currency_code(quoteAssetId)
        symbol = base + '/' + quote
        limits = {
          'amount' => {
            'min' => self.safe_float(entry, 'minimumOrderSize'),
            'max' => nil
          }
        }
        precision = {
          'price' => self.safe_integer(entry, 'displayDecimalsPrice'),
          'amount' => self.safe_integer(entry, 'displayDecimalsAmount')
        }
        result[symbol] = {
          'symbol' => symbol,
          'id' => marketId,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'precision' => precision,
          'info' => entry,
          'limits' => limits
        }
      end
      return result
    end

    def fetch_currencies(params = {})
      request = {
        'venueId' => self.options['venueId']
      }
      response = self.publicGetVenuesVenueIdAssets(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #             id => 'XLM/native',
      #             alias => '',
      #             code => 'XLM',
      #             name => '',
      #             displayDecimalsFull => 7,
      #             displayDecimalsSignificant => 2,
      #         },
      #         ...
      #     ]
      #
      data = response['result']
      result = {}
      limits = {
        'amount' => {
          'min' => nil,
          'max' => nil
        },
        'price' => {
          'min' => nil,
          'max' => nil
        },
        'cost' => {
          'min' => nil,
          'max' => nil
        },
        'withdraw' => {
          'min' => nil,
          'max' => nil
        }
      }
      for i in (0...data.length)
        entry = data[i]
        assetId = self.safe_string(entry, 'id')
        currencyId = self.safe_string(entry, 'code')
        code = self.common_currency_code(currencyId)
        precision = self.safe_integer(entry, 'displayDecimalsFull')
        result[code] = {
          'code' => code,
          'id' => assetId,
          'precision' => precision,
          'info' => entry,
          'active' => nil,
          'name' => nil,
          'limits' => limits
        }
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      marketId = self.market_id(symbol)
      request = {
        'marketId' => marketId,
        'venueId' => self.options['venueId']
      }
      response = self.publicGetVenuesVenueIdMarketsMarketIdOrderbook(self.shallow_extend(request, params))
      #
      #     {
      #         marketId => 'ETHBTC',
      #         bids => [
      #             ['0.031500', '7.385000'],
      #             ...,
      #         ],
      #         asks => [
      #             ['0.031500', '7.385000'],
      #             ...,
      #         ],
      #     }
      #
      data = response['result']
      timestamp = self.parse8601(self.safe_string(response, 'timestamp'))
      return self.parse_order_book(data, timestamp)
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'marketId' => market['id'],
        'venueId' => self.options['venueId']
      }
      response = self.publicGetVenuesVenueIdMarketsMarketIdTrades(self.shallow_extend(request, params))
      #
      #     {
      #         "requestId" => "4d343700-b53f-4975-afcc-732ae9d3c828",
      #         "timestamp" => "2018-11-08T19:22:11.399543Z",
      #         "success" => true,
      #         "statusCode" => 200,
      #         "result" => {
      #             "marketId" => "",
      #             "trades" => [
      #                 ["0.9", "3.10", "sell", "2018-11-08T19:22:11.399547Z"],
      #                 ...
      #             ],
      #         }
      #     }
      #
      return self.parse_trades(response['result']['trades'], market, since, limit)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #      ['0.03177000', '0.0643501', 'sell', '2019-01-27T23:02:04Z']
      #
      # fetchMyTrades(private)
      #
      #     {
      #         id => '9cdb109c-d035-47e2-81f8-a0c802c9c5f9',
      #         orderId => 'a38d8bcb-9ff5-4c52-81a0-a40196a66462',
      #         marketId => 'XLMUSD',
      #         side => 'sell',
      #         size => '1.0000000',
      #         price => '0.10440600',
      #         settled => true,
      #         maker => false,
      #         executedAt => '2019-02-01T18:44:21Z'
      #     }
      #
      id = nil
      takerOrMaker = nil
      price = nil
      amount = nil
      cost = nil
      side = nil
      timestamp = nil
      orderId = nil
      if trade.is_a?(Array)
        price = parse_float(trade[0])
        amount = parse_float(trade[1])
        side = trade[2]
        timestamp = self.parse8601(trade[3])
      else
        id = self.safe_string(trade, 'id')
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'size')
        side = self.safe_string(trade, 'side')
        timestamp = self.parse8601(self.safe_string(trade, 'executedAt'))
        orderId = self.safe_string(trade, 'orderId')
        marketId = self.safe_string(trade, 'marketId')
        market = self.safe_value(self.markets_by_id, marketId)
        isMaker = self.safe_value(trade, 'maker')
        takerOrMaker = isMaker ? 'maker' : 'taker'
      end
      if amount != nil && price != nil
        cost = amount * price
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      return {
        'id' => id,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => nil,
        'order' => orderId,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'takerOrMaker' => takerOrMaker,
        'fee' => {
          'cost' => nil,
          'currency' => nil,
          'rate' => nil
        }
      }
    end

    def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = self.shallow_extend({
        'venueId' => self.options['venueId'],
        'accountId' => self.get_active_account
      }, params)
      if !request['accountId']
        raise(ArgumentsRequired, self.id + " fetchTransactions requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.")
      end
      response = self.privateGetVenuesVenueIdAccountsAccountIdTransactions(request)
      currency = nil
      if code != nil
        currency = self.currency(code)
      end
      return self.parseTransactions(response['result'], currency, since, limit)
    end

    def parse_transaction_status(status)
      statuses = {
        'queued' => 'pending',
        'settling' => 'pending'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction(transaction, currency = nil)
      # {
      #     "id" => "6408e003-0f14-4457-9340-ba608992ad5c",
      #     "status" => "queued",
      #     "direction" => "outgoing",
      #     "amount" => "98.95000000",
      #     "assetId" => "XLM/native",
      #     "sourceAccount" => {
      #       "id" => "774fa8ef-600b-4636-b9ed-cd6d23421915",
      #       "venueSpecificId" => "GC5FIBIQZTQRMJE34GYF5EKH77GEQ3OHFX3NIP5OKDIZFA6VERLZSHY6"
      #     },
      #     "destinationAccount" => {
      #       "id" => "f72b9fb5-9607-4dd3-b31f-6ded21337056",
      #       "venueSpecificId" => "GAOWV6CYBE7DEWSWPODXLMI5YB75VXXZJX5OYVQ2YLZH2TVA3TMMSNYW"
      #     }
      #   }
      id = self.safe_string(transaction, 'id')
      assetId = self.safe_string(transaction, 'assetId')
      code = nil
      if assetId != nil
        currencyId = assetId.split('/')[0]
        code = self.common_currency_code(currencyId)
      else
        if currency != nil
          code = currency['code']
        end
      end
      amount = self.safe_float(transaction, 'amount')
      status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
      feeCost = self.safe_float(transaction, 'feeAmount')
      feeRate = nil
      if feeCost != nil
        feeRate = feeCost / amount
      end
      direction = self.safe_string(transaction, 'direction')
      datetime = self.safe_string(transaction, 'requestedAt')
      timestamp = self.parse8601(datetime)
      updated = self.parse8601(self.safe_string(transaction, 'updatedAt'))
      type = (direction == 'outgoing' || direction == 'withdrawal') ? 'withdrawal' : 'deposit'
      fee = {
        'cost' => feeCost,
        'rate' => feeRate
      }
      return {
        'id' => id,
        'info' => transaction,
        'currency' => code,
        'amount' => amount,
        'status' => status,
        'fee' => fee,
        'tag' => nil,
        'type' => type,
        'updated' => updated,
        'address' => nil,
        'txid' => nil,
        'timestamp' => timestamp,
        'datetime' => datetime
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = self.shallow_extend({
        'venueId' => self.options['venueId'],
        'accountId' => self.get_active_account,
        'marketID' => market['id'],
        'type' => type,
        'side' => side,
        'size' => self.amount_to_precision(symbol, amount),
        'price' => self.price_to_precision(symbol, price)
      }, params)
      if !request['accountId']
        raise(ArgumentsRequired, self.id + " createOrder requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.")
      end
      response = self.privatePostVenuesVenueIdAccountsAccountIdOrders(request)
      return self.parse_order(response, market)
    end

    def cancel_order(id, symbol = nil, params = {})
      request = self.shallow_extend({
        'venueId' => self.options['venueId'],
        'accountId' => self.get_active_account,
        'orderId' => id
      }, params)
      if !request['accountId']
        raise(ArgumentsRequired, self.id + " cancelOrder requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.")
      end
      response = self.privateDeleteVenuesVenueIdAccountsAccountIdOrdersOrderId(request)
      return self.parse_order(response)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      request = self.shallow_extend({
        'venueId' => self.options['venueId'],
        'accountId' => self.get_active_account
      }, params)
      if !request['accountId']
        raise(ArgumentsRequired, self.id + " cancelOrder requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.")
      end
      response = self.privateGetVenuesVenueIdAccountsAccountIdOrders(request)
      return self.parse_orders(response['result'], market, since, limit)
    end

    def parse_order(order, market = nil)
      # { id => '178596',
      #   marketId => 'XLMUSD',
      #   side => 'buy',
      #   size => '1.0000000',
      #   sizeFilled => '0',
      #   price => '0.10000000',
      #   placedAt => '2019-02-01T19:47:52Z' }
      marketId = self.safe_string(order, 'marketId')
      if marketId != nil
        market = self.safe_value(self.marketsById, marketId)
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      id = self.safe_string(order, 'id')
      datetime = self.safe_string(order, 'placedAt')
      amount = self.safe_float(order, 'size')
      price = self.safe_float(order, 'price')
      filled = self.safe_float(order, 'sizeFilled')
      cost = nil
      remaining = nil
      if amount != nil
        if filled != nil
          remaining = amount - filled
        end
        if price != nil
          cost = amount * price
        end
      end
      return {
        'id' => id,
        'info' => order,
        'symbol' => symbol,
        'datetime' => datetime,
        'timestamp' => self.parse8601(datetime),
        'side' => self.safe_string(order, 'side'),
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'price' => price,
        'cost' => cost,
        'trades' => [],
        'lastTradeTimestamp' => nil,
        'status' => nil,
        'type' => nil,
        'average' => nil
      }
    end

    def nonce
      return self.seconds
    end

    def set_sandbox_mode(enabled)
      if enabled
        self.options['venueId'] = self.options['venues']['sandbox']
      else
        self.options['venueId'] = self.options['venues']['trade']
      end
    end

    def fetch_balance(params = {})
      request = self.shallow_extend({
        'venueId' => self.options['venueId'],
        'accountId' => self.get_active_account
      }, params)
      if request.include?(!('accountId'))
        raise(ArgumentsRequired, self.id + " fetchBalance requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.")
      end
      response = self.privateGetVenuesVenueIdAccountsAccountId(request)
      balances = response['result']['balances']
      result = {}
      for i in (0...balances.length)
        entry = balances[i]
        asset = entry['assetId'].split('/')[0]
        code = self.common_currency_code(asset)
        account = {}
        account['total'] = self.safe_float(entry, 'amount', 0.0)
        account['free'] = self.safe_float(entry, 'availableForTrade', 0.0)
        account['used'] = account['total'] - account['free']
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = self.shallow_extend({
        'venueId' => self.options['venueId'],
        'accountId' => self.get_active_account
      }, params)
      if !request['accountId']
        raise(ArgumentsRequired, self.id + " fetchMyTrades requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.")
      end
      response = self.privateGetVenuesVenueIdAccountsAccountIdTrades(request)
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      return self.parse_trades(response['result'], market, since, limit)
    end

    def create_deposit_address(code, params = {})
      self.load_markets
      paymentMethod = self.safe_string(self.options['paymentMethods'], code)
      if paymentMethod.nil?
        raise(NotSupported, self.id + ' createDepositAddress requires code to be BTC, ETH, or XLM')
      end
      request = self.shallow_extend({
        'venueId' => self.options['venueId'],
        'accountId' => self.get_active_account,
        'assetId' => self.currencyId(code),
        'paymentMethod' => paymentMethod
      }, params)
      if !request['accountId']
        raise(ArgumentsRequired, self.id + " createDepositAddress requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.")
      end
      response = self.privatePostVenuesVenueIdAccountsAccountIdDeposit(request)
      #
      #     {
      #         assetId => 'BTC/stronghold.co',
      #         paymentMethod => 'bitcoin',
      #         paymentMethodInstructions => {
      #             deposit_address => 'mzMT9Cfw8JXVWK7rMonrpGfY9tt57ytHt4',
      #             reference => 'sometimes-exists',
      #         },
      #         direction => 'deposit',
      #     }
      #
      data = response['result']['paymentMethodInstructions']
      address = data['deposit_address']
      tag = self.safe_string(data, 'reference')
      return {
        'currency' => code,
        'address' => self.check_address(address),
        'tag' => tag,
        'info' => response
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.load_markets
      paymentMethod = self.safe_string(self.options['paymentMethods'], code)
      if paymentMethod.nil?
        raise(NotSupported, self.id + ' withdraw requires code to be BTC, ETH, or XLM')
      end
      request = self.shallow_extend({
        'venueId' => self.options['venueId'],
        'accountId' => self.get_active_account,
        'assetId' => self.currencyId(code),
        'amount' => amount,
        'paymentMethod' => paymentMethod,
        'paymentMethodDetails' => {
          'withdrawal_address' => address
        }
      }, params)
      if tag != nil
        request['paymentMethodDetails']['reference'] = tag
      end
      if !request['accountId']
        raise(ArgumentsRequired, self.id + " withdraw requires either the 'accountId' extra parameter or exchange.options['accountId'] = 'YOUR_ACCOUNT_ID'.")
      end
      response = self.privatePostVenuesVenueIdAccountsAccountIdWithdrawal(request)
      #
      #     {
      #         "id" => "5be48892-1b6e-4431-a3cf-34b38811e82c",
      #         "assetId" => "BTC/stronghold.co",
      #         "amount" => "10",
      #         "feeAmount" => "0.01",
      #         "paymentMethod" => "bitcoin",
      #         "paymentMethodDetails" => {
      #             "withdrawal_address" => "1vHysJeXYV6nqhroBaGi52QWFarbJ1dmQ"
      #         },
      #         "direction" => "withdrawal",
      #         "status" => "pending"
      #     }
      #
      data = response['result']
      return {
        'id' => self.safe_string(data, 'id'),
        'info' => response
      }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if !response
        return # fallback to base error handler by default
      end
      #
      #     {
      #         requestId => '3e7d17ab-b316-4721-b5aa-f7e6497eeab9',
      #         timestamp => '2019-01-31T21:59:06.696855Z',
      #         success => true,
      #         statusCode => 200,
      #         result => []
      #     }
      #
      errorCode = self.safe_string(response, 'errorCode')
      if self.exceptions.include?(errorCode)
        exceptionCass = self.exceptions[errorCode]
        raise(exceptionClass, self.id + ' ' + body)
      end
      success = self.safe_value(response, 'success')
      if !success
        raise(ExchangeError, self.id + ' ' + body)
      end
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      url = self.urls['api'][api] + request
      if query
        if method == 'GET'
          url += '?' + self.urlencode(query)
        else
          body = self.json(query)
        end
      end
      if api == 'private'
        self.check_required_credentials
        timestamp = self.nonce.to_s
        payload = timestamp + method + request
        if body != nil
          payload += body
        end
        secret = Base64.decode64(self.secret)
        headers = {
          'SH-CRED-ID' => self.apiKey,
          'SH-CRED-SIG' => self.hmac(self.encode(payload), secret, 'sha256', 'base64'),
          'SH-CRED-TIME' => timestamp,
          'SH-CRED-PASS' => self.password,
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
