# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Btcbox < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'btcbox',
        'name' => 'BtcBox',
        'countries' => ['JP'],
        'rateLimit' => 1000,
        'version' => 'v1',
        'has' => {
          'CORS' => false,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchTickers' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/31275803-4df755a8-aaa1-11e7-9abb-11ec2fad9f2d.jpg',
          'api' => 'https://www.btcbox.co.jp/api',
          'www' => 'https://www.btcbox.co.jp/',
          'doc' => 'https://www.btcbox.co.jp/help/asm',
          'fees' => 'https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction'
        },
        'api' => {
          'public' => {
            'get' => [
              'depth',
              'orders',
              'ticker'
            ]
          },
          'private' => {
            'post' => [
              'balance',
              'trade_add',
              'trade_cancel',
              'trade_list',
              'trade_view',
              'wallet'
            ]
          }
        },
        'markets' => {
          'BTC/JPY' => { 'id' => 'btc', 'symbol' => 'BTC/JPY', 'base' => 'BTC', 'quote' => 'JPY', 'baseId' => 'btc', 'quoteId' => 'jpy', 'taker' => 0.05 / 100, 'maker' => 0.05 / 100 },
          'ETH/JPY' => { 'id' => 'eth', 'symbol' => 'ETH/JPY', 'base' => 'ETH', 'quote' => 'JPY', 'baseId' => 'eth', 'quoteId' => 'jpy', 'taker' => 0.10 / 100, 'maker' => 0.10 / 100 },
          'LTC/JPY' => { 'id' => 'ltc', 'symbol' => 'LTC/JPY', 'base' => 'LTC', 'quote' => 'JPY', 'baseId' => 'ltc', 'quoteId' => 'jpy', 'taker' => 0.10 / 100, 'maker' => 0.10 / 100 },
          'BCH/JPY' => { 'id' => 'bch', 'symbol' => 'BCH/JPY', 'base' => 'BCH', 'quote' => 'JPY', 'baseId' => 'bch', 'quoteId' => 'jpy', 'taker' => 0.10 / 100, 'maker' => 0.10 / 100 }
        },
        'exceptions' => {
          '104' => AuthenticationError,
          '105' => PermissionDenied,
          '106' => InvalidNonce,
          '107' => InvalidOrder, # price should be an integer
          '200' => InsufficientFunds,
          '201' => InvalidOrder, # amount too small
          '202' => InvalidOrder, # price should be [0 : 1000000]
          '203' => OrderNotFound,
          '401' => OrderNotFound, # cancel canceled, closed or non-existent order
          '402' => DDoSProtection
        }
      })
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privatePostBalance
      result = { 'info' => balances }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        lowercase = currency.downcase
        if lowercase == 'dash'
          lowercase = 'drk'
        end
        account = self.account
        free = lowercase + '_balance'
        used = lowercase + '_lock'
        if balances.include?(free)
          account['free'] = parse_float(balances[free])
        end
        if balances.include?(used)
          account['used'] = parse_float(balances[used])
        end
        account['total'] = self.sum(account['free'], account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {}
      numSymbols = self.symbols.length
      if numSymbols > 1
        request['coin'] = market['baseId']
      end
      orderbook = self.publicGetDepth(self.shallow_extend(request, params))
      return self.parse_order_book(orderbook)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => self.safe_float(ticker, 'volume'),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {}
      numSymbols = self.symbols.length
      if numSymbols > 1
        request['coin'] = market['baseId']
      end
      ticker = self.publicGetTicker(self.shallow_extend(request, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      timestamp = parse_int(trade['date']) * 1000 # GMT time
      return {
        'info' => trade,
        'id' => trade['tid'],
        'order' => nil,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => trade['type'],
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {}
      numSymbols = self.symbols.length
      if numSymbols > 1
        request['coin'] = market['baseId']
      end
      response = self.publicGetOrders(self.shallow_extend(request, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'amount' => amount,
        'price' => price,
        'type' => side,
        'coin' => market['baseId']
      }
      response = self.privatePostTradeAdd(self.shallow_extend(request, params))
      #
      #     {
      #         "result":true,
      #         "id":"11"
      #     }
      #
      return self.parse_order(response, market)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      # a special case for btcbox – default symbol is BTC/JPY
      if symbol.nil?
        symbol = 'BTC/JPY'
      end
      market = self.market(symbol)
      request = {
        'id' => id,
        'coin' => market['baseId']
      }
      response = self.privatePostTradeCancel(self.shallow_extend(request, params))
      #
      #     {"result":true, "id":"11"}
      #
      return self.parse_order(response, market)
    end

    def parse_order_status(status)
      statuses = {
        # TODO => complete list
        'part' => 'open', # partially or not at all executed
        'all' => 'closed', # fully executed
        'cancelled' => 'canceled',
        'closed' => 'closed', # never encountered, seems to be bug in the doc
        'no' => 'closed', # not clarified in the docs...
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      #
      # {"id":11,"datetime":"2014-10-21 10:47:20","type":"sell","price":42000,"amount_original":1.2,"amount_outstanding":1.2,"status":"closed","trades":[]}
      #
      id = self.safe_string(order, 'id')
      datetimeString = self.safe_string(order, 'datetime')
      timestamp = nil
      if datetimeString != nil
        timestamp = self.parse8601(order['datetime'] + '+09:00') # Tokyo time
      end
      amount = self.safe_float(order, 'amount_original')
      remaining = self.safe_float(order, 'amount_outstanding')
      filled = nil
      if amount != nil
        if remaining != nil
          filled = amount - remaining
        end
      end
      price = self.safe_float(order, 'price')
      cost = nil
      if price != nil
        if filled != nil
          cost = filled * price
        end
      end
      # status is set by fetchOrder method only
      status = self.parse_order_status(self.safe_string(order, 'status'))
      # fetchOrders do not return status, use heuristic
      if status.nil?
        if remaining != nil && remaining == 0
          status = 'closed'
        end
      end
      trades = nil # todo => self.parse_trades(order['trades'])
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      side = self.safe_string(order, 'type')
      return {
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'amount' => amount,
        'remaining' => remaining,
        'filled' => filled,
        'side' => side,
        'type' => nil,
        'status' => status,
        'symbol' => symbol,
        'price' => price,
        'cost' => cost,
        'trades' => trades,
        'fee' => nil,
        'info' => order
      }
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      # a special case for btcbox – default symbol is BTC/JPY
      if symbol.nil?
        symbol = 'BTC/JPY'
      end
      market = self.market(symbol)
      request = self.shallow_extend({
        'id' => id,
        'coin' => market['baseId']
      }, params)
      response = self.privatePostTradeView(self.shallow_extend(request, params))
      return self.parse_order(response, market)
    end

    def fetch_orders_by_type(type, symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      # a special case for btcbox – default symbol is BTC/JPY
      if symbol.nil?
        symbol = 'BTC/JPY'
      end
      market = self.market(symbol)
      request = {
        'type' => type, # 'open' or 'all'
        'coin' => market['baseId']
      }
      response = self.privatePostTradeList(self.shallow_extend(request, params))
      orders = self.parse_orders(response, market, since, limit)
      # status(open/closed/canceled) is nil
      # btcbox does not return status, but we know it's 'open' as we queried for open orders
      if type == 'open'
        for i in (0...orders.length)
          orders[i]['status'] = 'open'
        end
      end
      return orders
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_type('all', symbol, since, limit, params)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_type('open', symbol, since, limit, params)
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + path
      if api == 'public'
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        query = self.shallow_extend({
          'key' => self.apiKey,
          'nonce' => nonce
        }, params)
        request = self.urlencode(query)
        secret = self.hash(self.encode(self.secret))
        query['signature'] = self.hmac(self.encode(request), self.encode(secret))
        body = self.urlencode(query)
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      # typical error response => {"result":false,"code":"401"}
      if httpCode >= 400
        return
      end # resort to defaultErrorHandler
      if body[0] != '{'
        return
      end # not json, resort to defaultErrorHandler
      result = self.safe_value(response, 'result')
      if result.nil? || result == true
        return
      end # either public API(no error codes expected) or success
      errorCode = self.safe_value(response, 'code')
      feedback = self.id + ' ' + self.json(response)
      exceptions = self.exceptions
      if exceptions.include?(errorCode)
        raise(exceptions[errorCode], feedback)
      end
      raise(ExchangeError, feedback) # unknown message
    end
  end
end
