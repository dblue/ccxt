# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bigone < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bigone',
        'name' => 'BigONE',
        'countries' => ['GB'],
        'version' => 'v2',
        'has' => {
          'cancelAllOrders' => true,
          'createMarketOrder' => false,
          'fetchDepositAddress' => true,
          'fetchMyTrades' => true,
          'fetchOHLCV' => false,
          'fetchOpenOrders' => true,
          'fetchTickers' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/42803606-27c2b5ec-89af-11e8-8d15-9c8c245e8b2c.jpg',
          'api' => {
            'public' => 'https://big.one/api/v2',
            'private' => 'https://big.one/api/v2/viewer'
          },
          'www' => 'https://big.one',
          'doc' => 'https://open.big.one/docs/api.html',
          'fees' => 'https://help.big.one/hc/en-us/articles/115001933374-BigONE-Fee-Policy',
          'referral' => 'https://b1.run/users/new?code=D3LLBVFT'
        },
        'api' => {
          'public' => {
            'get' => [
              'ping', # timestamp in nanoseconds
              'markets',
              'markets/{symbol}/depth',
              'markets/{symbol}/trades',
              'markets/{symbol}/ticker',
              'orders',
              'orders/{id}',
              'tickers',
              'trades'
            ]
          },
          'private' => {
            'get' => [
              'accounts',
              'orders',
              'orders/{order_id}',
              'trades',
              'withdrawals',
              'deposits'
            ],
            'post' => [
              'orders',
              'orders/{order_id}/cancel',
              'orders/cancel_all'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.1 / 100,
            'taker' => 0.1 / 100
          },
          'funding' => {
            # HARDCODING IS DEPRECATED THE FEES BELOW ARE TO BE REMOVED SOON
            'withdraw' => {
              'BTC' => 0.002,
              'ETH' => 0.01,
              'EOS' => 0.01,
              'ZEC' => 0.002,
              'LTC' => 0.01,
              'QTUM' => 0.01,
              # 'INK' => 0.01 QTUM,
              # 'BOT' => 0.01 QTUM,
              'ETC' => 0.01,
              'GAS' => 0.0,
              'BTS' => 1.0,
              'GXS' => 0.1,
              'BITCNY' => 1.0
            }
          }
        },
        'exceptions' => {
          'codes' => {
            '401' => AuthenticationError,
            '10030' => InvalidNonce, # {"message":"invalid nonce, nonce should be a 19bits number","code":10030}
          },
          'detail' => {
            'Internal server error' => ExchangeNotAvailable
          }
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetMarkets
      markets = response['data']
      result = []
      self.options['marketsByUuid'] = {}
      for i in (0...markets.length)
        #
        #      {       uuid =>   "550b34db-696e-4434-a126-196f827d9172",
        #        quoteScale =>    3,
        #        quoteAsset => {   uuid => "17082d1c-0195-4fb6-8779-2cdbcb9eeb3c",
        #                      symbol => "USDT",
        #                        name => "TetherUS"                              },
        #              name =>   "BTC-USDT",
        #         baseScale =>    5,
        #         baseAsset => {   uuid => "0df9c3c3-255a-46d7-ab82-dedae169fba9",
        #                      symbol => "BTC",
        #                        name => "Bitcoin"                               }  } }
        #
        market = markets[i]
        id = market['name']
        uuid = market['uuid']
        baseId = market['baseAsset']['symbol']
        quoteId = market['quoteAsset']['symbol']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => market['baseScale'],
          'price' => market['quoteScale']
        }
        entry = {
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => 10**precision['amount']
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => 10**precision['price']
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => market
        }
        self.options['marketsByUuid'][uuid] = entry
        result.push(entry)
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      #
      #     [
      #         {
      #             "volume" => "190.4925000000000000",
      #             "open" => "0.0777371200000000",
      #             "market_uuid" => "38dd30bf-76c2-4777-ae2a-a3222433eef3",
      #             "market_id" => "ETH-BTC",
      #             "low" => "0.0742925600000000",
      #             "high" => "0.0789150000000000",
      #             "daily_change_perc" => "-0.3789180767180466680525339760",
      #             "daily_change" => "-0.0002945600000000",
      #             "close" => "0.0774425600000000", # last price
      #             "bid" => {
      #                 "price" => "0.0764777900000000",
      #                 "amount" => "6.4248000000000000"
      #             },
      #             "ask" => {
      #                 "price" => "0.0774425600000000",
      #                 "amount" => "1.1741000000000000"
      #             }
      #         }
      #     ]
      #
      if market.nil?
        marketId = self.safe_string(ticker, 'market_id')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.milliseconds
      close = self.safe_float(ticker, 'close')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker['bid'], 'price'),
        'bidVolume' => self.safe_float(ticker['bid'], 'amount'),
        'ask' => self.safe_float(ticker['ask'], 'price'),
        'askVolume' => self.safe_float(ticker['ask'], 'amount'),
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'open'),
        'close' => close,
        'last' => close,
        'previousClose' => nil,
        'change' => self.safe_float(ticker, 'daily_change'),
        'percentage' => self.safe_float(ticker, 'daily_change_perc'),
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'volume'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketsSymbolTicker(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_ticker(response['data'], market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetTickers(params)
      tickers = response['data']
      result = {}
      for i in (0...tickers.length)
        ticker = self.parse_ticker(tickers[i])
        symbol = ticker['symbol']
        result[symbol] = ticker
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      response = self.publicGetMarketsSymbolDepth(self.shallow_extend({
        'symbol' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(response['data'], nil, 'bids', 'asks', 'price', 'amount')
    end

    def parse_trade(trade, market = nil)
      #
      #     {   node => {  taker_side => "ASK",
      #                       price => "0.0694071600000000",
      #                 market_uuid => "38dd30bf-76c2-4777-ae2a-a3222433eef3",
      #                   market_id => "ETH-BTC",
      #                 inserted_at => "2018-07-14T09:22:06Z",
      #                          id => "19913306",
      #                      amount => "0.8800000000000000"                    },
      #       cursor =>   "Y3Vyc29yOnYxOjE5OTEzMzA2"                              }
      #
      node = trade['node']
      timestamp = self.parse8601(node['inserted_at'])
      price = self.safe_float(node, 'price')
      amount = self.safe_float(node, 'amount')
      if market.nil?
        marketId = self.safe_string(node, 'market_id')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      cost = self.cost_to_precision(symbol, price * amount)
      side = nil
      if node['taker_side'] == 'ASK'
        side = 'sell'
      else
        side = 'buy'
      end
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => self.safe_string(node, 'id'),
        'order' => nil,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => parse_float(cost),
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id']
      }
      if limit != nil
        request['first'] = limit
      end
      response = self.publicGetMarketsSymbolTrades(self.shallow_extend(request, params))
      #
      #     { data => { page_info => {      start_cursor => "Y3Vyc29yOnYxOjE5OTEzMzA2",
      #                            has_previous_page =>  true,
      #                                has_next_page =>  false,
      #                                   end_cursor => "Y3Vyc29yOnYxOjIwMDU0NzIw"  },
      #                   edges => [{   node => {  taker_side => "ASK",
      #                                              price => "0.0694071600000000",
      #                                        market_uuid => "38dd30bf-76c2-4777-ae2a-a3222433eef3",
      #                                          market_id => "ETH-BTC",
      #                                        inserted_at => "2018-07-14T09:22:06Z",
      #                                                 id => "19913306",
      #                                             amount => "0.8800000000000000"                    },
      #                              cursor =>   "Y3Vyc29yOnYxOjE5OTEzMzA2"                              },
      #                            {   node => {  taker_side => "ASK",
      #                                              price => "0.0694071600000000",
      #                                        market_uuid => "38dd30bf-76c2-4777-ae2a-a3222433eef3",
      #                                          market_id => "ETH-BTC",
      #                                        inserted_at => "2018-07-14T09:22:07Z",
      #                                                 id => "19913307",
      #                                             amount => "0.3759000000000000"                    },
      #                              cursor =>   "Y3Vyc29yOnYxOjE5OTEzMzA3"                              },
      #                            {   node => {  taker_side => "ASK",
      #                                              price => "0.0694071600000000",
      #                                        market_uuid => "38dd30bf-76c2-4777-ae2a-a3222433eef3",
      #                                          market_id => "ETH-BTC",
      #                                        inserted_at => "2018-07-14T09:22:08Z",
      #                                                 id => "19913321",
      #                                             amount => "0.2197000000000000"                    },
      #                              cursor =>   "Y3Vyc29yOnYxOjE5OTEzMzIx"                              },
      #
      return self.parse_trades(response['data']['edges'], market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetAccounts(params)
      #
      #     { data => [{ locked_balance => "0",
      #                        balance => "0",
      #                     asset_uuid => "04479958-d7bb-40e4-b153-48bd63f2f77f",
      #                       asset_id => "NKC"                                   },
      #               { locked_balance => "0",
      #                        balance => "0",
      #                     asset_uuid => "04c8da0e-44fd-4d71-aeb0-8f4d54a4a907",
      #                       asset_id => "UBTC"                                  },
      #               { locked_balance => "0",
      #                        balance => "0",
      #                     asset_uuid => "05bc0d34-4809-4a39-a3c8-3a1851c8d224",
      #                       asset_id => "READ"                                  },
      #
      result = { 'info' => response }
      balances = response['data']
      for i in (0...balances.length)
        balance = balances[i]
        currencyId = balance['asset_id']
        code = self.common_currency_code(currencyId)
        if self.currencies_by_id.include?(currencyId)
          code = self.currencies_by_id[currencyId]['code']
        end
        total = self.safe_float(balance, 'balance')
        used = self.safe_float(balance, 'locked_balance')
        free = nil
        if total != nil && used != nil
          free = total - used
        end
        account = {
          'free' => free,
          'used' => used,
          'total' => total
        }
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def parse_order(order, market = nil)
      #
      #     {
      #       "id" => 10,
      #       "market_uuid" => "d2185614-50c3-4588-b146-b8afe7534da6",
      #       "market_uuid" => "BTC-EOS", # not sure which one is correct
      #       "market_id" => "BTC-EOS",   # not sure which one is correct
      #       "price" => "10.00",
      #       "amount" => "10.00",
      #       "filled_amount" => "9.0",
      #       "avg_deal_price" => "12.0",
      #       "side" => "ASK",
      #       "state" => "FILLED"
      #     }
      #
      id = self.safe_string(order, 'id')
      if market.nil?
        marketId = self.safe_string(order, 'market_id')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        else
          marketUuid = self.safe_string(order, 'market_uuid')
          if self.options['marketsByUuid'].include?(marketUuid)
            market = self.options['marketsByUuid'][marketUuid]
          end
        end
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.parse8601(self.safe_string(order, 'inserted_at'))
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'amount')
      filled = self.safe_float(order, 'filled_amount')
      remaining = maximum_wrapper(0, amount - filled)
      status = self.parse_order_status(self.safe_string(order, 'state'))
      side = self.safe_string(order, 'side')
      if side == 'BID'
        side = 'buy'
      else
        side = 'sell'
      end
      return {
        'id' => id,
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'status' => status,
        'symbol' => symbol,
        'type' => nil,
        'side' => side,
        'price' => price,
        'cost' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => nil,
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      side = (side == 'buy') ? 'BID' : 'ASK'
      request = {
        'market_id' => market['id'], # market uuid d2185614-50c3-4588-b146-b8afe7534da6, required
        'side' => side, # order side one of "ASK"/"BID", required
        'amount' => self.amount_to_precision(symbol, amount), # order amount, string, required
        'price' => self.price_to_precision(symbol, price), # order price, string, required
      }
      response = self.privatePostOrders(self.shallow_extend(request, params))
      #
      #     {
      #       "data":
      #         {
      #           "id" => 10,
      #           "market_uuid" => "BTC-EOS",
      #           "price" => "10.00",
      #           "amount" => "10.00",
      #           "filled_amount" => "9.0",
      #           "avg_deal_price" => "12.0",
      #           "side" => "ASK",
      #           "state" => "FILLED"
      #         }
      #     }
      #
      order = self.safe_value(response, 'data')
      return self.parse_order(order, market)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      request = { 'order_id' => id }
      response = self.privatePostOrdersOrderIdCancel(self.shallow_extend(request, params))
      #
      #     {
      #       "data":
      #         {
      #           "id" => 10,
      #           "market_uuid" => "BTC-EOS",
      #           "price" => "10.00",
      #           "amount" => "10.00",
      #           "filled_amount" => "9.0",
      #           "avg_deal_price" => "12.0",
      #           "side" => "ASK",
      #           "state" => "FILLED"
      #         }
      #     }
      #
      order = self.safe_value(response, 'data')
      return self.parse_order(order)
    end

    def cancel_all_orders(symbol = nil, params = {})
      self.load_markets
      response = self.privatePostOrdersOrderIdCancel(params)
      #
      #     [
      #         {
      #             "id" => 10,
      #             "market_uuid" => "d2185614-50c3-4588-b146-b8afe7534da6",
      #             "price" => "10.00",
      #             "amount" => "10.00",
      #             "filled_amount" => "9.0",
      #             "avg_deal_price" => "12.0",
      #             "side" => "ASK",
      #             "state" => "FILLED"
      #         },
      #         {
      #             ...
      #         },
      #     ]
      #
      return self.parse_orders(response)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = { 'order_id' => id }
      response = self.privateGetOrdersOrderId(self.shallow_extend(request, params))
      #
      #     {
      #       "data":
      #         {
      #           "id" => 10,
      #           "market_uuid" => "BTC-EOS",
      #           "price" => "10.00",
      #           "amount" => "10.00",
      #           "filled_amount" => "9.0",
      #           "avg_deal_price" => "12.0",
      #           "side" => "ASK",
      #           "state" => "FILLED"
      #         }
      #     }
      #
      order = self.safe_value(response, 'data')
      return self.parse_order(order)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      # NAME      DESCRIPTION                                           EXAMPLE         REQUIRED
      # market_id market id                                             ETH-BTC         true
      # after     ask for the server to return orders after the cursor  dGVzdGN1cmVzZQo false
      # before    ask for the server to return orders before the cursor dGVzdGN1cmVzZQo false
      # first     slicing count                                         20              false
      # last      slicing count                                         20              false
      # side      order side one of                                     "ASK"/"BID"     false
      # state     order state one of                      "CANCELED"/"FILLED"/"PENDING" false
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrders requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'market_id' => market['id']
      }
      if limit != nil
        request['first'] = limit
      end
      response = self.privateGetOrders(self.shallow_extend(request, params))
      #
      #     {
      #          "data" => {
      #              "edges" => [
      #                  {
      #                      "node" => {
      #                          "id" => 10,
      #                          "market_id" => "ETH-BTC",
      #                          "price" => "10.00",
      #                          "amount" => "10.00",
      #                          "filled_amount" => "9.0",
      #                          "avg_deal_price" => "12.0",
      #                          "side" => "ASK",
      #                          "state" => "FILLED"
      #                      },
      #                      "cursor" => "dGVzdGN1cmVzZQo="
      #                  }
      #              ],
      #              "page_info" => {
      #                  "end_cursor" => "dGVzdGN1cmVzZQo=",
      #                  "start_cursor" => "dGVzdGN1cmVzZQo=",
      #                  "has_next_page" => true,
      #                  "has_previous_page" => false
      #              }
      #          }
      #     }
      #
      data = self.safe_value(response, 'data', {})
      orders = self.safe_value(data, 'edges', [])
      result = []
      for i in (0...orders.length)
        result.push(self.parse_order(orders[i]['node'], market))
      end
      return self.filter_by_symbol_since_limit(result, symbol, since, limit)
    end

    def parse_order_status(status)
      statuses = {
        'PENDING' => 'open',
        'FILLED' => 'closed',
        'CANCELED' => 'canceled'
      }
      return self.safe_string(statuses, status)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'state' => 'PENDING'
      }, params))
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'state' => 'FILLED'
      }, params))
    end

    def nonce
      return self.microseconds * 1000
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      query = self.omit(params, self.extract_params(path))
      url = self.urls['api'][api] + '/' + self.implode_params(path, params)
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        request = {
          'type' => 'OpenAPI',
          'sub' => self.apiKey,
          'nonce' => nonce
        }
        jwt = self.jwt(request, self.secret)
        headers = {
          'Authorization' => 'Bearer ' + jwt
        }
        if method == 'GET'
          if query
            url += '?' + self.urlencode(query)
          end
        elsif method == 'POST'
          headers['Content-Type'] = 'application/json'
          body = self.json(query)
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        #
        #      {"errors":{"detail":"Internal server error"}}
        #      {"errors":[{"message":"invalid nonce, nonce should be a 19bits number","code":10030}],"data":null}
        #
        error = self.safe_value(response, 'error')
        errors = self.safe_value(response, 'errors')
        data = self.safe_value(response, 'data')
        if error != nil || errors != nil || data.nil?
          feedback = self.id + ' ' + self.json(response)
          code = nil
          if error != nil
            code = self.safe_integer(error, 'code')
          end
          exceptions = self.exceptions['codes']
          if errors != nil
            if errors.is_a?(Array)
              code = self.safe_string(errors[0], 'code')
            else
              code = self.safe_string(errors, 'detail')
              exceptions = self.exceptions['detail']
            end
          end
          if exceptions.include?(code)
            raise(exceptions[code], feedback)
          else
            raise(ExchangeError, feedback)
          end
        end
      end
    end
  end
end
