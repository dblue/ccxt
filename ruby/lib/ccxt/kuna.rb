# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

require_relative 'acx'

module Ccxt
  class Kuna < Acx
    def describe
      return self.deep_extend(super, {
        'id' => 'kuna',
        'name' => 'Kuna',
        'countries' => ['UA'],
        'rateLimit' => 1000,
        'version' => 'v2',
        'has' => {
          'CORS' => false,
          'fetchTickers' => true,
          'fetchOpenOrders' => true,
          'fetchMyTrades' => true,
          'withdraw' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/31697638-912824fa-b3c1-11e7-8c36-cf9606eb94ac.jpg',
          'api' => 'https://kuna.io',
          'www' => 'https://kuna.io',
          'doc' => 'https://kuna.io/documents/api',
          'fees' => 'https://kuna.io/documents/api'
        },
        'fees' => {
          'trading' => {
            'taker' => 0.25 / 100,
            'maker' => 0.25 / 100
          },
          'funding' => {
            'withdraw' => {
              'UAH' => '1%',
              'BTC' => 0.001,
              'BCH' => 0.001,
              'ETH' => 0.01,
              'WAVES' => 0.01,
              'GOL' => 0.0,
              'GBG' => 0.0,
              # 'RMC' => 0.001 BTC
              # 'ARN' => 0.01 ETH
              # 'R' => 0.01 ETH
              # 'EVR' => 0.01 ETH
            },
            'deposit' => {
              # 'UAH' => (amount) => amount * 0.001 + 5
            }
          }
        }
      })
    end

    def fetch_markets(params = {})
      quotes = ['btc', 'eth', 'eurs', 'gbg', 'uah']
      pricePrecisions = {
        'UAH' => 0
      }
      markets = []
      tickers = self.publicGetTickers
      ids = tickers.keys
      for i in (0...ids.length)
        id = ids[i]
        for j in (0...quotes.length)
          quoteId = quotes[j]
          if id.include?(quoteId)
            baseId = id.gsub(quoteId, '')
            base = baseId.upcase
            quote = quoteId.upcase
            base = self.common_currency_code(base)
            quote = self.common_currency_code(quote)
            symbol = base + '/' + quote
            precision = {
              'amount' => 6,
              'price' => self.safe_integer(pricePrecisions, quote, 6)
            }
            markets.push({
              'id' => id,
              'symbol' => symbol,
              'base' => base,
              'quote' => quote,
              'baseId' => baseId,
              'quoteId' => quoteId,
              'precision' => precision,
              'limits' => {
                'amount' => {
                  'min' => 10**-precision['amount'],
                  'max' => 10**precision['amount']
                },
                'price' => {
                  'min' => 10**-precision['price'],
                  'max' => 10**precision['price']
                },
                'cost' => {
                  'min' => nil,
                  'max' => nil
                }
              }
            })
            break
          end
        end
      end
      return markets
    end

    def fetch_l3_order_book(symbol, limit = nil, params = {})
      return self.fetch_order_book(symbol, limit, params)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOpenOrders requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      orders = self.privateGetOrders(self.shallow_extend({
        'market' => market['id']
      }, params))
      # todo emulation of fetchClosedOrders, fetchOrders, fetchOrder
      # with order cache + fetchOpenOrders
      # as in BTC-e, Liqui, Yobit, DSX, Tidex, WEX
      return self.parse_orders(orders, market, since, limit)
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(trade['created_at'])
      symbol = nil
      if market
        symbol = market['symbol']
      end
      side = self.safe_string(trade, 'side')
      if side != nil
        sideMap = {
          'ask' => 'sell',
          'bid' => 'buy'
        }
        side = self.safe_string(sideMap, side)
      end
      cost = self.safe_float(trade, 'funds')
      order = self.safe_string(trade, 'order_id')
      return {
        'id' => trade['id'].to_s,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => nil,
        'side' => side,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'volume'),
        'cost' => cost,
        'order' => order,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTrades(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOpenOrders requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      response = self.privateGetTradesMy({ 'market' => market['id'] })
      return self.parse_trades(response, market, since, limit)
    end
  end
end
