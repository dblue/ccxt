# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Nova < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'nova',
        'name' => 'Novaexchange',
        'countries' => ['TZ'], # Tanzania
        'rateLimit' => 2000,
        'version' => 'v2',
        'has' => {
          'CORS' => false,
          'createMarketOrder' => false,
          'createDepositAddress' => true,
          'fetchDepositAddress' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/30518571-78ca0bca-9b8a-11e7-8840-64b83a4a94b2.jpg',
          'api' => 'https://novaexchange.com/remote',
          'www' => 'https://novaexchange.com',
          'doc' => 'https://novaexchange.com/remote/faq'
        },
        'api' => {
          'public' => {
            'get' => [
              'markets/',
              'markets/{basecurrency}/',
              'market/info/{pair}/',
              'market/orderhistory/{pair}/',
              'market/openorders/{pair}/buy/',
              'market/openorders/{pair}/sell/',
              'market/openorders/{pair}/both/',
              'market/openorders/{pair}/{ordertype}/'
            ]
          },
          'private' => {
            'post' => [
              'getbalances/',
              'getbalance/{currency}/',
              'getdeposits/',
              'getwithdrawals/',
              'getnewdepositaddress/{currency}/',
              'getdepositaddress/{currency}/',
              'myopenorders/',
              'myopenorders_market/{pair}/',
              'cancelorder/{orderid}/',
              'withdraw/{currency}/',
              'trade/{pair}/',
              'tradehistory/',
              'getdeposithistory/',
              'getwithdrawalhistory/',
              'walletstatus/',
              'walletstatus/{currency}/'
            ]
          }
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetMarkets
      markets = response['markets']
      result = []
      for i in (0...markets.length)
        market = markets[i]
        id = market['marketname']
        quote, base = id.split('_')
        symbol = base + '/' + quote
        active = true
        if market['disabled']
          active = false
        end
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'active' => active,
          'info' => market
        })
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetMarketOpenordersPairBoth(self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook, nil, 'buyorders', 'sellorders', 'price', 'amount')
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      response = self.publicGetMarketInfoPair(self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      ticker = response['markets'][0]
      timestamp = self.milliseconds
      last = self.safe_float(ticker, 'last_price')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high24h'),
        'low' => self.safe_float(ticker, 'low24h'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => self.safe_float(ticker, 'change24h'),
        'average' => nil,
        'baseVolume' => nil,
        'quoteVolume' => self.safe_float(ticker, 'volume24h'),
        'info' => ticker
      }
    end

    def parse_trade(trade, market)
      timestamp = trade['unix_t_datestamp'] * 1000
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'id' => nil,
        'order' => nil,
        'type' => nil,
        'side' => trade['tradetype'].downcase,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'amount')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketOrderhistoryPair(self.shallow_extend({
        'pair' => market['id']
      }, params))
      return self.parse_trades(response['items'], market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostGetbalances
      balances = response['balances']
      result = { 'info' => response }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency']
        lockbox = parse_float(balance['amount_lockbox'])
        trades = parse_float(balance['amount_trades'])
        account = {
          'free' => parse_float(balance['amount']),
          'used' => self.sum(lockbox, trades),
          'total' => parse_float(balance['amount_total'])
        }
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      self.load_markets
      amount = amount.to_s
      price = price.to_s
      market = self.market(symbol)
      order = {
        'tradetype' => side.upcase,
        'tradeamount' => amount,
        'tradeprice' => price,
        'tradebase' => 1,
        'pair' => market['id']
      }
      response = self.privatePostTradePair(self.shallow_extend(order, params))
      tradeItems = self.safe_value(response, 'tradeitems', [])
      tradeItemsByType = self.index_by(tradeItems, 'type')
      created = self.safe_value(tradeItemsByType, 'created', {})
      orderId = self.safe_string(created, 'orderid')
      return {
        'info' => response,
        'id' => orderId
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancelorder(self.shallow_extend({
        'orderid' => id
      }, params))
    end

    def create_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostGetnewdepositaddressCurrency(self.shallow_extend({
        'currency' => currency
      }, params))
      address = self.safe_string(response, 'address')
      self.check_address(address)
      tag = self.safe_string(response, 'tag')
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostGetdepositaddressCurrency(self.shallow_extend({
        'currency' => currency
      }, params))
      address = self.safe_string(response, 'address')
      self.check_address(address)
      tag = self.safe_string(response, 'tag')
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/'
      if api == 'private'
        url += api + '/'
      end
      url += self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        url += '?' + self.urlencode({ 'nonce' => nonce })
        signature = self.hmac(self.encode(url), self.encode(self.secret), 'sha512', 'base64')
        body = self.urlencode(self.shallow_extend({
          'apikey' => self.apiKey,
          'signature' => signature
        }, query))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('status')
        if response['status'] != 'success'
          raise(ExchangeError, self.id + ' ' + self.json(response))
        end
      end
      return response
    end
  end
end
