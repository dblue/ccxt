# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bitmarket < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bitmarket',
        'name' => 'BitMarket',
        'countries' => ['PL', 'EU'],
        'rateLimit' => 1500,
        'has' => {
          'CORS' => false,
          'fetchOHLCV' => true,
          'withdraw' => true
        },
        'timeframes' => {
          '90m' => '90m',
          '6h' => '6h',
          '1d' => '1d',
          '1w' => '7d',
          '1M' => '1m',
          '3M' => '3m',
          '6M' => '6m',
          '1y' => '1y'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27767256-a8555200-5ef9-11e7-96fd-469a65e2b0bd.jpg',
          'api' => {
            'public' => 'https://www.bitmarket.net',
            'private' => 'https://www.bitmarket.pl/api2/', # last slash is critical
          },
          'www' => [
            'https://www.bitmarket.pl',
            'https://www.bitmarket.net'
          ],
          'doc' => [
            'https://www.bitmarket.net/docs.php?file=api_public.html',
            'https://www.bitmarket.net/docs.php?file=api_private.html',
            'https://github.com/bitmarket-net/api'
          ],
          'referral' => 'https://www.bitmarket.net/?ref=23323'
        },
        'api' => {
          'public' => {
            'get' => [
              'json/{market}/ticker',
              'json/{market}/orderbook',
              'json/{market}/trades',
              'json/ctransfer',
              'graphs/{market}/90m',
              'graphs/{market}/6h',
              'graphs/{market}/1d',
              'graphs/{market}/7d',
              'graphs/{market}/1m',
              'graphs/{market}/3m',
              'graphs/{market}/6m',
              'graphs/{market}/1y'
            ]
          },
          'private' => {
            'post' => [
              'info',
              'trade',
              'cancel',
              'orders',
              'trades',
              'history',
              'withdrawals',
              'tradingdesk',
              'tradingdeskStatus',
              'tradingdeskConfirm',
              'cryptotradingdesk',
              'cryptotradingdeskStatus',
              'cryptotradingdeskConfirm',
              'withdraw',
              'withdrawFiat',
              'withdrawPLNPP',
              'withdrawFiatFast',
              'deposit',
              'transfer',
              'transfers',
              'marginList',
              'marginOpen',
              'marginClose',
              'marginCancel',
              'marginModify',
              'marginBalanceAdd',
              'marginBalanceRemove',
              'swapList',
              'swapOpen',
              'swapClose'
            ]
          }
        },
        'markets' => {
          'BCH/PLN' => { 'id' => 'BCCPLN', 'symbol' => 'BCH/PLN', 'base' => 'BCH', 'quote' => 'PLN' },
          'BTG/PLN' => { 'id' => 'BTGPLN', 'symbol' => 'BTG/PLN', 'base' => 'BTG', 'quote' => 'PLN' },
          'BTC/PLN' => { 'id' => 'BTCPLN', 'symbol' => 'BTC/PLN', 'base' => 'BTC', 'quote' => 'PLN' },
          'BTC/EUR' => { 'id' => 'BTCEUR', 'symbol' => 'BTC/EUR', 'base' => 'BTC', 'quote' => 'EUR' },
          'LTC/PLN' => { 'id' => 'LTCPLN', 'symbol' => 'LTC/PLN', 'base' => 'LTC', 'quote' => 'PLN' },
          'LTC/BTC' => { 'id' => 'LTCBTC', 'symbol' => 'LTC/BTC', 'base' => 'LTC', 'quote' => 'BTC' },
          'LiteMineX/BTC' => { 'id' => 'LiteMineXBTC', 'symbol' => 'LiteMineX/BTC', 'base' => 'LiteMineX', 'quote' => 'BTC' }
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'percentage' => true,
            'taker' => 0.45 / 100,
            'maker' => 0.15 / 100,
            'tiers' => {
              'taker' => [
                [0, 0.45 / 100],
                [99.99, 0.44 / 100],
                [299.99, 0.43 / 100],
                [499.99, 0.42 / 100],
                [999.99, 0.41 / 100],
                [1999.99, 0.40 / 100],
                [2999.99, 0.39 / 100],
                [4999.99, 0.38 / 100],
                [9999.99, 0.37 / 100],
                [19999.99, 0.36 / 100],
                [29999.99, 0.35 / 100],
                [49999.99, 0.34 / 100],
                [99999.99, 0.33 / 100],
                [199999.99, 0.32 / 100],
                [299999.99, 0.31 / 100],
                [499999.99, 0.0 / 100]
              ],
              'maker' => [
                [0, 0.15 / 100],
                [99.99, 0.14 / 100],
                [299.99, 0.13 / 100],
                [499.99, 0.12 / 100],
                [999.99, 0.11 / 100],
                [1999.99, 0.10 / 100],
                [2999.99, 0.9 / 100],
                [4999.99, 0.8 / 100],
                [9999.99, 0.7 / 100],
                [19999.99, 0.6 / 100],
                [29999.99, 0.5 / 100],
                [49999.99, 0.4 / 100],
                [99999.99, 0.3 / 100],
                [199999.99, 0.2 / 100],
                [299999.99, 0.1 / 100],
                [499999.99, 0.0 / 100]
              ]
            }
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {
              'BTC' => 0.0008,
              'LTC' => 0.005,
              'BCH' => 0.0008,
              'BTG' => 0.0008,
              'DOGE' => 1,
              'EUR' => 2,
              'PLN' => 2
            },
            'deposit' => {
              'BTC' => 0,
              'LTC' => 0,
              'BCH' => 0,
              'BTG' => 0,
              'DOGE' => 25,
              'EUR' => 2, # SEPA. Transfer INT(SHA) => 5 EUR
              'PLN' => 0
            }
          }
        }
      })
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostInfo
      data = response['data']
      balance = data['balances']
      result = { 'info' => data }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        account = self.account
        if balance['available'].include?(currency)
          account['free'] = balance['available'][currency]
        end
        if balance['blocked'].include?(currency)
          account['used'] = balance['blocked'][currency]
        end
        account['total'] = self.sum(account['free'], account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      orderbook = self.publicGetJsonMarketOrderbook(self.shallow_extend({
        'market' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook)
    end

    def fetch_ticker(symbol, params = {})
      ticker = self.publicGetJsonMarketTicker(self.shallow_extend({
        'market' => self.market_id(symbol)
      }, params))
      timestamp = self.milliseconds
      vwap = self.safe_float(ticker, 'vwap')
      baseVolume = self.safe_float(ticker, 'volume')
      quoteVolume = nil
      if baseVolume != nil && vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      side = (trade['type'] == 'bid') ? 'buy' : 'sell'
      timestamp = trade['date'] * 1000
      return {
        'id' => trade['tid'].to_s,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'order' => nil,
        'type' => nil,
        'side' => side,
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetJsonMarketTrades(self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '90m', since = nil, limit = nil)
      return [
        ohlcv['time'] * 1000,
        parse_float(ohlcv['open']),
        parse_float(ohlcv['high']),
        parse_float(ohlcv['low']),
        parse_float(ohlcv['close']),
        parse_float(ohlcv['vol'])
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '90m', since = nil, limit = nil, params = {})
      self.load_markets
      method = 'publicGetGraphsMarket' + self.timeframes[timeframe]
      market = self.market(symbol)
      response = self.send_wrapper(method, self.shallow_extend({
        'market' => market['id']
      }, params))
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      response = self.privatePostTrade(self.shallow_extend({
        'market' => self.market_id(symbol),
        'type' => side,
        'amount' => amount,
        'rate' => price
      }, params))
      result = {
        'info' => response
      }
      if response['data'].include?('id')
        result['id'] = response['id']
      end
      return result
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancel({ 'id' => id })
    end

    def is_fiat(currency)
      if currency == 'EUR'
        return true
      end
      if currency == 'PLN'
        return true
      end
      return false
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      method = nil
      request = {
        'currency' => currency['id'],
        'quantity' => amount
      }
      if self.is_fiat(code)
        method = 'privatePostWithdrawFiat'
        if params.include?('account')
          request['account'] = params['account'] # bank account code for withdrawal
        else
          raise(ExchangeError, self.id + ' requires account parameter to withdraw fiat currency')
        end
        if params.include?('account2')
          request['account2'] = params['account2'] # bank SWIFT code(EUR only)
        else
          if currency == 'EUR'
            raise(ExchangeError, self.id + ' requires account2 parameter to withdraw EUR')
          end
        end
        if params.include?('withdrawal_note')
          request['withdrawal_note'] = params['withdrawal_note'] # a 10-character user-specified withdrawal note(PLN only)
        else
          if currency == 'PLN'
            raise(ExchangeError, self.id + ' requires withdrawal_note parameter to withdraw PLN')
          end
        end
      else
        method = 'privatePostWithdraw'
        request['address'] = address
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => response
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api]
      if api == 'public'
        url += '/' + self.implode_params(path + '.json', params)
      else
        self.check_required_credentials
        nonce = self.nonce
        query = self.shallow_extend({
          'tonce' => nonce,
          'method' => path
        }, params)
        body = self.urlencode(query)
        headers = {
          'API-Key' => self.apiKey,
          'API-Hash' => self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
