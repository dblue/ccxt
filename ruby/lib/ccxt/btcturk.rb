# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Btcturk < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'btcturk',
        'name' => 'BTCTurk',
        'countries' => ['TR'], # Turkey
        'rateLimit' => 1000,
        'has' => {
          'CORS' => true,
          'fetchTickers' => true,
          'fetchOHLCV' => true
        },
        'timeframes' => {
          '1d' => '1d'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27992709-18e15646-64a3-11e7-9fa2-b0950ec7712f.jpg',
          'api' => 'https://www.btcturk.com/api',
          'www' => 'https://www.btcturk.com',
          'doc' => 'https://github.com/BTCTrader/broker-api-docs'
        },
        'api' => {
          'public' => {
            'get' => [
              'ohlcdata', # ?last=COUNT
              'orderbook',
              'ticker',
              'trades',   # ?last=COUNT(max 50)
            ]
          },
          'private' => {
            'get' => [
              'balance',
              'openOrders',
              'userTransactions', # ?offset=0&limit=25&sort=asc
            ],
            'post' => [
              'exchange',
              'cancelOrder'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.002 * 1.18,
            'taker' => 0.0035 * 1.18
          }
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetTicker
      result = []
      for i in (0...response.length)
        market = response[i]
        id = market['pair']
        baseId = id[0...3]
        quoteId = id[3...6]
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        baseId = baseId.downcase
        quoteId = quoteId.downcase
        symbol = base + '/' + quote
        precision = {
          'amount' => 8,
          'price' => 8
        }
        active = true
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'info' => market,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => nil
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def fetch_balance(params = {})
      response = self.privateGetBalance
      result = { 'info' => response }
      codes = self.currencies.keys
      for i in (0...codes.length)
        code = codes[i]
        currency = self.currencies[code]
        account = self.account
        free = currency['id'] + '_available'
        total = currency['id'] + '_balance'
        used = currency['id'] + '_reserved'
        if response.include?(free)
          account['free'] = self.safe_float(response, free)
          account['total'] = self.safe_float(response, total)
          account['used'] = self.safe_float(response, used)
        end
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      market = self.market(symbol)
      orderbook = self.publicGetOrderbook(self.shallow_extend({
        'pairSymbol' => market['id']
      }, params))
      timestamp = parse_int(orderbook['timestamp'] * 1000)
      return self.parse_order_book(orderbook, timestamp)
    end

    def parse_ticker(ticker, market = nil)
      symbol = nil
      if market
        symbol = market['symbol']
      end
      timestamp = parse_int(ticker['timestamp']) * 1000
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'open'),
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => self.safe_float(ticker, 'average'),
        'baseVolume' => self.safe_float(ticker, 'volume'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTicker(params)
      result = {}
      for i in (0...tickers.length)
        ticker = tickers[i]
        symbol = ticker['pair']
        market = nil
        if self.markets_by_id.include?(symbol)
          market = self.markets_by_id[symbol]
          symbol = market['symbol']
        end
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      tickers = self.fetch_tickers
      result = nil
      if tickers.include?(symbol)
        result = tickers[symbol]
      end
      return result
    end

    def parse_trade(trade, market)
      timestamp = trade['date'] * 1000
      return {
        'id' => trade['tid'],
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => nil,
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      # maxCount = 50
      response = self.publicGetTrades(self.shallow_extend({
        'pairSymbol' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1d', since = nil, limit = nil)
      timestamp = self.parse8601(ohlcv['Time'])
      return [
        timestamp,
        ohlcv['Open'],
        ohlcv['High'],
        ohlcv['Low'],
        ohlcv['Close'],
        ohlcv['Volume']
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1d', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {}
      if limit != nil
        request['last'] = limit
      end
      response = self.publicGetOhlcdata(self.shallow_extend(request, params))
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      order = {
        'PairSymbol' => self.market_id(symbol),
        'OrderType' => (side == 'buy') ? 0 : 1,
        'OrderMethod' => (type == 'market') ? 1 : 0
      }
      if type == 'market'
        if params.include?(!('Total'))
          raise(ExchangeError, self.id + ' createOrder requires the "Total" extra parameter for market orders(amount and price are both ignored)')
        end
      else
        order['Price'] = price
        order['Amount'] = amount
      end
      response = self.privatePostExchange(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['id']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancelOrder({ 'id' => id })
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      if self.id == 'btctrader'
        raise(ExchangeError, self.id + ' is an abstract base API for BTCExchange, BTCTurk')
      end
      url = self.urls['api'] + '/' + path
      if api == 'public'
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        body = self.urlencode(params)
        secret = Base64.decode64(self.secret)
        auth = self.apiKey + nonce
        headers = {
          'X-PCK' => self.apiKey,
          'X-Stamp' => nonce,
          'X-Signature' => Base64.encode64(self.hmac(self.encode(auth), secret, 'sha256', 'binary')),
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
