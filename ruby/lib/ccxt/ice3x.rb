# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Ice3x < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'ice3x',
        'name' => 'ICE3X',
        'countries' => ['ZA'], # South Africa
        'rateLimit' => 1000,
        'version' => 'v1',
        'has' => {
          'fetchCurrencies' => true,
          'fetchTickers' => true,
          'fetchOrder' => true,
          'fetchOpenOrders' => true,
          'fetchMyTrades' => true,
          'fetchDepositAddress' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/38012176-11616c32-3269-11e8-9f05-e65cf885bb15.jpg',
          'api' => 'https://ice3x.com/api',
          'www' => [
            'https://ice3x.com',
            'https://ice3x.co.za'
          ],
          'doc' => 'https://ice3x.co.za/ice-cubed-bitcoin-exchange-api-documentation-1-june-2017',
          'fees' => [
            'https://help.ice3.com/support/solutions/articles/11000033293-trading-fees',
            'https://help.ice3.com/support/solutions/articles/11000033288-fees-explained',
            'https://help.ice3.com/support/solutions/articles/11000008131-what-are-your-fiat-deposit-and-withdrawal-fees-',
            'https://help.ice3.com/support/solutions/articles/11000033289-deposit-fees'
          ],
          'referral' => 'https://ice3x.com?ref=14341802'
        },
        'api' => {
          'public' => {
            'get' => [
              'currency/list',
              'currency/info',
              'pair/list',
              'pair/info',
              'stats/marketdepthfull',
              'stats/marketdepthbtcav',
              'stats/marketdepth',
              'orderbook/info',
              'trade/list',
              'trade/info'
            ]
          },
          'private' => {
            'post' => [
              'balance/list',
              'balance/info',
              'order/new',
              'order/cancel',
              'order/list',
              'order/info',
              'trade/list',
              'trade/info',
              'transaction/list',
              'transaction/info',
              'invoice/list',
              'invoice/info',
              'invoice/pdf'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.01,
            'taker' => 0.01
          }
        },
        'precision' => {
          'amount' => 8,
          'price' => 8
        }
      })
    end

    def fetch_currencies(params = {})
      response = self.publicGetCurrencyList(params)
      currencies = response['response']['entities']
      precision = self.precision['amount']
      result = {}
      for i in (0...currencies.length)
        currency = currencies[i]
        id = self.safe_string(currency, 'currency_id')
        code = self.safe_string(currency, 'iso')
        code = code.upcase
        code = self.common_currency_code(code)
        result[code] = {
          'id' => id,
          'code' => code,
          'name' => currency['name'],
          'active' => true,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => nil,
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => currency
        }
      end
      return result
    end

    def fetch_markets(params = {})
      if !(self.currencies.size > 0)
        self.currencies = self.fetch_currencies
      end
      self.currencies_by_id = self.index_by(self.currencies, 'id')
      response = self.publicGetPairList
      markets = response['response']['entities']
      result = []
      for i in (0...markets.length)
        market = markets[i]
        id = self.safe_string(market, 'pair_id')
        baseId = self.safe_string(market, 'currency_id_from')
        quoteId = self.safe_string(market, 'currency_id_to')
        baseCurrency = self.currencies_by_id[baseId]
        quoteCurrency = self.currencies_by_id[quoteId]
        base = self.common_currency_code(baseCurrency['code'])
        quote = self.common_currency_code(quoteCurrency['code'])
        symbol = base + '/' + quote
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'info' => market
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = market['symbol']
      last = self.safe_float(ticker, 'last_price')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'max'),
        'low' => self.safe_float(ticker, 'min'),
        'bid' => self.safe_float(ticker, 'max_bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'min_ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => self.safe_float(ticker, 'avg'),
        'baseVolume' => nil,
        'quoteVolume' => self.safe_float(ticker, 'vol'),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetStatsMarketdepthfull(self.shallow_extend({
        'pair_id' => market['id']
      }, params))
      return self.parse_ticker(response['response']['entity'], market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetStatsMarketdepthfull(params)
      tickers = response['response']['entities']
      result = {}
      for i in (0...tickers.length)
        ticker = tickers[i]
        marketId = self.safe_string(ticker, 'pair_id')
        market = self.safe_value(self.marketsById, marketId)
        if market != nil
          symbol = market['symbol']
          result[symbol] = self.parse_ticker(ticker, market)
        end
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'pair_id' => self.market_id(symbol)
      }
      if limit != nil
        type = self.safe_string(params, 'type')
        if (type != 'ask') && (type != 'bid')
          # eslint-disable-next-line quotes
          raise(ExchangeError, self.id + " fetchOrderBook requires an exchange-specific extra 'type' param('bid' or 'ask') when used with a limit")
        else
          request['items_per_page'] = limit
        end
      end
      response = self.publicGetOrderbookInfo(self.shallow_extend(request, params))
      orderbook = response['response']['entities']
      return self.parse_order_book(orderbook, nil, 'bids', 'asks', 'price', 'amount')
    end

    def parse_trade(trade, market = nil)
      timestamp = parse_int(trade['created']) * 1000
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'volume')
      symbol = market['symbol']
      cost = parse_float(self.cost_to_precision(symbol, price * amount))
      fee = self.safe_float(trade, 'fee')
      if fee
        fee = {
          'cost' => fee,
          'currency' => market['quote']
        }
      end
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => self.safe_string(trade, 'trade_id'),
        'order' => nil,
        'type' => 'limit',
        'side' => trade['type'],
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTradeList(self.shallow_extend({
        'pair_id' => market['id']
      }, params))
      trades = response['response']['entities']
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostBalanceList(params)
      result = { 'info' => response }
      balances = response['response']['entities']
      for i in (0...balances.length)
        balance = balances[i]
        id = balance['currency_id']
        if self.currencies_by_id.include?(id)
          currency = self.currencies_by_id[id]
          code = currency['code']
          result[code] = {
            'free' => 0.0,
            'used' => 0.0,
            'total' => parse_float(balance['balance'])
          }
        end
      end
      return self.parse_balance(result)
    end

    def parse_order(order, market = nil)
      pairId = self.safe_integer(order, 'pair_id')
      symbol = nil
      if pairId && !market && (self.marketsById.include?(pairId))
        market = self.marketsById[pairId]
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'created') * 1000
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'volume')
      status = self.safe_integer(order, 'active')
      remaining = self.safe_float(order, 'remaining')
      filled = nil
      if status == 1
        status = 'open'
      else
        status = 'closed'
        remaining = 0
        filled = amount
      end
      fee = self.safe_float(order, 'fee')
      if fee
        fee = { 'cost' => fee }
        if market
          fee['currency'] = market['quote']
        end
      end
      return {
        'id' => self.safe_string(order, 'order_id'),
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => order['type'],
        'price' => price,
        'cost' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => fee,
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostOrderNew(self.shallow_extend({
        'pair_id' => market['id'],
        'type' => side,
        'amount' => amount,
        'price' => price
      }, params))
      order = self.parse_order({
        'order_id' => response['response']['entity']['order_id'],
        'created' => self.seconds,
        'active' => 1,
        'type' => side,
        'price' => price,
        'volume' => amount,
        'remaining' => amount,
        'info' => response
      }, market)
      id = order['id']
      self.orders[id] = order
      return order
    end

    def cancel_order(id, symbol = nil, params = {})
      response = self.privatePostOrderCancel(self.shallow_extend({
        'order_id' => id
      }, params))
      return response
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePostOrderInfo(self.shallow_extend({
        'order _id' => id
      }, params))
      return self.parse_order(response['response']['entity'])
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      response = self.privatePostOrderList
      orders = response['response']['entities']
      return self.parse_orders(orders, nil, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'pair_id' => market['id']
      }
      if limit != nil
        request['items_per_page'] = limit
      end
      if since != nil
        request['date_from'] = parse_int(since / 1000)
      end
      response = self.privatePostTradeList(self.shallow_extend(request, params))
      trades = response['response']['entities']
      return self.parse_trades(trades, market, since, limit)
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostBalanceInfo(self.shallow_extend({
        'currency_id' => currency['id']
      }, params))
      balance = response['response']['entity']
      address = self.safe_string(balance, 'address')
      status = address ? 'ok' : 'none'
      return {
        'currency' => code,
        'address' => address,
        'tag' => nil,
        'status' => status,
        'info' => response
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + path
      if api == 'public'
        if params.size > 0
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        body = self.urlencode(self.shallow_extend({
          'nonce' => self.nonce
        }, params))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Key' => self.apiKey,
          'Sign' => self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      errors = self.safe_value(response, 'errors')
      data = self.safe_value(response, 'response')
      if errors || !data
        authErrorKeys = ['Key', 'user_id', 'Sign']
        for i in (0...authErrorKeys.length)
          errorKey = authErrorKeys[i]
          errorMessage = self.safe_string(errors, errorKey)
          if !errorMessage
            next
          end
          if errorKey == 'user_id' && !errorMessage.include?('authorization')
            next
          end
          raise(AuthenticationError, errorMessage)
        end
        raise(ExchangeError, self.json(errors))
      end
      return response
    end
  end
end
