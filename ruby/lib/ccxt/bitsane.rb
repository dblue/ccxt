# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bitsane < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bitsane',
        'name' => 'Bitsane',
        'countries' => ['IE'], # Ireland
        'has' => {
          'fetchCurrencies' => true,
          'fetchTickers' => true,
          'fetchOpenOrders' => true,
          'fetchDepositAddress' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/41387105-d86bf4c6-6f8d-11e8-95ea-2fa943872955.jpg',
          'api' => 'https://bitsane.com/api',
          'www' => 'https://bitsane.com',
          'doc' => 'https://bitsane.com/help/api',
          'fees' => 'https://bitsane.com/help/fees'
        },
        'api' => {
          'public' => {
            'get' => [
              'assets/currencies',
              'assets/pairs',
              'ticker',
              'orderbook',
              'trades'
            ]
          },
          'private' => {
            'post' => [
              'balances',
              'order/cancel',
              'order/new',
              'order/status',
              'orders',
              'orders/history',
              'deposit/address',
              'withdraw',
              'withdrawal/status',
              'transactions/history',
              'vouchers',
              'vouchers/create',
              'vouchers/redeem'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.15 / 100,
            'taker' => 0.25 / 100
          }
        },
        'exceptions' => {
          '3' => AuthenticationError,
          '4' => AuthenticationError,
          '5' => AuthenticationError,
          '6' => InvalidNonce,
          '7' => AuthenticationError,
          '8' => InvalidNonce,
          '9' => AuthenticationError,
          '10' => AuthenticationError,
          '11' => AuthenticationError
        },
        'options' => {
          'defaultCurrencyPrecision' => 2
        }
      })
    end

    def fetch_currencies(params = {})
      currencies = self.publicGetAssetsCurrencies(params)
      ids = currencies.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        currency = currencies[id]
        precision = self.safe_integer(currency, 'precision', self.options['defaultCurrencyPrecision'])
        code = self.common_currency_code(id)
        canWithdraw = self.safe_value(currency, 'withdrawal', true)
        canDeposit = self.safe_value(currency, 'deposit', true)
        active = true
        if !canWithdraw || !canDeposit
          active = false
        end
        result[code] = {
          'id' => id,
          'code' => code,
          'name' => self.safe_string(currency, 'full_name', code),
          'active' => active,
          'precision' => precision,
          'funding' => {
            'withdraw' => {
              'active' => canWithdraw,
              'fee' => self.safe_value(currency, 'withdrawal_fee')
            },
            'deposit' => {
              'active' => canDeposit,
              'fee' => self.safe_value(currency, 'deposit_fee')
            }
          },
          'limits' => {
            'amount' => {
              'min' => self.safe_float(currency, 'minAmountTrade'),
              'max' => 10**precision
            },
            'price' => {
              'min' => 10**-precision,
              'max' => 10**precision
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => currency
        }
      end
      return result
    end

    def fetch_markets(params = {})
      markets = self.publicGetAssetsPairs
      result = []
      marketIds = markets.keys
      for i in (0...marketIds.length)
        id = marketIds[i]
        market = markets[id]
        base = self.common_currency_code(market['base'])
        quote = self.common_currency_code(market['quote'])
        symbol = base + '/' + quote
        limits = self.safe_value(market, 'limits')
        minLimit = nil
        maxLimit = nil
        if limits != nil
          minLimit = self.safe_float(limits, 'minimum')
          maxLimit = self.safe_float(limits, 'maximum')
        end
        precision = {
          'amount' => parse_int(market['precision']),
          'price' => 8
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => market['base'],
          'quoteId' => market['quote'],
          'active' => true,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => minLimit,
              'max' => maxLimit
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => 10**precision['price']
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => id
        })
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      symbol = market['symbol']
      timestamp = self.milliseconds
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high24hr'),
        'low' => self.safe_float(ticker, 'low24hr'),
        'bid' => self.safe_float(ticker, 'highestBid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'lowestAsk'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => self.safe_float(ticker, 'percentChange'),
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'baseVolume'),
        'quoteVolume' => self.safe_float(ticker, 'quoteVolume'),
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      tickers = self.fetch_tickers([symbol], params)
      return tickers[symbol]
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      request = {}
      if symbols
        ids = self.market_ids(symbols)
        request['pairs'] = ids.join(',')
      end
      tickers = self.publicGetTicker(self.shallow_extend(request, params))
      marketIds = tickers.keys
      result = {}
      for i in (0...marketIds.length)
        id = marketIds[i]
        market = self.safe_value(self.marketsById, id)
        if market.nil?
          next
        end
        symbol = market['symbol']
        ticker = tickers[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      response = self.publicGetOrderbook(self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(response['result'], nil, 'bids', 'asks', 'price', 'amount')
    end

    def parse_trade(trade, market = nil)
      symbol = market['symbol']
      timestamp = parse_int(trade['timestamp']) * 1000
      price = parse_float(trade['price'])
      amount = parse_float(trade['amount'])
      cost = self.cost_to_precision(symbol, price * amount)
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => self.safe_string(trade, 'tid'),
        'order' => nil,
        'type' => nil,
        'side' => nil,
        'price' => price,
        'amount' => amount,
        'cost' => parse_float(cost),
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'pair' => market['id']
      }
      if since != nil
        request['since'] = parse_int(since / 1000)
      end
      if limit != nil
        request['limit'] = limit
      end
      response = self.publicGetTrades(self.shallow_extend(request, params))
      return self.parse_trades(response['result'], market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostBalances(params)
      result = { 'info' => response }
      balances = response['result']
      ids = balances.keys
      for i in (0...ids.length)
        id = ids[i]
        balance = balances[id]
        code = id
        if self.currencies_by_id.include?(id)
          code = self.currencies_by_id[id]['code']
        else
          code = self.common_currency_code(code)
        end
        account = {
          'free' => parse_float(balance['amount']),
          'used' => parse_float(balance['locked']),
          'total' => parse_float(balance['total'])
        }
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def parse_order(order, market = nil)
      symbol = nil
      if !market
        market = self.safe_value(self.marketsById, order['pair'])
      end
      if market
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'timestamp') * 1000
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'original_amount')
      filled = self.safe_float(order, 'executed_amount')
      remaining = self.safe_float(order, 'remaining_amount')
      isCanceled = self.safe_value(order, 'is_cancelled')
      isLive = self.safe_value(order, 'is_live')
      status = 'closed'
      if isCanceled
        status = 'canceled'
      elsif isLive
        status = 'open'
      end
      return {
        'id' => self.safe_string(order, 'id'),
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'status' => status,
        'symbol' => symbol,
        'type' => self.safe_string(order, 'type'),
        'side' => self.safe_string(order, 'side'),
        'price' => price,
        'cost' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => nil,
        'info' => self.safe_value(order, 'info', order)
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      order = {
        'pair' => market['id'],
        'amount' => amount,
        'type' => type,
        'side' => side
      }
      if type != 'market'
        order['price'] = price
      end
      response = self.privatePostOrderNew(self.shallow_extend(order, params))
      order['id'] = response['result']['order_id']
      order['timestamp'] = self.seconds
      order['original_amount'] = order['amount']
      order['info'] = response
      order = self.parse_order(order, market)
      id = order['id']
      self.orders[id] = order
      return order
    end

    def cancel_order(id, symbol = nil, params = {})
      response = self.privatePostOrderCancel(self.shallow_extend({
        'order_id' => id
      }, params))
      return self.parse_order(response['result'])
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePostOrderStatus(self.shallow_extend({
        'order_id' => id
      }, params))
      return self.parse_order(response['result'])
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      response = self.privatePostOrders
      return self.parse_orders(response['result'], nil, since, limit)
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostDepositAddress(self.shallow_extend({
        'currency' => currency['id']
      }, params))
      address = self.safe_string(response['result'], 'address')
      return {
        'currency' => code,
        'address' => address,
        'tag' => nil,
        'info' => response
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'amount' => amount,
        'address' => address
      }
      if tag
        request['additional'] = tag
      end
      response = self.privatePostWithdraw(self.shallow_extend(request, params))
      return {
        'id' => response['result']['withdrawal_id'],
        'info' => response
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + api + '/' + path
      if api == 'public'
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        body = self.shallow_extend({
          'nonce' => self.nonce
        }, params)
        payload = self.json(body)
        payload64 = Base64.encode64(self.encode(payload))
        body = self.decode(payload64)
        headers = {
          'X-BS-APIKEY' => self.apiKey,
          'X-BS-PAYLOAD' => body,
          'X-BS-SIGNATURE' => self.hmac(payload64, self.encode(self.secret), 'sha384')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        statusCode = self.safe_string(response, 'statusCode')
        if statusCode != nil
          if statusCode != '0'
            feedback = self.id + ' ' + self.json(response)
            exceptions = self.exceptions
            if exceptions.include?(statusCode)
              raise(exceptions[statusCode], feedback)
            else
              raise(ExchangeError, self.id + ' ' + self.json(response))
            end
          end
        end
        return response
      end
    end
  end
end
