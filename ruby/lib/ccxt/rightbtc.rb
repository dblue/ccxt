# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Rightbtc < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'rightbtc',
        'name' => 'RightBTC',
        'countries' => ['AE'],
        'has' => {
          'privateAPI' => false,
          'fetchTickers' => true,
          'fetchOHLCV' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => false,
          'fetchOrder' => 'emulated',
          'fetchMyTrades' => true
        },
        'timeframes' => {
          '1m' => 'min1',
          '5m' => 'min5',
          '15m' => 'min15',
          '30m' => 'min30',
          '1h' => 'hr1',
          '1d' => 'day1',
          '1w' => 'week'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/42633917-7d20757e-85ea-11e8-9f53-fffe9fbb7695.jpg',
          'api' => 'https://www.rightbtc.com/api',
          'www' => 'https://www.rightbtc.com',
          'doc' => [
            'https://52.53.159.206/api/trader/',
            'https://support.rightbtc.com/hc/en-us/articles/360012809412'
          ],
          # eslint-disable-next-line no-useless-escape
          # 'fees' => 'https://www.rightbtc.com/\#\!/support/fee'
        },
        'api' => {
          'public' => {
            'get' => [
              # 'getAssetsTradingPairs/zh', # 404
              'trading_pairs',
              'ticker/{trading_pair}',
              'tickers',
              'depth/{trading_pair}',
              'depth/{trading_pair}/{count}',
              'trades/{trading_pair}',
              'trades/{trading_pair}/{count}',
              'candlestick/latest/{trading_pair}',
              'candlestick/{timeSymbol}/{trading_pair}',
              'candlestick/{timeSymbol}/{trading_pair}/{count}'
            ]
          },
          'trader' => {
            'get' => [
              'balance/{symbol}',
              'balances',
              'deposits/{asset}/{page}',
              'withdrawals/{asset}/{page}',
              'orderpage/{trading_pair}/{cursor}',
              'orders/{trading_pair}/{ids}', # ids are a slash-separated list of {id}/{id}/{id}/...
              'history/{trading_pair}/{ids}',
              'historys/{trading_pair}/{page}',
              'trading_pairs'
            ],
            'post' => [
              'order'
            ],
            'delete' => [
              'order/{trading_pair}/{ids}'
            ]
          }
        },
        # HARDCODING IS DEPRECATED, THE FEES BELOW SHOULD BE REWRITTEN
        'fees' => {
          'trading' => {
            # min trading fees
            # 0.0001 BTC
            # 0.01 ETP
            # 0.001 ETH
            # 0.1 BITCNY
            'maker' => 0.2 / 100,
            'taker' => 0.2 / 100
          },
          'funding' => {
            'withdraw' => {
              # 'BTM' => n => 3 + n * (1 / 100),
              # 'ZDC' => n => 1 + n * (0.5 / 100),
              # 'ZGC' => n => 0.5 + n * (0.5 / 100),
              # 'BTS' => n => 1 + n * (1 / 100),
              # 'DLT' => n => 3 + n * (1 / 100),
              # 'SNT' => n => 10 + n * (1 / 100),
              # 'XNC' => n => 1 + n * (1 / 100),
              # 'ICO' => n => 3 + n * (1 / 100),
              # 'CMC' => n => 1 + n * (0.5 / 100),
              # 'GXS' => n => 0.2 + n * (1 / 100),
              # 'OBITS' => n => 0.3 + n * (1 / 100),
              # 'ICS' => n => 2 + n * (1 / 100),
              # 'TIC' => n => 2 + n * (1 / 100),
              # 'IND' => n => 20 + n * (1 / 100),
              # 'MVC' => n => 20 + n * (1 / 100),
              # 'BitCNY' => n => 0.1 + n * (1 / 100),
              # 'MTX' => n => 1 + n * (1 / 100),
              'ETP' => 0.01,
              'BTC' => 0.001,
              'ETH' => 0.01,
              'ETC' => 0.01,
              'STORJ' => 3,
              'LTC' => 0.001,
              'ZEC' => 0.001,
              'BCC' => 0.001,
              'XRB' => 0,
              'NXS' => 0.1
            }
          }
        },
        'commonCurrencies' => {
          'XRB' => 'NANO'
        },
        'exceptions' => {
          'ERR_USERTOKEN_NOT_FOUND' => AuthenticationError,
          'ERR_ASSET_NOT_EXISTS' => ExchangeError,
          'ERR_ASSET_NOT_AVAILABLE' => ExchangeError,
          'ERR_BALANCE_NOT_ENOUGH' => InsufficientFunds,
          'ERR_CREATE_ORDER' => InvalidOrder,
          'ERR_CANDLESTICK_DATA' => ExchangeError
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetTradingPairs
      # zh = self.publicGetGetAssetsTradingPairsZh
      markets = self.shallow_extend(response['status']['message'])
      marketIds = markets.keys
      result = []
      for i in (0...marketIds.length)
        id = marketIds[i]
        market = markets[id]
        baseId = market['bid_asset_symbol']
        quoteId = market['ask_asset_symbol']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => parse_int(market['bid_asset_decimals']),
          'price' => parse_int(market['ask_asset_decimals'])
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => 10**precision['price']
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => 10**precision['price']
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => market
        })
      end
      return result
    end

    def divide_safe_float(x, key, divisor)
      value = self.safe_float(x, key)
      if value != nil
        return value / divisor
      end
      return value
    end

    def parse_ticker(ticker, market = nil)
      symbol = market['symbol']
      timestamp = ticker['date']
      last = self.divide_safe_float(ticker, 'last', 1e8)
      high = self.divide_safe_float(ticker, 'high', 1e8)
      low = self.divide_safe_float(ticker, 'low', 1e8)
      bid = self.divide_safe_float(ticker, 'buy', 1e8)
      ask = self.divide_safe_float(ticker, 'sell', 1e8)
      baseVolume = self.divide_safe_float(ticker, 'vol24h', 1e8)
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => high,
        'low' => low,
        'bid' => bid,
        'bidVolume' => nil,
        'ask' => ask,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTickerTradingPair(self.shallow_extend({
        'trading_pair' => market['id']
      }, params))
      return self.parse_ticker(response['result'], market)
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetTickers(params)
      tickers = response['result']
      result = {}
      for i in (0...tickers.length)
        ticker = tickers[i]
        id = ticker['market']
        if self.marketsById.include?(!(id))
          next
        end
        market = self.marketsById[id]
        symbol = market['symbol']
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'trading_pair' => self.market_id(symbol)
      }
      method = 'publicGetDepthTradingPair'
      if limit != nil
        method += 'Count'
        request['count'] = limit
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      bidsasks = {}
      types = ['bid', 'ask']
      for ti in (0...types.length)
        type = types[ti]
        bidsasks[type] = []
        for i in (0...response['result'][type].length)
          price, amount, total = response['result'][type][i]
          bidsasks[type].push([
            price / 1e8,
            amount / 1e8,
            total / 1e8
          ])
        end
      end
      return self.parse_order_book(bidsasks, nil, 'bid', 'ask')
    end

    def parse_trade(trade, market = nil)
      #
      #     {
      #         "order_id" => 118735,
      #         "trade_id" => 7,
      #         "trading_pair" => "BTCCNY",
      #         "side" => "B",
      #         "quantity" => 1000000000,
      #         "price" => 900000000,
      #         "created_at" => "2017-06-06T20:45:27.000Z"
      #     }
      #
      timestamp = self.safe_integer(trade, 'date')
      if timestamp.nil?
        timestamp = self.parse8601(self.safe_string(trade, 'created_at'))
      end
      id = self.safe_string(trade, 'tid')
      id = self.safe_string(trade, 'trade_id', id)
      orderId = self.safe_string(trade, 'order_id')
      price = self.divide_safe_float(trade, 'price', 1e8)
      amount = self.safe_float(trade, 'amount')
      amount = self.safe_float(trade, 'quantity', amount)
      if amount != nil
        amount = amount / 1e8
      end
      symbol = nil
      if market.nil?
        marketId = self.safe_string(trade, 'trading_pair')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      cost = self.cost_to_precision(symbol, price * amount)
      cost = parse_float(cost)
      side = self.safe_string(trade, 'side')
      side = side.downcase
      if side == 'b'
        side = 'buy'
      elsif side == 's'
        side = 'sell'
      end
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => id,
        'order' => orderId,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTradesTradingPair(self.shallow_extend({
        'trading_pair' => market['id']
      }, params))
      return self.parse_trades(response['result'], market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '5m', since = nil, limit = nil)
      return [
        ohlcv[0],
        ohlcv[2] / 1e8,
        ohlcv[3] / 1e8,
        ohlcv[4] / 1e8,
        ohlcv[5] / 1e8,
        ohlcv[1] / 1e8
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '5m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetCandlestickTimeSymbolTradingPair(self.shallow_extend({
        'trading_pair' => market['id'],
        'timeSymbol' => self.timeframes[timeframe]
      }, params))
      return self.parse_ohlcvs(response['result'], market, timeframe, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.traderGetBalances(params)
      #
      #     {
      #         "status" => {
      #             "success" => 1,
      #             "message" => "GET_BALANCES"
      #         },
      #         "result" => [
      #             {
      #                 "asset" => "ETP",
      #                 "balance" => "5000000000000",
      #                 "frozen" => "0",
      #                 "state" => "1"
      #             },
      #             {
      #                 "asset" => "CNY",
      #                 "balance" => "10000000000000",
      #                 "frozen" => "240790000",
      #                 "state" => "1"
      #             }
      #         ]
      #     }
      #
      result = { 'info' => response }
      balances = response['result']
      for i in (0...balances.length)
        balance = balances[i]
        currencyId = balance['asset']
        code = self.common_currency_code(currencyId)
        if self.currencies_by_id.include?(currencyId)
          code = self.currencies_by_id[currencyId]['code']
        end
        free = self.divide_safe_float(balance, 'balance', 1e8)
        used = self.divide_safe_float(balance, 'frozen', 1e8)
        total = self.sum(free, used)
        #
        # https://github.com/ccxt/ccxt/issues/3873
        #
        #     if total != nil
        #         if used != nil
        #             free = total - used
        #         }
        #     }
        #
        account = {
          'free' => free,
          'used' => used,
          'total' => total
        }
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      order = {
        'trading_pair' => market['id'],
        # We need to use decimalToPrecision here, since
        #   0.036*1e8 == 3599999.9999999995
        # which would get truncated to 3599999 after parse_int// which would then be rejected by rightBtc because it's too precise
        'quantity' => parse_int(self.decimal_to_precision(amount * 1e8, ROUND, 0, self.precisionMode)),
        'limit' => parse_int(self.decimal_to_precision(price * 1e8, ROUND, 0, self.precisionMode)),
        'type' => type.upcase,
        'side' => side.upcase
      }
      response = self.traderPostOrder(self.shallow_extend(order, params))
      return self.parse_order(response)
    end

    def cancel_order(id, symbol = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' cancelOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      response = self.traderDeleteOrderTradingPairIds(self.shallow_extend({
        'trading_pair' => market['id'],
        'ids' => id
      }, params))
      return response
    end

    def parse_order_status(status)
      statuses = {
        'NEW' => 'open',
        'TRADE' => 'closed', # TRADE means filled or partially filled orders
        'CANCEL' => 'canceled'
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      #
      # fetchOrder / fetchOpenOrders
      #
      #     {
      #         "id" => 4180528,
      #         "quantity" => 20000000,
      #         "rest" => 20000000,
      #         "limit" => 1000000,
      #         "price" => null,
      #         "side" => "BUY",
      #         "created" => 1496005693738
      #     }
      #
      # fetchOrders
      #
      #     {
      #         "trading_pair" => "ETPCNY",
      #         "status" => "TRADE",
      #         "fee" => 0.23,
      #         "min_fee" => 10000000,
      #         "created_at" => "2017-05-25T00:12:27.000Z",
      #         "cost" => 1152468000000,
      #         "limit" => 3600000000,
      #         "id" => 11060,
      #         "quantity" => 32013000000,
      #         "filled_quantity" => 32013000000
      #     }
      #
      id = self.safe_string(order, 'id')
      status = self.parse_order_status(self.safe_string(order, 'status'))
      marketId = self.safe_string(order, 'trading_pair')
      if market.nil?
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      symbol = marketId
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'created')
      if timestamp.nil?
        timestamp = self.parse8601(self.safe_string(order, 'created_at'))
      end
      if order.include?('time')
        timestamp = order['time']
      elsif order.include?('transactTime')
        timestamp = order['transactTime']
      end
      price = self.safe_float(order, 'limit')
      price = self.safe_float(order, 'price', price)
      if price != nil
        price = price / 1e8
      end
      amount = self.divide_safe_float(order, 'quantity', 1e8)
      filled = self.divide_safe_float(order, 'filled_quantity', 1e8)
      remaining = self.divide_safe_float(order, 'rest', 1e8)
      cost = self.divide_safe_float(order, 'cost', 1e8)
      # lines 483-494 should be generalized into a base class method
      if amount != nil
        if remaining.nil?
          if filled != nil
            remaining = maximum_wrapper(0, amount - filled)
          end
        end
        if filled.nil?
          if remaining != nil
            filled = maximum_wrapper(0, amount - remaining)
          end
        end
      end
      type = 'limit'
      side = self.safe_string(order, 'side')
      if side != nil
        side = side.downcase
      end
      feeCost = self.divide_safe_float(order, 'min_fee', 1e8)
      fee = nil
      if feeCost != nil
        feeCurrency = nil
        if market != nil
          feeCurrency = market['quote']
        end
        fee = {
          'rate' => self.safe_float(order, 'fee'),
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      trades = nil
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee,
        'trades' => trades
      }
      return result
    end

    def fetch_order(id, symbol = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'trading_pair' => market['id'],
        'ids' => id
      }
      response = self.traderGetOrdersTradingPairIds(self.shallow_extend(request, params))
      #
      # response = {
      #         "status" => {
      #             "success" => 1,
      #             "message" => "SUC_LIST_AVTICE_ORDERS"
      #         },
      #         "result" => [
      #             {
      #                 "id" => 4180528,
      #                 "quantity" => 20000000,
      #                 "rest" => 20000000,
      #                 "limit" => 1000000,
      #                 "price" => null,
      #                 "side" => "BUY",
      #                 "created" => 1496005693738
      #             }
      #         ]
      #     }
      #
      orders = self.parse_orders(response['result'], market)
      ordersById = self.index_by(orders, 'id')
      if ordersById.include?(!(id))
        raise(OrderNotFound, self.id + ' fetchOrder could not find order ' + id.to_s + ' in open orders.')
      end
      return ordersById[id]
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOpenOrders requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'trading_pair' => market['id'],
        'cursor' => 0
      }
      response = self.traderGetOrderpageTradingPairCursor(self.shallow_extend(request, params))
      #
      # response = {
      #         "status" => {
      #             "success" => 1,
      #             "message" => "SUC_LIST_AVTICE_ORDERS_PAGE"
      #         },
      #         "result" => {
      #             "cursor" => "0",
      #             "orders" => [
      #                 {
      #                     "id" => 4180528,
      #                     "quantity" => 20000000,
      #                     "rest" => 20000000,
      #                     "limit" => 1000000,
      #                     "price" => null,
      #                     "side" => "BUY",
      #                     "created" => 1496005693738
      #                 }
      #             ]
      #         }
      #     }
      #
      return self.parse_orders(response['result']['orders'], market, since, limit)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      ids = self.safe_string(params, 'ids')
      if (symbol.nil?) || (ids.nil?)
        raise(ArgumentsRequired, self.id + " fetchOrders requires a 'symbol' argument and an extra 'ids' parameter. The 'ids' should be an array or a string of one or more order ids separated with slashes.") # eslint-disable-line quotes
      end
      if ids.is_a?(Array)
        ids = ids.join('/')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'trading_pair' => market['id'],
        'ids' => ids
      }
      response = self.traderGetHistoryTradingPairIds(self.shallow_extend(request, params))
      #
      # response = {
      #         "status" => {
      #             "success" => 1,
      #             "message" => null
      #         },
      #         "result" => [
      #             {
      #                 "trading_pair" => "ETPCNY",
      #                 "status" => "TRADE",
      #                 "fee" => 0.23,
      #                 "min_fee" => 10000000,
      #                 "created_at" => "2017-05-25T00:12:27.000Z",
      #                 "cost" => 1152468000000,
      #                 "limit" => 3600000000,
      #                 "id" => 11060,
      #                 "quantity" => 32013000000,
      #                 "filled_quantity" => 32013000000
      #             }
      #         ]
      #     }
      #
      return self.parse_orders(response['result'], nil, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      response = self.traderGetHistorysTradingPairPage(self.shallow_extend({
        'trading_pair' => market['id'],
        'page' => 0
      }, params))
      #
      # response = {
      #         "status" => {
      #             "success" => 1,
      #             "message" => null
      #         },
      #         "result" => [
      #             {
      #                 "order_id" => 118735,
      #                 "trade_id" => 7,
      #                 "trading_pair" => "BTCCNY",
      #                 "side" => "B",
      #                 "quantity" => 1000000000,
      #                 "price" => 900000000,
      #                 "created_at" => "2017-06-06T20:45:27.000Z"
      #             },
      #             {
      #                 "order_id" => 118734,
      #                 "trade_id" => 7,
      #                 "trading_pair" => "BTCCNY",
      #                 "side" => "S",
      #                 "quantity" => 1000000000,
      #                 "price" => 900000000,
      #                 "created_at" => "2017-06-06T20:45:27.000Z"
      #             }
      #         ]
      #     }
      #
      return self.parse_trades(response['result'], nil, since, limit)
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      query = self.omit(params, self.extract_params(path))
      url = self.urls['api'] + '/' + api + '/' + self.implode_params(path, params)
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        headers = {
          'apikey' => self.apiKey,
          'signature' => self.secret
        }
        if method == 'GET'
          if query
            url += '?' + self.urlencode(query)
          end
        else
          body = self.json(query)
          headers['Content-Type'] = 'application/json'
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        status = self.safe_value(response, 'status')
        if status != nil
          #
          #     {"status":{"success":0,"message":"ERR_USERTOKEN_NOT_FOUND"}}
          #
          success = self.safe_string(status, 'success')
          if success != '1'
            message = self.safe_string(status, 'message')
            feedback = self.id + ' ' + self.json(response)
            exceptions = self.exceptions
            if exceptions.include?(message)
              raise(exceptions[message], feedback)
            end
            raise(ExchangeError, feedback)
          end
        end
      end
    end
  end
end
