# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bitstamp1 < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bitstamp1',
        'name' => 'Bitstamp',
        'countries' => ['GB'],
        'rateLimit' => 1000,
        'version' => 'v1',
        'has' => {
          'CORS' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
          'api' => 'https://www.bitstamp.net/api',
          'www' => 'https://www.bitstamp.net',
          'doc' => 'https://www.bitstamp.net/api'
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true,
          'uid' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'ticker',
              'ticker_hour',
              'order_book',
              'transactions',
              'eur_usd'
            ]
          },
          'private' => {
            'post' => [
              'balance',
              'user_transactions',
              'open_orders',
              'order_status',
              'cancel_order',
              'cancel_all_orders',
              'buy',
              'sell',
              'bitcoin_deposit_address',
              'unconfirmed_btc',
              'ripple_withdrawal',
              'ripple_address',
              'withdrawal_requests',
              'bitcoin_withdrawal'
            ]
          }
        },
        'markets' => {
          'BTC/USD' => { 'id' => 'btcusd', 'symbol' => 'BTC/USD', 'base' => 'BTC', 'quote' => 'USD', 'maker' => 0.0025, 'taker' => 0.0025 },
          'BTC/EUR' => { 'id' => 'btceur', 'symbol' => 'BTC/EUR', 'base' => 'BTC', 'quote' => 'EUR', 'maker' => 0.0025, 'taker' => 0.0025 },
          'EUR/USD' => { 'id' => 'eurusd', 'symbol' => 'EUR/USD', 'base' => 'EUR', 'quote' => 'USD', 'maker' => 0.0025, 'taker' => 0.0025 },
          'XRP/USD' => { 'id' => 'xrpusd', 'symbol' => 'XRP/USD', 'base' => 'XRP', 'quote' => 'USD', 'maker' => 0.0025, 'taker' => 0.0025 },
          'XRP/EUR' => { 'id' => 'xrpeur', 'symbol' => 'XRP/EUR', 'base' => 'XRP', 'quote' => 'EUR', 'maker' => 0.0025, 'taker' => 0.0025 },
          'XRP/BTC' => { 'id' => 'xrpbtc', 'symbol' => 'XRP/BTC', 'base' => 'XRP', 'quote' => 'BTC', 'maker' => 0.0025, 'taker' => 0.0025 },
          'LTC/USD' => { 'id' => 'ltcusd', 'symbol' => 'LTC/USD', 'base' => 'LTC', 'quote' => 'USD', 'maker' => 0.0025, 'taker' => 0.0025 },
          'LTC/EUR' => { 'id' => 'ltceur', 'symbol' => 'LTC/EUR', 'base' => 'LTC', 'quote' => 'EUR', 'maker' => 0.0025, 'taker' => 0.0025 },
          'LTC/BTC' => { 'id' => 'ltcbtc', 'symbol' => 'LTC/BTC', 'base' => 'LTC', 'quote' => 'BTC', 'maker' => 0.0025, 'taker' => 0.0025 },
          'ETH/USD' => { 'id' => 'ethusd', 'symbol' => 'ETH/USD', 'base' => 'ETH', 'quote' => 'USD', 'maker' => 0.0025, 'taker' => 0.0025 },
          'ETH/EUR' => { 'id' => 'etheur', 'symbol' => 'ETH/EUR', 'base' => 'ETH', 'quote' => 'EUR', 'maker' => 0.0025, 'taker' => 0.0025 },
          'ETH/BTC' => { 'id' => 'ethbtc', 'symbol' => 'ETH/BTC', 'base' => 'ETH', 'quote' => 'BTC', 'maker' => 0.0025, 'taker' => 0.0025 }
        }
      })
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      if symbol != 'BTC/USD'
        raise(ExchangeError, self.id + ' ' + self.version + " fetchOrderBook doesn't support " + symbol + ', use it for BTC/USD only')
      end
      orderbook = self.publicGetOrderBook(params)
      timestamp = parse_int(orderbook['timestamp']) * 1000
      return self.parse_order_book(orderbook, timestamp)
    end

    def fetch_ticker(symbol, params = {})
      if symbol != 'BTC/USD'
        raise(ExchangeError, self.id + ' ' + self.version + " fetchTicker doesn't support " + symbol + ', use it for BTC/USD only')
      end
      ticker = self.publicGetTicker(params)
      timestamp = parse_int(ticker['timestamp']) * 1000
      vwap = self.safe_float(ticker, 'vwap')
      baseVolume = self.safe_float(ticker, 'volume')
      quoteVolume = nil
      if baseVolume != nil && vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => self.safe_float(ticker, 'open'),
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      timestamp = nil
      if trade.include?('date')
        timestamp = parse_int(trade['date']) * 1000
      elsif trade.include?('datetime')
        # timestamp = self.parse8601(trade['datetime'])
        timestamp = parse_int(trade['datetime']) * 1000
      end
      side = (trade['type'] == 0) ? 'buy' : 'sell'
      order = nil
      if trade.include?('order_id')
        order = trade['order_id'].to_s
      end
      if trade.include?('currency_pair')
        if self.markets_by_id.include?(trade['currency_pair'])
          market = self.markets_by_id[trade['currency_pair']]
        end
      end
      return {
        'id' => trade['tid'].to_s,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'order' => order,
        'type' => nil,
        'side' => side,
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'amount')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      if symbol != 'BTC/USD'
        raise(ExchangeError, self.id + ' ' + self.version + " fetchTrades doesn't support " + symbol + ', use it for BTC/USD only')
      end
      market = self.market(symbol)
      response = self.publicGetTransactions(self.shallow_extend({
        'time' => 'minute'
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_balance(params = {})
      balance = self.privatePostBalance
      result = { 'info' => balance }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        lowercase = currency.downcase
        total = lowercase + '_balance'
        free = lowercase + '_available'
        used = lowercase + '_reserved'
        account = self.account
        account['free'] = self.safe_float(balance, free, 0.0)
        account['used'] = self.safe_float(balance, used, 0.0)
        account['total'] = self.safe_float(balance, total, 0.0)
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type != 'limit'
        raise(ExchangeError, self.id + ' ' + self.version + ' accepts limit orders only')
      end
      if symbol != 'BTC/USD'
        raise(ExchangeError, self.id + ' v1 supports BTC/USD orders only')
      end
      method = 'privatePost' + self.capitalize(side)
      order = {
        'amount' => amount,
        'price' => price
      }
      response = self.send_wrapper(method, self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['id']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancelOrder({ 'id' => id })
    end

    def parse_order_status(status)
      statuses = {
        'In Queue' => 'open',
        'Open' => 'open',
        'Finished' => 'closed',
        'Canceled' => 'canceled'
      }
      return(statuses.include?(status)) ? statuses[status] : status
    end

    def fetch_order_status(id, symbol = nil, params = {})
      self.load_markets
      request = { 'id' => id }
      response = self.privatePostOrderStatus(self.shallow_extend(request, params))
      return self.parse_order_status(response)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      pair = market ? market['id'] : 'all'
      request = self.shallow_extend({ 'id' => pair }, params)
      response = self.privatePostOpenOrdersId(request)
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_order(id, symbol = nil, params = {})
      raise(NotSupported, self.id + ' fetchOrder is not implemented yet')
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        auth = nonce + self.uid + self.apiKey
        signature = self.encode(self.hmac(self.encode(auth), self.encode(self.secret)))
        query = self.shallow_extend({
          'key' => self.apiKey,
          'signature' => signature.upcase,
          'nonce' => nonce
        }, query)
        body = self.urlencode(query)
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('status')
        if response['status'] == 'error'
          raise(ExchangeError, self.id + ' ' + self.json(response))
        end
      end
      return response
    end
  end
end
