# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Buda < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'buda',
        'name' => 'Buda',
        'countries' => ['AR', 'CL', 'CO', 'PE'],
        'rateLimit' => 1000,
        'version' => 'v2',
        'has' => {
          'CORS' => false,
          'createDepositAddress' => true,
          'fetchClosedOrders' => true,
          'fetchCurrencies' => true,
          'fetchDepositAddress' => true,
          'fetchDeposits' => true,
          'fetchFundingFees' => true,
          'fetchMyTrades' => false,
          'fetchOHLCV' => true,
          'fetchOpenOrders' => true,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchTrades' => true,
          'fetchWithdrawals' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/47380619-8a029200-d706-11e8-91e0-8a391fe48de3.jpg',
          'api' => 'https://www.buda.com/api',
          'www' => 'https://www.buda.com',
          'doc' => 'https://api.buda.com',
          'fees' => 'https://www.buda.com/comisiones'
        },
        'api' => {
          'public' => {
            'get' => [
              'pairs',
              'markets',
              'currencies',
              'markets/{market}',
              'markets/{market}/ticker',
              'markets/{market}/volume',
              'markets/{market}/order_book',
              'markets/{market}/trades',
              'currencies/{currency}/fees/deposit',
              'currencies/{currency}/fees/withdrawal',
              'tv/history'
            ],
            'post' => [
              'markets/{market}/quotations'
            ]
          },
          'private' => {
            'get' => [
              'balances',
              'balances/{currency}',
              'currencies/{currency}/balances',
              'orders',
              'orders/{id}',
              'markets/{market}/orders',
              'deposits',
              'currencies/{currency}/deposits',
              'withdrawals',
              'currencies/{currency}/withdrawals',
              'currencies/{currency}/receive_addresses',
              'currencies/{currency}/receive_addresses/{id}'
            ],
            'post' => [
              'markets/{market}/orders',
              'currencies/{currency}/deposits',
              'currencies/{currency}/withdrawals',
              'currencies/{currency}/simulated_withdrawals',
              'currencies/{currency}/receive_addresses'
            ],
            'put' => [
              'orders/{id}'
            ]
          }
        },
        'timeframes' => {
          '1m' => '1',
          '5m' => '5',
          '30m' => '30',
          '1h' => '60',
          '2h' => '120',
          '1d' => 'D',
          '1w' => 'W'
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'percentage' => true,
            'taker' => 0.008,  # 0.8%
            'maker' => 0.004,  # 0.4%
            'tiers' => {
              'taker' => [
                [0, 0.008],  # 0.8%
                [2000, 0.007],  # 0.7%
                [20000, 0.006],  # 0.6%
                [100000, 0.005],  # 0.5%
                [500000, 0.004],  # 0.4%
                [2500000, 0.003],  # 0.3%
                [12500000, 0.002],  # 0.2%
              ],
              'maker' => [
                [0, 0.004],  # 0.4%
                [2000, 0.0035],  # 0.35%
                [20000, 0.003],  # 0.3%
                [100000, 0.0025],  # 0.25%
                [500000, 0.002],  # 0.2%
                [2500000, 0.0015],  # 0.15%
                [12500000, 0.001],  # 0.1%
              ]
            }
          }
        },
        'exceptions' => {
          'not_authorized' => AuthenticationError,  # { message => 'Invalid credentials', code => 'not_authorized' }
          'forbidden' => PermissionDenied,  # { message => 'You dont have access to self resource', code => 'forbidden' }
          'invalid_record' => ExchangeError,  # { message => 'Validation Failed', code => 'invalid_record', errors => [] }
          'not_found' => ExchangeError,  # { message => 'Not found', code => 'not_found' }
          'parameter_missing' => ExchangeError,  # { message => 'Parameter missing', code => 'parameter_missing' }
          'bad_parameter' => ExchangeError,  # { message => 'Bad Parameter format', code => 'bad_parameter' }
        }
      })
    end

    def fetch_currency_info(currency, currencies = nil)
      if !currencies
        response = self.publicGetCurrencies
        currencies = response['currencies']
      end
      for i in (0...currencies.length)
        currencyInfo = currencies[i]
        if currencyInfo['id'] == currency
          return currencyInfo
        end
      end
      return nil
    end

    def fetch_markets(params = {})
      marketsResponse = self.publicGetMarkets
      markets = marketsResponse['markets']
      currenciesResponse = self.publicGetCurrencies
      currencies = currenciesResponse['currencies']
      result = []
      for i in (0...markets.length)
        market = markets[i]
        id = market['id']
        baseId = market['base_currency']
        quoteId = market['quote_currency']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        baseInfo = self.fetch_currency_info(baseId, currencies)
        quoteInfo = self.fetch_currency_info(quoteId, currencies)
        symbol = base + '/' + quote
        precision = {
          'amount' => baseInfo['input_decimals'],
          'price' => quoteInfo['input_decimals']
        }
        limits = {
          'amount' => {
            'min' => parse_float(market['minimum_order_amount'][0]),
            'max' => nil
          },
          'price' => {
            'min' => 10**-precision['price'],
            'max' => nil
          }
        }
        limits['cost'] = {
          'min' => limits['amount']['min'] * limits['price']['min'],
          'max' => nil
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => true,
          'precision' => precision,
          'limits' => limits,
          'info' => market
        })
      end
      return result
    end

    def fetch_currencies(params = {})
      response = self.publicGetCurrencies
      currencies = response['currencies']
      result = {}
      for i in (0...currencies.length)
        currency = currencies[i]
        if !currency['managed']
          next
        end
        id = currency['id']
        code = self.common_currency_code(id)
        precision = currency['input_decimals']
        minimum = 10**-precision
        result[code] = {
          'id' => id,
          'code' => code,
          'info' => currency,
          'name' => nil,
          'active' => true,
          'fee' => nil,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => minimum,
              'max' => nil
            },
            'price' => {
              'min' => minimum,
              'max' => nil
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            },
            'deposit' => {
              'min' => parse_float(currency['deposit_minimum'][0]),
              'max' => nil
            },
            'withdraw' => {
              'min' => parse_float(currency['withdrawal_minimum'][0])
            }
          }
        }
      end
      return result
    end

    def fetch_funding_fees(codes = nil, params = {})
      #  by default it will try load withdrawal fees of all currencies(with separate requests)
      #  however if you define codes = ['ETH', 'BTC'] in args it will only load those
      self.load_markets
      withdrawFees = {}
      depositFees = {}
      info = {}
      if codes.nil?
        codes = self.currencies.keys
      end
      for i in (0...codes.length)
        code = codes[i]
        currency = self.currency(code)
        request = { 'currency' => currency['id'] }
        withdrawResponse = self.publicGetCurrenciesCurrencyFeesWithdrawal(request)
        depositResponse = self.publicGetCurrenciesCurrencyFeesDeposit(request)
        withdrawFees[code] = self.parse_funding_fee(withdrawResponse['fee'])
        depositFees[code] = self.parse_funding_fee(depositResponse['fee'])
        info[code] = {
          'withdraw' => withdrawResponse,
          'deposit' => depositResponse
        }
      end
      return {
        'withdraw' => withdrawFees,
        'deposit' => depositFees,
        'info' => info
      }
    end

    def parse_funding_fee(fee, type = nil)
      if type.nil?
        type = fee['name']
      end
      if type == 'withdrawal'
        type = 'withdraw'
      end
      return {
        'type' => type,
        'currency' => fee['base'][1],
        'rate' => fee['percent'],
        'cost' => parse_float(fee['base'][0])
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketsMarketTicker(self.shallow_extend({
        'market' => market['id']
      }, params))
      ticker = response['ticker']
      return self.parse_ticker(ticker, market)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      last = parse_float(ticker['last_price'][0])
      percentage = parse_float(ticker['price_variation_24h'])
      open = parse_float(self.price_to_precision(symbol, last / (percentage + 1)))
      change = last - open
      average = self.sum(last, open) / 2
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => parse_float(ticker['max_bid'][0]),
        'bidVolume' => nil,
        'ask' => parse_float(ticker['min_ask'][0]),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => open,
        'close' => last,
        'last' => last,
        'previousClose' => open,
        'change' => change,
        'percentage' => percentage * 100,
        'average' => average,
        'baseVolume' => parse_float(ticker['volume'][0]),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'market' => market['id']
      }
      # the since argument works backwards – returns trades up to the specified timestamp
      # therefore not implemented here
      # the method is still available for users to be able to traverse backwards in time
      # by using the timestamp from the first received trade upon each iteration
      if limit != nil
        request['limit'] = limit # 50 max
      end
      response = self.publicGetMarketsMarketTrades(self.shallow_extend(request, params))
      #
      #     { trades => {      market_id =>   "ETH-BTC",
      #                      timestamp =>    null,
      #                 last_timestamp =>   "1536901277302",
      #                        entries => [["1540077456791", "0.0063767", "0.03", "sell", 479842],
      #                                   ["1539916642772", "0.01888263", "0.03019563", "sell", 479438],
      #                                   ["1539834081787", "0.023718648", "0.031001", "sell", 479069],
      #                                   ...]
      #
      return self.parse_trades(response['trades']['entries'], market, since, limit)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #  ["1540077456791", "0.0063767", "0.03", "sell", 479842]
      #
      timestamp = nil
      side = nil
      type = nil
      price = nil
      amount = nil
      id = nil
      order = nil
      fee = nil
      symbol = nil
      cost = nil
      if market
        symbol = market['symbol']
      end
      if trade.is_a?(Array)
        timestamp = parse_int(trade[0])
        price = parse_float(trade[1])
        amount = parse_float(trade[2])
        cost = price * amount
        side = trade[3]
        id = trade[4].to_s
      end
      return {
        'id' => id,
        'order' => order,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketsMarketOrderBook(self.shallow_extend({
        'market' => market['id']
      }, params))
      orderBook = response['order_book']
      return self.parse_order_book(orderBook)
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      if since.nil?
        since = self.milliseconds - 86400000
      end
      request = {
        'symbol' => market['id'],
        'resolution' => self.timeframes[timeframe],
        'from' => since / 1000,
        'to' => self.seconds
      }
      response = self.publicGetTvHistory(self.shallow_extend(request, params))
      return self.parse_trading_view_ohlcv(response, market, timeframe, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetBalances
      result = { 'info' => response }
      balances = response['balances']
      for i in (0...balances.length)
        balance = balances[i]
        id = balance['id']
        currency = self.common_currency_code(id)
        total = parse_float(balance['amount'][0])
        free = parse_float(balance['available_amount'][0])
        account = {
          'free' => free,
          'used' => total - free,
          'total' => total
        }
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privateGetOrdersId(self.shallow_extend({
        'id' => parse_int(id)
      }, params))
      order = response['order']
      return self.parse_order(order)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      response = self.privateGetMarketsMarketOrders(self.shallow_extend({
        'market' => market['id'],
        'per' => limit
      }, params))
      orders = response['orders']
      return self.parse_orders(orders, market, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'state' => 'pending'
      }, params))
      return orders
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'state' => 'traded'
      }, params))
      return orders
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      side = (side == 'buy') ? 'Bid' : 'Ask'
      request = {
        'market' => self.market_id(symbol),
        'price_type' => type,
        'type' => side,
        'amount' => self.amount_to_precision(symbol, amount)
      }
      if type == 'limit'
        request['limit'] = self.price_to_precision(symbol, price)
      end
      response = self.privatePostMarketsMarketOrders(self.shallow_extend(request, params))
      order = response['order']
      return self.parse_order(order)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePutOrdersId(self.shallow_extend({
        'id' => parse_int(id),
        'state' => 'canceling'
      }, params))
      order = response['order']
      return self.parse_order(order)
    end

    def parse_order_status(status)
      statuses = {
        'traded' => 'closed',
        'received' => 'open',
        'canceling' => 'canceled'
      }
      return(statuses.include?(status)) ? statuses[status] : status
    end

    def parse_order(order, market = nil)
      id = order['id']
      timestamp = self.parse8601(self.safe_string(order, 'created_at'))
      symbol = nil
      if market.nil?
        marketId = order['market_id']
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      type = order['price_type']
      side = order['type'].downcase
      status = self.parse_order_status(self.safe_string(order, 'state'))
      amount = parse_float(order['original_amount'][0])
      remaining = parse_float(order['amount'][0])
      filled = parse_float(order['traded_amount'][0])
      cost = parse_float(order['total_exchanged'][0])
      price = order['limit']
      if price != nil
        price = parse_float(price[0])
      end
      if cost > 0 && filled > 0
        price = self.price_to_precision(symbol, cost / filled)
      end
      fee = {
        'cost' => parse_float(order['paid_fee'][0]),
        'currency' => order['paid_fee'][1]
      }
      return {
        'id' => id,
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => fee,
        'info' => order
      }
    end

    def is_fiat(code)
      fiats = {
        'ARS' => true,
        'CLP' => true,
        'COP' => true,
        'PEN' => true
      }
      return self.safe_value(fiats, code, false)
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      if self.is_fiat(code)
        raise(NotSupported, self.id + ' fetchDepositAddress for fiat ' + code + ' is not supported')
      end
      response = self.privateGetCurrenciesCurrencyReceiveAddresses(self.shallow_extend({
        'currency' => currency['id']
      }, params))
      receiveAddresses = response['receive_addresses']
      addressPool = []
      for i in (1...receiveAddresses.length)
        receiveAddress = receiveAddresses[i]
        if receiveAddress['ready']
          address = receiveAddress['address']
          self.check_address(address)
          addressPool.push(address)
        end
      end
      addressPoolLength = addressPool.length
      if addressPoolLength < 1
        raise(AddressPending, self.id + ' => there are no addresses ready for receiving ' + code + ', retry again later)')
      end
      address = addressPool[0]
      return {
        'currency' => code,
        'address' => address,
        'tag' => nil,
        'info' => receiveAddresses
      }
    end

    def create_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      if self.is_fiat(code)
        raise(NotSupported, self.id + ' => fiat fetchDepositAddress for ' + code + ' is not supported')
      end
      response = self.privatePostCurrenciesCurrencyReceiveAddresses(self.shallow_extend({
        'currency' => currency['id']
      }, params))
      address = self.safe_string(response['receive_address'], 'address')  # the creation is async and returns a null address, returns only the id
      return {
        'currency' => code,
        'address' => address,
        'tag' => nil,
        'info' => response
      }
    end

    def parse_transaction_status(status)
      statuses = {
        'rejected' => 'failed',
        'confirmed' => 'ok',
        'anulled' => 'canceled',
        'retained' => 'canceled',
        'pending_confirmation' => 'pending'
      }
      return(statuses.include?(status)) ? statuses[status] : status
    end

    def parse_transaction(transaction, currency = nil)
      id = self.safe_string(transaction, 'id')
      timestamp = self.parse8601(self.safe_string(transaction, 'created_at'))
      code = nil
      currencyId = nil
      if currency.nil?
        currencyId = self.safe_string(transaction, 'currency')
        currency = self.safe_value(self.currencies_by_id, currencyId)
      end
      if currency != nil
        code = currency['code']
      else
        code = self.common_currency_code(currencyId)
      end
      amount = parse_float(transaction['amount'][0])
      fee = parse_float(transaction['fee'][0])
      feeCurrency = transaction['fee'][1]
      status = self.parse_transaction_status(self.safe_string(transaction, 'state'))
      type = (transaction.include?('deposit_data')) ? 'deposit' : 'withdrawal'
      data = self.safe_value(transaction, type + '_data', {})
      address = self.safe_value(data, 'target_address')
      txid = self.safe_string(data, 'tx_hash')
      updated = self.parse8601(self.safe_string(data, 'updated_at'))
      return {
        'info' => transaction,
        'id' => id,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => address,
        'type' => type,
        'amount' => amount,
        'currency' => code,
        'status' => status,
        'updated' => updated,
        'fee' => {
          'cost' => fee,
          'rate' => feeCurrency
        }
      }
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if code.nil?
        raise(ExchangeError, self.id + ' => fetchDeposits requires a currency code argument')
      end
      currency = self.currency(code)
      response = self.privateGetCurrenciesCurrencyDeposits(self.shallow_extend({
        'currency' => currency['id'],
        'per' => limit
      }, params))
      deposits = response['deposits']
      return self.parseTransactions(deposits, currency, since, limit)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      if code.nil?
        raise(ExchangeError, self.id + ' => fetchDeposits requires a currency code argument')
      end
      currency = self.currency(code)
      response = self.privateGetCurrenciesCurrencyWithdrawals(self.shallow_extend({
        'currency' => currency['id'],
        'per' => limit
      }, params))
      withdrawals = response['withdrawals']
      return self.parseTransactions(withdrawals, currency, since, limit)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostCurrenciesCurrencyWithdrawals(self.shallow_extend({
        'currency' => currency['id'],
        'amount' => amount,
        'withdrawal_data' => {
          'target_address' => address
        }
      }, params))
      withdrawal = response['withdrawal']
      return self.parse_transaction(withdrawal)
    end

    def nonce
      return self.microseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if query
        if method == 'GET'
          request += '?' + self.urlencode(query)
        else
          body = self.json(query)
        end
      end
      url = self.urls['api'] + '/' + self.version + '/' + request
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce.to_s
        components = [method, '/api/' + self.version + '/' + request]
        if body
          base64_body = Base64.encode64(self.encode(body))
          components.push(self.decode(base64_body))
        end
        components.push(nonce)
        message = components.join(' ')
        signature = self.hmac(self.encode(message), self.encode(self.secret), 'sha384')
        headers = {
          'X-SBTC-APIKEY' => self.apiKey,
          'X-SBTC-SIGNATURE' => signature,
          'X-SBTC-NONCE' => nonce,
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if !self.is_json_encoded_object(body)
        return # fallback to default error handler
      end
      if code >= 400
        errorCode = self.safe_string(response, 'code')
        message = self.safe_string(response, 'message', body)
        feedback = self.id + ' ' + message
        exceptions = self.exceptions
        if errorCode != nil
          if exceptions.include?(errorCode)
            raise(exceptions[errorCode], feedback)
          else
            raise(ExchangeError, feedback)
          end
        end
      end
    end
  end
end
