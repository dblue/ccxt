# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Exmo < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'exmo',
        'name' => 'EXMO',
        'countries' => ['ES', 'RU'], # Spain, Russia
        'rateLimit' => 350, # once every 350 ms ≈ 180 requests per minute ≈ 3 requests per second
        'version' => 'v1',
        'has' => {
          'CORS' => false,
          'fetchClosedOrders' => 'emulated',
          'fetchDepositAddress' => true,
          'fetchOpenOrders' => true,
          'fetchOrder' => 'emulated',
          'fetchOrders' => 'emulated',
          'fetchOrderTrades' => true,
          'fetchOrderBooks' => true,
          'fetchMyTrades' => true,
          'fetchTickers' => true,
          'withdraw' => true,
          'fetchTradingFee' => true,
          'fetchTradingFees' => true,
          'fetchFundingFees' => true,
          'fetchCurrencies' => true,
          'fetchTransactions' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg',
          'api' => {
            'public' => 'https://api.exmo.com',
            'private' => 'https://api.exmo.com',
            'web' => 'https://exmo.me'
          },
          'www' => 'https://exmo.me',
          'referral' => 'https://exmo.me/?ref=131685',
          'doc' => [
            'https://exmo.me/en/api_doc?ref=131685',
            'https://github.com/exmo-dev/exmo_api_lib/tree/master/nodejs'
          ],
          'fees' => 'https://exmo.com/en/docs/fees'
        },
        'api' => {
          'web' => {
            'get' => [
              'ctrl/feesAndLimits',
              'en/docs/fees'
            ]
          },
          'public' => {
            'get' => [
              'currency',
              'order_book',
              'pair_settings',
              'ticker',
              'trades'
            ]
          },
          'private' => {
            'post' => [
              'user_info',
              'order_create',
              'order_cancel',
              'user_open_orders',
              'user_trades',
              'user_cancelled_orders',
              'order_trades',
              'required_amount',
              'deposit_address',
              'withdraw_crypt',
              'withdraw_get_txid',
              'excode_create',
              'excode_load',
              'wallet_history'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.2 / 100,
            'taker' => 0.2 / 100
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false, # fixed funding fees for crypto, see fetchFundingFees below
          }
        },
        'options' => {
          'useWebapiForFetchingFees' => false, # TODO => figure why Exmo bans us when we try to fetch their web urls
          'feesAndLimits' => {
            'success' => 1,
            'ctlr' => 'feesAndLimits',
            'error' => '',
            'data' => {
              'limits' => [
                { 'pair' => 'BTC/USD', 'min_q' => '0.001', 'max_q' => '1000', 'min_p' => '1', 'max_p' => '30000', 'min_a' => '1', 'max_a' => '500000' },
                { 'pair' => 'BTC/EUR', 'min_q' => '0.001', 'max_q' => '1000', 'min_p' => '1', 'max_p' => '30000', 'min_a' => '1', 'max_a' => '500000' },
                { 'pair' => 'BTC/RUB', 'min_q' => '0.001', 'max_q' => '1000', 'min_p' => '1', 'max_p' => '2000000', 'min_a' => '10', 'max_a' => '50000000' },
                { 'pair' => 'BTC/UAH', 'min_q' => '0.001', 'max_q' => '1000', 'min_p' => '1', 'max_p' => '1500000', 'min_a' => '10', 'max_a' => '15000000' },
                { 'pair' => 'BTC/PLN', 'min_q' => '0.001', 'max_q' => '1000', 'min_p' => '0.001', 'max_p' => '90000', 'min_a' => '1', 'max_a' => '2000000' },
                { 'pair' => 'BTC/TRY', 'min_q' => '0.001', 'max_q' => '1000', 'min_p' => '1', 'max_p' => '800000', 'min_a' => '40', 'max_a' => '6000000' },
                { 'pair' => 'ETH/TRY', 'min_q' => '0.01', 'max_q' => '5000', 'min_p' => '0.1', 'max_p' => '80000', 'min_a' => '10', 'max_a' => '6000000' },
                { 'pair' => 'XRP/TRY', 'min_q' => '1', 'max_q' => '100000', 'min_p' => '0.0001', 'max_p' => '1000', 'min_a' => '0.01', 'max_a' => '6000000' },
                { 'pair' => 'XLM/TRY', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.00001', 'max_p' => '100000', 'min_a' => '0.1', 'max_a' => '6000000' },
                { 'pair' => 'DAI/BTC', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.0000001', 'max_p' => '0.1', 'min_a' => '0.00001', 'max_a' => '100' },
                { 'pair' => 'DAI/ETH', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.000001', 'max_p' => '10', 'min_a' => '0.0001', 'max_a' => '5000' },
                { 'pair' => 'DAI/USD', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'DAI/RUB', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.01', 'max_p' => '100000', 'min_a' => '0.5', 'max_a' => '30000000' },
                { 'pair' => 'MKR/BTC', 'min_q' => '0.001', 'max_q' => '1000', 'min_p' => '0.0001', 'max_p' => '100', 'min_a' => '0.000001', 'max_a' => '100' },
                { 'pair' => 'MKR/DAI', 'min_q' => '0.001', 'max_q' => '1000', 'min_p' => '0.5', 'max_p' => '500000', 'min_a' => '0.005', 'max_a' => '500000' },
                { 'pair' => 'QTUM/BTC', 'min_q' => '0.1', 'max_q' => '200000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.0001', 'max_a' => '100' },
                { 'pair' => 'QTUM/ETH', 'min_q' => '0.1', 'max_q' => '200000', 'min_p' => '0.00000001', 'max_p' => '100', 'min_a' => '0.001', 'max_a' => '5000' },
                { 'pair' => 'QTUM/USD', 'min_q' => '0.1', 'max_q' => '200000', 'min_p' => '0.00000001', 'max_p' => '10000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'HB/BTC', 'min_q' => '10', 'max_q' => '100000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.000001', 'max_a' => '100' },
                { 'pair' => 'SMART/BTC', 'min_q' => '10', 'max_q' => '10000000', 'min_p' => '0.0000001', 'max_p' => '1', 'min_a' => '0.00001', 'max_a' => '100' },
                { 'pair' => 'SMART/USD', 'min_q' => '10', 'max_q' => '10000000', 'min_p' => '0.00001', 'max_p' => '1000', 'min_a' => '1', 'max_a' => '500000' },
                { 'pair' => 'SMART/EUR', 'min_q' => '10', 'max_q' => '10000000', 'min_p' => '0.00001', 'max_p' => '1000', 'min_a' => '1', 'max_a' => '500000' },
                { 'pair' => 'SMART/RUB', 'min_q' => '10', 'max_q' => '10000000', 'min_p' => '0.000001', 'max_p' => '100000', 'min_a' => '10', 'max_a' => '50000000' },
                { 'pair' => 'XEM/BTC', 'min_q' => '10', 'max_q' => '5000000', 'min_p' => '0.0000001', 'max_p' => '1', 'min_a' => '0.00015', 'max_a' => '100' },
                { 'pair' => 'XEM/USD', 'min_q' => '10', 'max_q' => '5000000', 'min_p' => '0.00001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'XEM/EUR', 'min_q' => '10', 'max_q' => '5000000', 'min_p' => '0.00001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'GUSD/BTC', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.0015', 'max_a' => '100' },
                { 'pair' => 'GUSD/USD', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.1', 'max_p' => '10', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'GUSD/RUB', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.01', 'max_p' => '1000', 'min_a' => '10', 'max_a' => '50000000' },
                { 'pair' => 'LSK/BTC', 'min_q' => '1', 'max_q' => '200000', 'min_p' => '0.0000001', 'max_p' => '1', 'min_a' => '0.0015', 'max_a' => '100' },
                { 'pair' => 'LSK/USD', 'min_q' => '1', 'max_q' => '200000', 'min_p' => '0.1', 'max_p' => '1000', 'min_a' => '1', 'max_a' => '500000' },
                { 'pair' => 'LSK/RUB', 'min_q' => '1', 'max_q' => '200000', 'min_p' => '0.001', 'max_p' => '100000', 'min_a' => '0.5', 'max_a' => '50000000' },
                { 'pair' => 'NEO/BTC', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'NEO/USD', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.01', 'max_p' => '50000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'NEO/RUB', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.001', 'max_p' => '1500000', 'min_a' => '50', 'max_a' => '50000000' },
                { 'pair' => 'ADA/BTC', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'ADA/USD', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.0001', 'max_p' => '1000', 'min_a' => '0.01', 'max_a' => '500000' },
                { 'pair' => 'ADA/ETH', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '10', 'min_a' => '0.001', 'max_a' => '5000' },
                { 'pair' => 'ZRX/BTC', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'ZRX/ETH', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '10', 'min_a' => '0.01', 'max_a' => '5000' },
                { 'pair' => 'GNT/BTC', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'GNT/ETH', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '10', 'min_a' => '0.01', 'max_a' => '5000' },
                { 'pair' => 'TRX/BTC', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'TRX/USD', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.0001', 'max_p' => '1000', 'min_a' => '0.01', 'max_a' => '500000' },
                { 'pair' => 'TRX/RUB', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.000001', 'max_p' => '100000', 'min_a' => '0.1', 'max_a' => '50000000' },
                { 'pair' => 'GAS/BTC', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'GAS/USD', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.01', 'max_p' => '50000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'INK/BTC', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'INK/ETH', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '10', 'min_a' => '0.001', 'max_a' => '5000' },
                { 'pair' => 'INK/USD', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00001', 'max_p' => '1000', 'min_a' => '0.01', 'max_a' => '500000' },
                { 'pair' => 'MNX/BTC', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'MNX/ETH', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '10', 'min_a' => '0.01', 'max_a' => '5000' },
                { 'pair' => 'MNX/USD', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.01', 'max_p' => '1000', 'min_a' => '0.5', 'max_a' => '500000' },
                { 'pair' => 'OMG/BTC', 'min_q' => '0.01', 'max_q' => '100000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'OMG/ETH', 'min_q' => '0.01', 'max_q' => '100000', 'min_p' => '0.00000001', 'max_p' => '10', 'min_a' => '0.01', 'max_a' => '5000' },
                { 'pair' => 'OMG/USD', 'min_q' => '0.01', 'max_q' => '100000', 'min_p' => '0.01', 'max_p' => '1000', 'min_a' => '0.5', 'max_a' => '500000' },
                { 'pair' => 'XLM/BTC', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'XLM/USD', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '0.01', 'max_a' => '500000' },
                { 'pair' => 'XLM/RUB', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.00001', 'max_p' => '100000', 'min_a' => '0.1', 'max_a' => '50000000' },
                { 'pair' => 'EOS/BTC', 'min_q' => '0.01', 'max_q' => '100000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'EOS/USD', 'min_q' => '0.01', 'max_q' => '100000', 'min_p' => '0.01', 'max_p' => '1000', 'min_a' => '0.5', 'max_a' => '500000' },
                { 'pair' => 'STQ/BTC', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.0001', 'max_a' => '100' },
                { 'pair' => 'STQ/USD', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.0001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'STQ/EUR', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.0001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'STQ/RUB', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.00001', 'max_p' => '50000', 'min_a' => '1', 'max_a' => '50000000' },
                { 'pair' => 'BTG/BTC', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'BTG/USD', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'HBZ/BTC', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.0001', 'max_a' => '100' },
                { 'pair' => 'HBZ/ETH', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.0001', 'max_a' => '5000' },
                { 'pair' => 'HBZ/USD', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.0001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'DXT/BTC', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.0001', 'max_a' => '100' },
                { 'pair' => 'DXT/USD', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.0001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'BTCZ/BTC', 'min_q' => '100', 'max_q' => '100000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.1', 'max_a' => '100' },
                { 'pair' => 'BCH/BTC', 'min_q' => '0.003', 'max_q' => '10000', 'min_p' => '0.00000001', 'max_p' => '5', 'min_a' => '0.0001', 'max_a' => '100' },
                { 'pair' => 'BCH/USD', 'min_q' => '0.003', 'max_q' => '10000', 'min_p' => '0.00000001', 'max_p' => '30000', 'min_a' => '0.0001', 'max_a' => '500000' },
                { 'pair' => 'BCH/RUB', 'min_q' => '0.003', 'max_q' => '10000', 'min_p' => '0.00000001', 'max_p' => '2000000', 'min_a' => '0.0001', 'max_a' => '50000000' },
                { 'pair' => 'BCH/ETH', 'min_q' => '0.003', 'max_q' => '10000', 'min_p' => '0.0000001', 'max_p' => '200', 'min_a' => '0.0001', 'max_a' => '5000' },
                { 'pair' => 'DASH/BTC', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'DASH/USD', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.01', 'max_p' => '10000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'DASH/RUB', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.01', 'max_p' => '100000', 'min_a' => '150', 'max_a' => '50000000' },
                { 'pair' => 'ETH/BTC', 'min_q' => '0.001', 'max_q' => '5000', 'min_p' => '0.00000001', 'max_p' => '10', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'ETH/LTC', 'min_q' => '0.01', 'max_q' => '5000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '100000' },
                { 'pair' => 'ETH/USD', 'min_q' => '0.01', 'max_q' => '5000', 'min_p' => '0.01', 'max_p' => '100000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'ETH/EUR', 'min_q' => '0.01', 'max_q' => '5000', 'min_p' => '0.001', 'max_p' => '10000', 'min_a' => '1', 'max_a' => '500000' },
                { 'pair' => 'ETH/RUB', 'min_q' => '0.01', 'max_q' => '5000', 'min_p' => '0.001', 'max_p' => '100000', 'min_a' => '1', 'max_a' => '50000000' },
                { 'pair' => 'ETH/UAH', 'min_q' => '0.01', 'max_q' => '5000', 'min_p' => '0.01', 'max_p' => '1000000', 'min_a' => '90', 'max_a' => '15000000' },
                { 'pair' => 'ETH/PLN', 'min_q' => '0.001', 'max_q' => '5000', 'min_p' => '0.001', 'max_p' => '8000', 'min_a' => '1', 'max_a' => '2000000' },
                { 'pair' => 'ETC/BTC', 'min_q' => '0.2', 'max_q' => '1000', 'min_p' => '0.0001', 'max_p' => '0.5', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'ETC/USD', 'min_q' => '0.2', 'max_q' => '1000', 'min_p' => '0.01', 'max_p' => '10000', 'min_a' => '0.01', 'max_a' => '500000' },
                { 'pair' => 'ETC/RUB', 'min_q' => '0.2', 'max_q' => '1000', 'min_p' => '0.01', 'max_p' => '10000', 'min_a' => '0.01', 'max_a' => '50000000' },
                { 'pair' => 'LTC/BTC', 'min_q' => '0.05', 'max_q' => '1000000', 'min_p' => '0.00000001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'LTC/USD', 'min_q' => '0.05', 'max_q' => '1000000', 'min_p' => '0.01', 'max_p' => '10000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'LTC/EUR', 'min_q' => '0.05', 'max_q' => '1000000', 'min_p' => '0.01', 'max_p' => '10000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'LTC/RUB', 'min_q' => '0.05', 'max_q' => '1000000', 'min_p' => '0.01', 'max_p' => '100000', 'min_a' => '150', 'max_a' => '50000000' },
                { 'pair' => 'ZEC/BTC', 'min_q' => '0.01', 'max_q' => '1000', 'min_p' => '0.001', 'max_p' => '10', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'ZEC/USD', 'min_q' => '0.01', 'max_q' => '1000', 'min_p' => '0.001', 'max_p' => '5000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'ZEC/EUR', 'min_q' => '0.01', 'max_q' => '1000', 'min_p' => '0.001', 'max_p' => '5000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'ZEC/RUB', 'min_q' => '0.01', 'max_q' => '1000', 'min_p' => '0.001', 'max_p' => '100000', 'min_a' => '0.1', 'max_a' => '50000000' },
                { 'pair' => 'XRP/BTC', 'min_q' => '1', 'max_q' => '100000', 'min_p' => '0.0000001', 'max_p' => '1', 'min_a' => '0.00001', 'max_a' => '100' },
                { 'pair' => 'XRP/USD', 'min_q' => '1', 'max_q' => '100000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '0.001', 'max_a' => '500000' },
                { 'pair' => 'XRP/RUB', 'min_q' => '1', 'max_q' => '100000', 'min_p' => '0.000001', 'max_p' => '1000', 'min_a' => '0.01', 'max_a' => '50000000' },
                { 'pair' => 'XMR/BTC', 'min_q' => '0.03', 'max_q' => '1000', 'min_p' => '0.001', 'max_p' => '1', 'min_a' => '0.001', 'max_a' => '100' },
                { 'pair' => 'XMR/USD', 'min_q' => '0.03', 'max_q' => '1000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'XMR/EUR', 'min_q' => '0.03', 'max_q' => '1000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'BTC/USDT', 'min_q' => '0.001', 'max_q' => '1000', 'min_p' => '0.01', 'max_p' => '30000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'ETH/USDT', 'min_q' => '0.01', 'max_q' => '5000', 'min_p' => '0.01', 'max_p' => '100000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'USDT/USD', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.5', 'max_p' => '10', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'USDT/RUB', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.01', 'max_p' => '1000', 'min_a' => '10', 'max_a' => '50000000' },
                { 'pair' => 'USD/RUB', 'min_q' => '1', 'max_q' => '500000', 'min_p' => '0.01', 'max_p' => '1000', 'min_a' => '10', 'max_a' => '50000000' },
                { 'pair' => 'DOGE/BTC', 'min_q' => '100', 'max_q' => '100000000', 'min_p' => '0.0000001', 'max_p' => '1', 'min_a' => '0.0001', 'max_a' => '100' },
                { 'pair' => 'WAVES/BTC', 'min_q' => '0.5', 'max_q' => '10000', 'min_p' => '0.0001', 'max_p' => '1', 'min_a' => '0.0001', 'max_a' => '100' },
                { 'pair' => 'WAVES/RUB', 'min_q' => '0.5', 'max_q' => '10000', 'min_p' => '1', 'max_p' => '10000', 'min_a' => '1', 'max_a' => '50000000' },
                { 'pair' => 'KICK/BTC', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.0000001', 'max_p' => '0.1', 'min_a' => '0.00001', 'max_a' => '100' },
                { 'pair' => 'KICK/ETH', 'min_q' => '100', 'max_q' => '10000000', 'min_p' => '0.000001', 'max_p' => '1', 'min_a' => '0.0001', 'max_a' => '5000' },
                { 'pair' => 'EOS/EUR', 'min_q' => '0.01', 'max_q' => '100000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '0.5', 'max_a' => '500000' },
                { 'pair' => 'BCH/EUR', 'min_q' => '0.003', 'max_q' => '100000', 'min_p' => '0.01', 'max_p' => '300000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'XRP/EUR', 'min_q' => '1', 'max_q' => '100000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '0.001', 'max_a' => '500000' },
                { 'pair' => 'XRP/UAH', 'min_q' => '1', 'max_q' => '100000', 'min_p' => '0.0001', 'max_p' => '1000', 'min_a' => '0.01', 'max_a' => '15000000' },
                { 'pair' => 'XEM/UAH', 'min_q' => '1', 'max_q' => '5000000', 'min_p' => '0.0001', 'max_p' => '30000', 'min_a' => '10', 'max_a' => '15000000' },
                { 'pair' => 'BCH/USDT', 'min_q' => '0.003', 'max_q' => '100000', 'min_p' => '0.01', 'max_p' => '5000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'DASH/USDT', 'min_q' => '0.01', 'max_q' => '100000', 'min_p' => '0.01', 'max_p' => '5000', 'min_a' => '3', 'max_a' => '500000' },
                { 'pair' => 'BCH/UAH', 'min_q' => '0.003', 'max_q' => '100000', 'min_p' => '0.1', 'max_p' => '30000', 'min_a' => '10', 'max_a' => '15000000' },
                { 'pair' => 'XRP/USDT', 'min_q' => '1', 'max_q' => '100000', 'min_p' => '0.001', 'max_p' => '1000', 'min_a' => '0.001', 'max_a' => '500000' },
                { 'pair' => 'USDT/UAH', 'min_q' => '0.01', 'max_q' => '100000', 'min_p' => '1', 'max_p' => '3000', 'min_a' => '2', 'max_a' => '15000000' },
                { 'pair' => 'USDT/EUR', 'min_q' => '0.01', 'max_q' => '100000', 'min_p' => '0.1', 'max_p' => '10', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'ZRX/USD', 'min_q' => '0.01', 'max_q' => '10000000', 'min_p' => '0.00001', 'max_p' => '1000', 'min_a' => '0.1', 'max_a' => '500000' },
                { 'pair' => 'BTG/ETH', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.0001', 'max_p' => '100', 'min_a' => '0.01', 'max_a' => '5000' },
                { 'pair' => 'WAVES/USD', 'min_q' => '0.5', 'max_q' => '10000', 'min_p' => '0.001', 'max_p' => '3500', 'min_a' => '0.5', 'max_a' => '500000' },
                { 'pair' => 'DOGE/USD', 'min_q' => '100', 'max_q' => '1000000000', 'min_p' => '0.0000001', 'max_p' => '1000', 'min_a' => '0.01', 'max_a' => '500000' },
                { 'pair' => 'XRP/ETH', 'min_q' => '1', 'max_q' => '100000', 'min_p' => '0.00000001', 'max_p' => '10', 'min_a' => '0.00001', 'max_a' => '5000' },
                { 'pair' => 'DASH/UAH', 'min_q' => '0.01', 'max_q' => '200000', 'min_p' => '0.01', 'max_p' => '200000', 'min_a' => '10', 'max_a' => '15000000' },
                { 'pair' => 'XMR/ETH', 'min_q' => '0.03', 'max_q' => '1000', 'min_p' => '0.00000001', 'max_p' => '100', 'min_a' => '0.001', 'max_a' => '5000' },
                { 'pair' => 'WAVES/ETH', 'min_q' => '0.5', 'max_q' => '10000', 'min_p' => '0.00001', 'max_p' => '30', 'min_a' => '0.0035', 'max_a' => '3500' }
              ],
              'fees' => [
                {
                  'group' => 'crypto',
                  'title' => 'Cryptocurrency',
                  'items' => [
                    { 'prov' => 'BTC', 'dep' => '0%', 'wd' => '0.0005 BTC' },
                    { 'prov' => 'LTC', 'dep' => '0%', 'wd' => '0.01 LTC' },
                    { 'prov' => 'DOGE', 'dep' => '0%', 'wd' => '1 Doge' },
                    { 'prov' => 'DASH', 'dep' => '0%', 'wd' => '0.01 DASH' },
                    { 'prov' => 'ETH', 'dep' => '0%', 'wd' => '0.01 ETH' },
                    { 'prov' => 'WAVES', 'dep' => '0%', 'wd' => '0.001 WAVES' },
                    { 'prov' => 'ZEC', 'dep' => '0%', 'wd' => '0.001 ZEC' },
                    { 'prov' => 'USDT', 'dep' => '5 USDT', 'wd' => '5 USDT' },
                    { 'prov' => 'XMR', 'dep' => '0%', 'wd' => '0.05 XMR' },
                    { 'prov' => 'XRP', 'dep' => '0%', 'wd' => '0.02 XRP' },
                    { 'prov' => 'KICK', 'dep' => '0 KICK', 'wd' => '50 KICK' },
                    { 'prov' => 'ETC', 'dep' => '0%', 'wd' => '0.01 ETC' },
                    { 'prov' => 'BCH', 'dep' => '0%', 'wd' => '0.001 BCH' },
                    { 'prov' => 'BTG', 'dep' => '0%', 'wd' => '0.001 BTG' },
                    { 'prov' => 'EOS', 'dep' => '', 'wd' => '0.05 EOS' },
                    { 'prov' => 'HBZ', 'dep' => '65 HBZ', 'wd' => '65 HBZ' },
                    { 'prov' => 'BTCZ', 'dep' => '0 %', 'wd' => '5 BTCZ' },
                    { 'prov' => 'DXT', 'dep' => '20 DXT', 'wd' => '20 DXT' },
                    { 'prov' => 'STQ', 'dep' => '100 STQ', 'wd' => '100 STQ' },
                    { 'prov' => 'XLM', 'dep' => '0%', 'wd' => '-' },
                    { 'prov' => 'MNX', 'dep' => '0%', 'wd' => '0.01 MNX' },
                    { 'prov' => 'OMG', 'dep' => '0.1 OMG', 'wd' => '0.5 OMG' },
                    { 'prov' => 'TRX', 'dep' => '0%', 'wd' => '1 TRX' },
                    { 'prov' => 'ADA', 'dep' => '0%', 'wd' => '1 ADA' },
                    { 'prov' => 'INK', 'dep' => '10 INK', 'wd' => '50 INK' },
                    { 'prov' => 'NEO', 'dep' => '0%', 'wd' => '0%' },
                    { 'prov' => 'GAS', 'dep' => '0%', 'wd' => '0%' },
                    { 'prov' => 'ZRX', 'dep' => '0%', 'wd' => '1 ZRX' },
                    { 'prov' => 'GNT', 'dep' => '0%', 'wd' => '1 GNT' },
                    { 'prov' => 'GUSD', 'dep' => '0%', 'wd' => '0.5 GUSD' },
                    { 'prov' => 'LSK', 'dep' => '0%', 'wd' => '0.1 LSK' },
                    { 'prov' => 'XEM', 'dep' => '0%', 'wd' => '5 XEM' },
                    { 'prov' => 'SMART', 'dep' => '0%', 'wd' => '0.5 SMART' },
                    { 'prov' => 'QTUM', 'dep' => '0%', 'wd' => '0.01 QTUM' },
                    { 'prov' => 'HB', 'dep' => '0%', 'wd' => '10 HB' },
                    { 'prov' => 'DAI', 'dep' => '0%', 'wd' => '1 DAI' },
                    { 'prov' => 'MKR', 'dep' => '0%', 'wd' => '0.005 MKR' }
                  ]
                },
                {
                  'group' => 'usd',
                  'title' => 'USD',
                  'items' => [
                    { 'prov' => 'Perfect Money', 'dep' => '-', 'wd' => '0.5%' },
                    { 'prov' => 'Neteller', 'dep' => '3.5% + 0.29 USD', 'wd' => '-' },
                    { 'prov' => 'AdvCash', 'dep' => '1.95%', 'wd' => '3.95%' },
                    { 'prov' => 'Payeer', 'dep' => '-', 'wd' => '0.45%' },
                    { 'prov' => 'Visa', 'dep' => '3.45%', 'wd' => '-' },
                    { 'prov' => 'Skrill', 'dep' => '2.95%', 'wd' => '2.45%' },
                    { 'prov' => 'Visa/MasterCard(Simplex)', 'dep' => '5%', 'wd' => '-' }
                  ]
                },
                {
                  'group' => 'eur',
                  'title' => 'EUR',
                  'items' => [
                    { 'prov' => 'Payeer', 'dep' => '-', 'wd' => '0.45%' },
                    { 'prov' => 'CryptoCapital', 'dep' => '-', 'wd' => '0.45%' },
                    { 'prov' => 'AdvCash', 'dep' => '1%', 'wd' => '-' },
                    { 'prov' => 'Perfect Money', 'dep' => '-', 'wd' => '2.95%' },
                    { 'prov' => 'Neteller', 'dep' => '3.5%+0.25 EUR', 'wd' => '2.95%' },
                    { 'prov' => 'Visa', 'dep' => '3.45%', 'wd' => '-' },
                    { 'prov' => 'Wire Transfer', 'dep' => '6.95 EUR', 'wd' => '-' },
                    { 'prov' => 'Skrill', 'dep' => '2.95% + 0.29 EUR', 'wd' => '-' },
                    { 'prov' => 'Rapid Transfer', 'dep' => '1.5% + 0.29 EUR', 'wd' => '-' },
                    { 'prov' => 'MisterTango SEPA', 'dep' => '5 EUR', 'wd' => '-' },
                    { 'prov' => 'SEPA', 'dep' => '6.95 EUR', 'wd' => '-' },
                    { 'prov' => 'Visa/MasterCard(Simplex)', 'dep' => '5%', 'wd' => '-' }
                  ]
                },
                {
                  'group' => 'rub',
                  'title' => 'RUB',
                  'items' => [
                    { 'prov' => 'AdvCash', 'dep' => '0.95%', 'wd' => '2.95%' },
                    { 'prov' => 'Payeer', 'dep' => '1.95%', 'wd' => '-' },
                    { 'prov' => 'Qiwi', 'dep' => '1.95%', 'wd' => '3.45%' },
                    { 'prov' => 'Visa/MasterCard', 'dep' => '4%', 'wd' => '-' },
                    { 'prov' => 'Yandex Money', 'dep' => '3.45%', 'wd' => '3.95%' },
                    { 'prov' => 'Visa/Mastercard', 'dep' => '-', 'wd' => '4.45% + 50 RUB' }
                  ]
                },
                {
                  'group' => 'pln',
                  'title' => 'PLN',
                  'items' => [
                    { 'prov' => 'Neteller', 'dep' => '3.5% + 4 PLN', 'wd' => '-' },
                    { 'prov' => 'Rapid Transfer', 'dep' => '1.5% + 1.21 PLN', 'wd' => '-' },
                    { 'prov' => 'CryptoCapital', 'dep' => '-', 'wd' => '0.45%' },
                    { 'prov' => 'Skrill', 'dep' => '3.5% + 1.21 PLN', 'wd' => '1.95%' },
                    { 'prov' => 'Visa/MasterCard(Simplex)', 'dep' => '5%', 'wd' => '-' }
                  ]
                },
                {
                  'group' => 'try',
                  'title' => 'TRY',
                  'items' => [
                    { 'prov' => 'QR ile yatırma', 'dep' => '5.95%', 'wd' => '-' },
                    { 'prov' => 'Visa', 'dep' => '0%', 'wd' => '-' },
                    { 'prov' => 'Skrill', 'dep' => '2.95% + 3 TRY', 'wd' => '1.45%' }
                  ]
                },
                {
                  'group' => 'uah',
                  'title' => 'UAH',
                  'items' => [
                    { 'prov' => 'Terminal', 'dep' => '2.6%', 'wd' => '-' },
                    { 'prov' => 'AdvCash', 'dep' => '0.45%', 'wd' => '3.45%' },
                    { 'prov' => 'Visa/MasterCard', 'dep' => '2.6%', 'wd' => '3.95%' },
                    { 'prov' => 'Enfins', 'dep' => '0%', 'wd' => '-' }
                  ]
                }
              ]
            }
          }
        },
        'exceptions' => {
          '40005' => AuthenticationError, # Authorization error, incorrect signature
          '40009' => InvalidNonce, #
          '40015' => ExchangeError, # API function do not exist
          '40016' => ExchangeNotAvailable, # Maintenance work in progress
          '40017' => AuthenticationError, # Wrong API Key
          '50052' => InsufficientFunds,
          '50054' => InsufficientFunds,
          '50304' => OrderNotFound, # "Order was not found '123456789'"(fetching order trades for an order that does not have trades yet)
          '50173' => OrderNotFound, # "Order with id X was not found."(cancelling non-existent, closed and cancelled order)
          '50319' => InvalidOrder, # Price by order is less than permissible minimum for self pair
          '50321' => InvalidOrder, # Price by order is more than permissible maximum for self pair
        }
      })
    end

    def fetch_trading_fees(params = {})
      if self.options['useWebapiForFetchingFees']
        response = self.webGetEnDocsFees(params)
        parts = response.split('<td class="th_fees_2" colspan="2">')
        numParts = parts.length
        if numParts != 2
          raise(ExchangeError, self.id + ' fetchTradingFees format has changed')
        end
        rest = parts[1]
        parts = rest.split('</td>')
        numParts = parts.length
        if numParts < 2
          raise(ExchangeError, self.id + ' fetchTradingFees format has changed')
        end
        fee = parse_float(parts[0].gsub('%', '')) * 0.01
        taker = fee
        maker = fee
        return {
          # 'info' => response,
          'maker' => maker,
          'taker' => taker
        }
      else
        return {
          'maker' => self.fees['trading']['maker'],
          'taker' => self.fees['trading']['taker']
        }
      end
    end

    def parse_fixed_float_value(input)
      if (input.nil?) || (input == '-')
        return nil
      end
      isPercentage = (input.include?('%'))
      parts = input.split(' ')
      value = parts[0].gsub('%', '')
      result = parse_float(value)
      if (result > 0) && isPercentage
        raise(ExchangeError, self.id + ' parseFixedFloatValue detected an unsupported non-zero percentage-based fee ' + input)
      end
      return result
    end

    def fetch_funding_fees(params = {})
      response = nil
      if self.options['useWebapiForFetchingFees']
        response = self.webGetCtrlFeesAndLimits(params)
      else
        response = self.options['feesAndLimits']
      end
      # the code below assumes all non-zero crypto fees are fixed(for now)
      withdraw = {}
      deposit = {}
      groups = self.safe_value(response['data'], 'fees')
      groupsByGroup = self.index_by(groups, 'group')
      items = groupsByGroup['crypto']['items']
      for i in (0...items.length)
        item = items[i]
        code = self.common_currency_code(self.safe_string(item, 'prov'))
        withdrawalFee = self.safe_string(item, 'wd')
        depositFee = self.safe_string(item, 'dep')
        if withdrawalFee != nil
          if withdrawalFee.length > 0
            withdraw[code] = self.parse_fixed_float_value(withdrawalFee)
          end
        end
        if depositFee != nil
          if depositFee.length > 0
            deposit[code] = self.parse_fixed_float_value(depositFee)
          end
        end
      end
      # sets fiat fees to nil
      fiatGroups = self.to_array(self.omit(groupsByGroup, 'crypto'))
      for i in (0...fiatGroups.length)
        code = self.common_currency_code(self.safe_string(fiatGroups[i], 'title'))
        withdraw[code] = nil
        deposit[code] = nil
      end
      result = {
        'info' => response,
        'withdraw' => withdraw,
        'deposit' => deposit
      }
      # cache them for later use
      self.options['fundingFees'] = result
      return result
    end

    def fetch_currencies(params = {})
      fees = self.fetch_funding_fees(params)
      # todo redesign the 'fee' property in currencies
      ids = fees['withdraw'].keys
      limitsByMarketId = self.index_by(fees['info']['data']['limits'], 'pair')
      marketIds = limitsByMarketId.keys
      minAmounts = {}
      minPrices = {}
      minCosts = {}
      maxAmounts = {}
      maxPrices = {}
      maxCosts = {}
      for i in (0...marketIds.length)
        marketId = marketIds[i]
        limit = limitsByMarketId[marketId]
        baseId, quoteId = marketId.split('/')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        maxAmount = self.safe_float(limit, 'max_q')
        maxPrice = self.safe_float(limit, 'max_p')
        maxCost = self.safe_float(limit, 'max_a')
        minAmount = self.safe_float(limit, 'min_q')
        minPrice = self.safe_float(limit, 'min_p')
        minCost = self.safe_float(limit, 'min_a')
        minAmounts[base] = minimum_wrapper(self.safe_float(minAmounts, base, minAmount), minAmount)
        maxAmounts[base] = maximum_wrapper(self.safe_float(maxAmounts, base, maxAmount), maxAmount)
        minPrices[quote] = minimum_wrapper(self.safe_float(minPrices, quote, minPrice), minPrice)
        minCosts[quote] = minimum_wrapper(self.safe_float(minCosts, quote, minCost), minCost)
        maxPrices[quote] = maximum_wrapper(self.safe_float(maxPrices, quote, maxPrice), maxPrice)
        maxCosts[quote] = maximum_wrapper(self.safe_float(maxCosts, quote, maxCost), maxCost)
      end
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        code = self.common_currency_code(id)
        fee = self.safe_value(fees['withdraw'], code)
        active = true
        result[code] = {
          'id' => id,
          'code' => code,
          'name' => code,
          'active' => active,
          'fee' => fee,
          'precision' => 8,
          'limits' => {
            'amount' => {
              'min' => self.safe_float(minAmounts, code),
              'max' => self.safe_float(maxAmounts, code)
            },
            'price' => {
              'min' => self.safe_float(minPrices, code),
              'max' => self.safe_float(maxPrices, code)
            },
            'cost' => {
              'min' => self.safe_float(minCosts, code),
              'max' => self.safe_float(maxCosts, code)
            }
          },
          'info' => id
        }
      end
      return result
    end

    def fetch_markets(params = {})
      fees = self.fetch_trading_fees
      markets = self.publicGetPairSettings
      keys = markets.keys
      result = []
      for p in (0...keys.length)
        id = keys[p]
        market = markets[id]
        symbol = id.gsub('_', '/')
        base, quote = symbol.split('/')
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'active' => true,
          'taker' => fees['taker'],
          'maker' => fees['maker'],
          'limits' => {
            'amount' => {
              'min' => self.safe_float(market, 'min_quantity'),
              'max' => self.safe_float(market, 'max_quantity')
            },
            'price' => {
              'min' => self.safe_float(market, 'min_price'),
              'max' => self.safe_float(market, 'max_price')
            },
            'cost' => {
              'min' => self.safe_float(market, 'min_amount'),
              'max' => self.safe_float(market, 'max_amount')
            }
          },
          'precision' => {
            'amount' => 8,
            'price' => 8
          },
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostUserInfo(params)
      result = { 'info' => response }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        account = self.account
        if response['balances'].include?(currency)
          account['free'] = parse_float(response['balances'][currency])
        end
        if response['reserved'].include?(currency)
          account['used'] = parse_float(response['reserved'][currency])
        end
        account['total'] = self.sum(account['free'], account['used'])
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = self.shallow_extend({
        'pair' => market['id']
      }, params)
      if limit != nil
        request['limit'] = limit
      end
      response = self.publicGetOrderBook(request)
      result = response[market['id']]
      return self.parse_order_book(result, nil, 'bid', 'ask')
    end

    def fetch_order_books(symbols = nil, params = {})
      self.load_markets
      ids = nil
      if symbols.nil?
        ids = self.ids.join(',')
        # max URL length is 2083 symbols, including http schema, hostname, tld, etc...
        if ids.length > 2048
          numIds = self.ids.length
          raise(ExchangeError, self.id + ' has ' + numIds.to_s + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks')
        end
      else
        ids = self.market_ids(symbols)
        ids = ids.join(',')
      end
      response = self.publicGetOrderBook(self.shallow_extend({
        'pair' => ids
      }, params))
      result = {}
      ids = response.keys
      for i in (0...ids.length)
        id = ids[i]
        symbol = self.find_symbol(id)
        result[symbol] = self.parse_order_book(response[id], nil, 'bid', 'ask')
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = ticker['updated'] * 1000
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last_trade')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy_price'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell_price'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => self.safe_float(ticker, 'avg'),
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => self.safe_float(ticker, 'vol_curr'),
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetTicker(params)
      result = {}
      ids = response.keys
      for i in (0...ids.length)
        id = ids[i]
        market = self.markets_by_id[id]
        symbol = market['symbol']
        ticker = response[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      response = self.publicGetTicker(params)
      market = self.market(symbol)
      return self.parse_ticker(response[market['id']], market)
    end

    def parse_trade(trade, market = nil)
      timestamp = trade['date'] * 1000
      fee = nil
      symbol = nil
      id = self.safe_string(trade, 'trade_id')
      orderId = self.safe_string(trade, 'order_id')
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'quantity')
      cost = self.safe_float(trade, 'amount')
      side = self.safe_string(trade, 'type')
      type = nil
      if market != nil
        symbol = market['symbol']
        if market['taker'] != market['maker']
          raise(ExchangeError, self.id + ' parseTrade can not deduce proper fee costs, taker and maker fees now differ')
        end
        if (side == 'buy') && (amount != nil)
          fee = {
            'currency' => market['base'],
            'cost' => amount * market['taker'],
            'rate' => market['taker']
          }
        elsif (side == 'sell') && (cost != nil)
          fee = {
            'currency' => market['quote'],
            'cost' => cost * market['taker'],
            'rate' => market['taker']
          }
        end
      end
      return {
        'id' => id,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => orderId,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTrades(self.shallow_extend({
        'pair' => market['id']
      }, params))
      return self.parse_trades(response[market['id']], market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      # their docs does not mention it, but if you don't supply a symbol
      # their API will return an empty response as if you don't have any trades
      # therefore we make it required here as calling it without a symbol is useless
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'pair' => market['id']
      }
      if limit != nil
        request['limit'] = limit
      end
      response = self.privatePostUserTrades(self.shallow_extend(request, params))
      if market != nil
        response = response[market['id']]
      end
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      prefix = (type == 'market') ?(type + '_') : ''
      market = self.market(symbol)
      if (type == 'market') && (price.nil?)
        price = 0
      end
      request = {
        'pair' => market['id'],
        'quantity' => self.amount_to_precision(symbol, amount),
        'type' => prefix + side,
        'price' => self.price_to_precision(symbol, price)
      }
      response = self.privatePostOrderCreate(self.shallow_extend(request, params))
      id = self.safe_string(response, 'order_id')
      timestamp = self.milliseconds
      amount = parse_float(amount)
      price = parse_float(price)
      status = 'open'
      order = {
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => price * amount,
        'amount' => amount,
        'remaining' => amount,
        'filled' => 0.0,
        'fee' => nil,
        'trades' => nil
      }
      self.orders[id] = order
      return self.shallow_extend({ 'info' => response }, order)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePostOrderCancel({ 'order_id' => id })
      if self.orders.include?(id)
        self.orders[id]['status'] = 'canceled'
      end
      return response
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      begin
        response = self.privatePostOrderTrades({
          'order_id' => id.to_s
        })
        return self.parse_order(response)
      rescue BaseError => e
        if e.is_a?(OrderNotFound)
          if self.orders.include?(id)
            return self.orders[id]
          end
        end
      end
      raise(OrderNotFound, self.id + ' fetchOrder order id ' + id.to_s + ' not found in cache.')
    end

    def fetch_order_trades(id, symbol = nil, since = nil, limit = nil, params = {})
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      response = self.privatePostOrderTrades(self.shallow_extend({
        'order_id' => id.to_s
      }, params))
      trades = self.safe_value(response, 'trades')
      return self.parse_trades(trades, market, since, limit)
    end

    def update_cached_orders(openOrders, symbol)
      # update local cache with open orders
      for j in (0...openOrders.length)
        id = openOrders[j]['id']
        self.orders[id] = openOrders[j]
      end
      openOrdersIndexedById = self.index_by(openOrders, 'id')
      cachedOrderIds = self.orders.keys
      for k in (0...cachedOrderIds.length)
        # match each cached order to an order in the open orders array
        # possible reasons why a cached order may be missing in the open orders array:
        # - order was closed or canceled -> update cache
        # - symbol mismatch(e.g. cached BTC/USDT, fetched ETH/USDT) -> skip
        id = cachedOrderIds[k]
        order = self.orders[id]
        if openOrdersIndexedById.include?(!(id))
          # cached order is not in open orders array
          # if we fetched orders by symbol and it doesn't match the cached order -> won't update the cached order
          if symbol != nil && symbol != order['symbol']
            next
          end
          # order is cached but not present in the list of open orders -> mark the cached order as closed
          if order['status'] == 'open'
            order = self.shallow_extend(order, {
              'status' => 'closed', # likewise it might have been canceled externally(unnoticed by "us")
              'cost' => nil,
              'filled' => order['amount'],
              'remaining' => 0.0
            })
            if order['cost'].nil?
              if order['filled'] != nil
                order['cost'] = order['filled'] * order['price']
              end
            end
            self.orders[id] = order
          end
        end
      end
      return self.to_array(self.orders)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      response = self.privatePostUserOpenOrders(params)
      marketIds = response.keys
      orders = []
      for i in (0...marketIds.length)
        marketId = marketIds[i]
        market = nil
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
        parsedOrders = self.parse_orders(response[marketId], market)
        orders = self.array_concat(orders, parsedOrders)
      end
      self.update_cached_orders(orders, symbol)
      return self.filter_by_symbol_since_limit(self.to_array(self.orders), symbol, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.fetch_orders(symbol, since, limit, params)
      orders = self.filter_by(self.orders, 'status', 'open')
      return self.filter_by_symbol_since_limit(orders, symbol, since, limit)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.fetch_orders(symbol, since, limit, params)
      orders = self.filter_by(self.orders, 'status', 'closed')
      return self.filter_by_symbol_since_limit(orders, symbol, since, limit)
    end

    def parse_order(order, market = nil)
      id = self.safe_string(order, 'order_id')
      timestamp = self.safe_integer(order, 'created')
      if timestamp != nil
        timestamp *= 1000
      end
      symbol = nil
      side = self.safe_string(order, 'type')
      if market.nil?
        marketId = nil
        if order.include?('pair')
          marketId = order['pair']
        elsif order.include?(('in_currency')) && (order.include?('out_currency'))
          if side == 'buy'
            marketId = order['in_currency'] + '_' + order['out_currency']
          else
            marketId = order['out_currency'] + '_' + order['in_currency']
          end
        end
        if (marketId != nil) && (self.markets_by_id.include?(marketId))
          market = self.markets_by_id[marketId]
        end
      end
      amount = self.safe_float(order, 'quantity')
      if amount.nil?
        amountField = (side == 'buy') ? 'in_amount' : 'out_amount'
        amount = self.safe_float(order, amountField)
      end
      price = self.safe_float(order, 'price')
      cost = self.safe_float(order, 'amount')
      filled = 0.0
      trades = []
      transactions = self.safe_value(order, 'trades')
      feeCost = nil
      if transactions != nil
        if transactions.is_a?(Array)
          for i in (0...transactions.length)
            trade = self.parse_trade(transactions[i], market)
            if id.nil?
              id = trade['order']
            end
            if timestamp.nil?
              timestamp = trade['timestamp']
            end
            if timestamp > trade['timestamp']
              timestamp = trade['timestamp']
            end
            filled = self.sum(filled, trade['amount'])
            if feeCost.nil?
              feeCost = 0.0
            end
            feeCost = self.sum(feeCost, trade['fee']['cost'])
            if cost.nil?
              cost = 0.0
            end
            cost = self.sum(cost, trade['cost'])
            trades.push(trade)
          end
        end
      end
      remaining = nil
      if amount != nil
        remaining = amount - filled
      end
      status = self.safe_string(order, 'status') # in case we need to redefine it for canceled orders
      if filled >= amount
        status = 'closed'
      else
        status = 'open'
      end
      if market.nil?
        market = self.get_market_from_trades(trades)
      end
      feeCurrency = nil
      if market != nil
        symbol = market['symbol']
        feeCurrency = market['quote']
      end
      if cost.nil?
        if price != nil
          cost = price * filled
        end
      elsif price.nil?
        if filled > 0
          price = cost / filled
        end
      end
      fee = {
        'cost' => feeCost,
        'currency' => feeCurrency
      }
      return {
        'id' => id,
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => trades,
        'fee' => fee,
        'info' => order
      }
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      response = self.privatePostDepositAddress(params)
      depositAddress = self.safe_string(response, code)
      address = nil
      tag = nil
      if depositAddress
        addressAndTag = depositAddress.split(',')
        address = addressAndTag[0]
        numParts = addressAndTag.length
        if numParts > 1
          tag = addressAndTag[1]
        end
      end
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def get_market_from_trades(trades)
      tradesBySymbol = self.index_by(trades, 'pair')
      symbols = tradesBySymbol.keys
      numSymbols = symbols.length
      if numSymbols == 1
        return self.markets[symbols[0]]
      end
      return nil
    end

    def calculate_fee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {})
      market = self.markets[symbol]
      rate = market[takerOrMaker]
      cost = parse_float(self.cost_to_precision(symbol, amount * rate))
      key = 'quote'
      if side == 'sell'
        cost *= price
      else
        key = 'base'
      end
      return {
        'type' => takerOrMaker,
        'currency' => market[key],
        'rate' => rate,
        'cost' => parse_float(self.fee_to_precision(symbol, cost))
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'amount' => amount,
        'currency' => currency['id'],
        'address' => address
      }
      if tag != nil
        request['invoice'] = tag
      end
      result = self.privatePostWithdrawCrypt(self.shallow_extend(request, params))
      return {
        'info' => result,
        'id' => result['task_id']
      }
    end

    def parse_transaction_status(status)
      statuses = {
        'transferred' => 'ok',
        'paid' => 'ok',
        'pending' => 'pending',
        'processing' => 'pending'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchTransactions
      #
      #          {
      #            "dt" => 1461841192,
      #            "type" => "deposit",
      #            "curr" => "RUB",
      #            "status" => "processing",
      #            "provider" => "Qiwi(LA) [12345]",
      #            "amount" => "1",
      #            "account" => "",
      #            "txid" => "ec46f784ad976fd7f7539089d1a129fe46...",
      #          }
      #
      timestamp = self.safe_float(transaction, 'dt')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      amount = self.safe_float(transaction, 'amount')
      if amount != nil
        amount = amount.abs
      end
      status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
      txid = self.safe_string(transaction, 'txid')
      type = self.safe_string(transaction, 'type')
      code = self.safe_string(transaction, 'curr')
      if currency.nil?
        currency = self.safe_value(self.currencies_by_id, code)
      end
      if currency != nil
        code = currency['code']
      else
        code = self.common_currency_code(code)
      end
      address = self.safe_string(transaction, 'account')
      if address != nil
        parts = address.split(':')
        numParts = parts.length
        if numParts == 2
          address = parts[1].gsub(' ', '')
        end
      end
      fee = nil
      # fixed funding fees only(for now)
      if !self.fees['funding']['percentage']
        key = (type == 'withdrawal') ? 'withdraw' : 'deposit'
        feeCost = self.safe_float(self.options['fundingFees'][key], code)
        # users don't pay for cashbacks, no fees for that
        provider = self.safe_string(transaction, 'provider')
        if provider == 'cashback'
          feeCost = 0
        end
        if feeCost != nil
          # withdrawal amount includes the fee
          if type == 'withdrawal'
            amount = amount - feeCost
          end
          fee = {
            'cost' => feeCost,
            'currency' => code,
            'rate' => nil
          }
        end
      end
      return {
        'info' => transaction,
        'id' => nil,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => nil, # refix it properly
        'status' => status,
        'type' => type,
        'updated' => nil,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => fee
      }
    end

    def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      if since != nil
        request['date'] = parse_int(since / 1000)
      end
      currency = nil
      if code != nil
        currency = self.currency(code)
      end
      response = self.privatePostWalletHistory(self.shallow_extend(request, params))
      #
      #     {
      #       "result" => true,
      #       "error" => "",
      #       "begin" => "1493942400",
      #       "end" => "1494028800",
      #       "history" => [
      #          {
      #            "dt" => 1461841192,
      #            "type" => "deposit",
      #            "curr" => "RUB",
      #            "status" => "processing",
      #            "provider" => "Qiwi(LA) [12345]",
      #            "amount" => "1",
      #            "account" => "",
      #            "txid" => "ec46f784ad976fd7f7539089d1a129fe46...",
      #          },
      #          {
      #            "dt" => 1463414785,
      #            "type" => "withdrawal",
      #            "curr" => "USD",
      #            "status" => "paid",
      #            "provider" => "EXCODE",
      #            "amount" => "-1",
      #            "account" => "EX-CODE_19371_USDda...",
      #            "txid" => "",
      #          },
      #       ],
      #     }
      #
      return self.parseTransactions(response['history'], currency, since, limit)
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/'
      if api != 'web'
        url += self.version + '/'
      end
      url += path
      if (api == 'public') || (api == 'web')
        if params
          url += '?' + self.urlencode(params)
        end
      elsif api == 'private'
        self.check_required_credentials
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({ 'nonce' => nonce }, params))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Key' => self.apiKey,
          'Sign' => self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def nonce
      return self.milliseconds
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if response.nil?
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        if response.include?('result')
          #
          #     {"result":false,"error":"Error 50052 => Insufficient funds"}
          #
          success = self.safe_value(response, 'result', false)
          if success.is_a?(String)
            if (success == 'true') || (success == '1')
              success = true
            else
              success = false
            end
          end
          if !success
            code = nil
            message = self.safe_string(response, 'error')
            errorParts = message.split(':')
            numParts = errorParts.length
            if numParts > 1
              errorSubParts = errorParts[0].split(' ')
              numSubParts = errorSubParts.length
              code = (numSubParts > 1) ? errorSubParts[1] : errorSubParts[0]
            end
            feedback = self.id + ' ' + self.json(response)
            exceptions = self.exceptions
            if exceptions.include?(code)
              raise(exceptions[code], feedback)
            else
              raise(ExchangeError, feedback)
            end
          end
        end
      end
    end
  end
end
