# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bxinth < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bxinth',
        'name' => 'BX.in.th',
        'countries' => ['TH'], # Thailand
        'rateLimit' => 1500,
        'has' => {
          'CORS' => false,
          'fetchTickers' => true,
          'fetchOpenOrders' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766412-567b1eb4-5ed7-11e7-94a8-ff6a3884f6c5.jpg',
          'api' => 'https://bx.in.th/api',
          'www' => 'https://bx.in.th',
          'doc' => 'https://bx.in.th/info/api'
        },
        'api' => {
          'public' => {
            'get' => [
              '', # ticker
              'options',
              'optionbook',
              'orderbook',
              'pairing',
              'trade',
              'tradehistory'
            ]
          },
          'private' => {
            'post' => [
              'balance',
              'biller',
              'billgroup',
              'billpay',
              'cancel',
              'deposit',
              'getorders',
              'history',
              'option-issue',
              'option-bid',
              'option-sell',
              'option-myissue',
              'option-mybid',
              'option-myoptions',
              'option-exercise',
              'option-cancel',
              'option-history',
              'order',
              'withdrawal',
              'withdrawal-history'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'taker' => 0.25 / 100,
            'maker' => 0.25 / 100
          }
        },
        'commonCurrencies' => {
          'DAS' => 'DASH',
          'DOG' => 'DOGE'
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetPairing
      keys = markets.keys
      result = []
      for p in (0...keys.length)
        market = markets[keys[p]]
        id = market['pairing_id'].to_s
        baseId = market['secondary_currency']
        quoteId = market['primary_currency']
        active = market['active']
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostBalance
      balance = response['balance']
      result = { 'info' => balance }
      currencies = balance.keys
      for c in (0...currencies.length)
        currency = currencies[c]
        code = self.common_currency_code(currency)
        account = {
          'free' => parse_float(balance[currency]['available']),
          'used' => 0.0,
          'total' => parse_float(balance[currency]['total'])
        }
        account['used'] = account['total'] - account['free']
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetOrderbook(self.shallow_extend({
        'pairing' => self.market_id(symbol)
      }, params))
      return self.parse_order_book(orderbook)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last_price')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => parse_float(ticker['orderbook']['bids']['highbid']),
        'bidVolume' => nil,
        'ask' => parse_float(ticker['orderbook']['asks']['highbid']),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => self.safe_float(ticker, 'change'),
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'volume_24hours'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGet(params)
      result = {}
      ids = tickers.keys
      for i in (0...ids.length)
        id = ids[i]
        ticker = tickers[id]
        market = self.markets_by_id[id]
        symbol = market['symbol']
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      tickers = self.publicGet(self.shallow_extend({
        'pairing' => market['id']
      }, params))
      id = market['id'].to_s
      ticker = tickers[id]
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      timestamp = self.parse8601(trade['trade_date'] + '+07:00') # Thailand UTC+7 offset
      return {
        'id' => trade['trade_id'],
        'info' => trade,
        'order' => trade['order_id'],
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => trade['trade_type'],
        'price' => self.safe_float(trade, 'rate'),
        'amount' => self.safe_float(trade, 'amount')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTrade(self.shallow_extend({
        'pairing' => market['id']
      }, params))
      return self.parse_trades(response['trades'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      response = self.privatePostOrder(self.shallow_extend({
        'pairing' => self.market_id(symbol),
        'type' => side,
        'amount' => amount,
        'rate' => price
      }, params))
      return {
        'info' => response,
        'id' => response['order_id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      pairing = nil # TODO fixme
      return self.privatePostCancel({
        'order_id' => id,
        'pairing' => pairing
      })
    end

    def parse_order(order, market = nil)
      side = self.safe_string(order, 'order_type')
      symbol = nil
      if market.nil?
        marketId = self.safe_string(order, 'pairing_id')
        if marketId != nil
          if self.markets_by_id.include?(marketId)
            market = self.markets_by_id[marketId]
          end
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.parse8601(order['date'])
      price = self.safe_float(order, 'rate')
      amount = self.safe_float(order, 'amount')
      return {
        'info' => order,
        'id' => order['order_id'],
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'amount' => amount
      }
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['pairing'] = market['id']
      end
      response = self.privatePostGetorders(self.shallow_extend(request, params))
      orders = self.parse_orders(response['orders'], market, since, limit)
      return self.filter_by_symbol(orders, symbol)
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/'
      if path
        url += path + '/'
      end
      if params
        url += '?' + self.urlencode(params)
      end
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce
        auth = self.apiKey + nonce.to_s + self.secret
        signature = self.hash(self.encode(auth), 'sha256')
        body = self.urlencode(self.shallow_extend({
          'key' => self.apiKey,
          'nonce' => nonce,
          'signature' => signature,
          # twofa => self.twofa
        }, params))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if api == 'public'
        return response
      end
      if response.include?('success')
        if response['success']
          return response
        end
      end
      raise(ExchangeError, self.id + ' ' + self.json(response))
    end
  end
end
