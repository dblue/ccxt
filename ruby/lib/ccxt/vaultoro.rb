# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Vaultoro < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'vaultoro',
        'name' => 'Vaultoro',
        'countries' => ['CH'],
        'rateLimit' => 1000,
        'version' => '1',
        'has' => {
          'CORS' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766880-f205e870-5ee9-11e7-8fe2-0d5b15880752.jpg',
          'api' => 'https://api.vaultoro.com',
          'www' => 'https://www.vaultoro.com',
          'doc' => 'https://api.vaultoro.com'
        },
        'commonCurrencies' => {
          'GLD' => 'Gold'
        },
        'api' => {
          'public' => {
            'get' => [
              'bidandask',
              'buyorders',
              'latest',
              'latesttrades',
              'markets',
              'orderbook',
              'sellorders',
              'transactions/day',
              'transactions/hour',
              'transactions/month'
            ]
          },
          'private' => {
            'get' => [
              'balance',
              'mytrades',
              'orders'
            ],
            'post' => [
              'buy/{symbol}/{type}',
              'cancel/{id}',
              'sell/{symbol}/{type}',
              'withdraw'
            ]
          }
        }
      })
    end

    def fetch_markets(params = {})
      result = []
      markets = self.publicGetMarkets
      market = markets['data']
      baseId = market['MarketCurrency']
      quoteId = market['BaseCurrency']
      base = self.common_currency_code(baseId)
      quote = self.common_currency_code(quoteId)
      symbol = base + '/' + quote
      id = market['MarketName']
      result.push({
        'id' => id,
        'symbol' => symbol,
        'base' => base,
        'quote' => quote,
        'baseId' => baseId,
        'quoteId' => quoteId,
        'info' => market
      })
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetBalance
      balances = response['data']
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currencyId = balance['currency_code'].upcase
        code = currencyId
        if self.currencies_by_id[currencyId].include?(currencyId)
          code = self.currencies_by_id[currencyId]['code']
        end
        free = balance['cash']
        used = balance['reserved']
        total = self.sum(free, used)
        account = {
          'free' => free,
          'used' => used,
          'total' => total
        }
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      response = self.publicGetOrderbook(params)
      orderbook = {
        'bids' => response['data'][0]['b'],
        'asks' => response['data'][1]['s']
      }
      return self.parse_order_book(orderbook, nil, 'bids', 'asks', 'Gold_Price', 'Gold_Amount')
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      quote = self.publicGetBidandask(params)
      bidsLength = quote['bids'].length
      bid = quote['bids'][bidsLength - 1]
      ask = quote['asks'][0]
      response = self.publicGetMarkets(params)
      ticker = response['data']
      timestamp = self.milliseconds
      last = self.safe_float(ticker, 'LastPrice')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, '24hHigh'),
        'low' => self.safe_float(ticker, '24hLow'),
        'bid' => bid[0],
        'bidVolume' => nil,
        'ask' => ask[0],
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => nil,
        'quoteVolume' => self.safe_float(ticker, '24hVolume'),
        'info' => ticker
      }
    end

    def parse_trade(trade, market)
      timestamp = self.parse8601(trade['Time'])
      return {
        'id' => nil,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'order' => nil,
        'type' => nil,
        'side' => nil,
        'price' => trade['Gold_Price'],
        'amount' => trade['Gold_Amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTransactionsDay(params)
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      method = 'privatePost' + self.capitalize(side) + 'SymbolType'
      response = self.send_wrapper(method, self.shallow_extend({
        'symbol' => market['quoteId'].downcase,
        'type' => type,
        'gld' => amount,
        'price' => price || 1
      }, params))
      return {
        'info' => response,
        'id' => response['data']['Order_ID']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostCancelId(self.shallow_extend({
        'id' => id
      }, params))
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/'
      if api == 'public'
        url += path
      else
        self.check_required_credentials
        nonce = self.nonce
        url += self.version + '/' + self.implode_params(path, params)
        query = self.shallow_extend({
          'nonce' => nonce,
          'apikey' => self.apiKey
        }, self.omit(params, self.extract_params(path)))
        url += '?' + self.urlencode(query)
        headers = {
          'Content-Type' => 'application/json',
          'X-Signature' => self.hmac(self.encode(url), self.encode(self.secret))
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
