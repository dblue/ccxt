# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Btcalpha < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'btcalpha',
        'name' => 'BTC-Alpha',
        'countries' => ['US'],
        'version' => 'v1',
        'has' => {
          'fetchTicker' => false,
          'fetchOHLCV' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchMyTrades' => true
        },
        'timeframes' => {
          '1m' => '1',
          '5m' => '5',
          '15m' => '15',
          '30m' => '30',
          '1h' => '60',
          '4h' => '240',
          '1d' => 'D'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/42625213-dabaa5da-85cf-11e8-8f99-aa8f8f7699f0.jpg',
          'api' => 'https://btc-alpha.com/api',
          'www' => 'https://btc-alpha.com',
          'doc' => 'https://btc-alpha.github.io/api-docs',
          'fees' => 'https://btc-alpha.com/fees/',
          'referral' => 'https://btc-alpha.com/?r=123788'
        },
        'api' => {
          'public' => {
            'get' => [
              'currencies/',
              'pairs/',
              'orderbook/{pair_name}/',
              'exchanges/',
              'charts/{pair}/{type}/chart/'
            ]
          },
          'private' => {
            'get' => [
              'wallets/',
              'orders/own/',
              'order/{id}/',
              'exchanges/own/',
              'deposits/',
              'withdraws/'
            ],
            'post' => [
              'order/',
              'order-cancel/'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.2 / 100,
            'taker' => 0.2 / 100
          },
          'funding' => {
            'withdraw' => {
              'BTC' => 0.00135,
              'LTC' => 0.0035,
              'XMR' => 0.018,
              'ZEC' => 0.002,
              'ETH' => 0.01,
              'ETC' => 0.01,
              'SIB' => 1.5,
              'CCRB' => 4,
              'PZM' => 0.05,
              'ITI' => 0.05,
              'DCY' => 5,
              'R' => 5,
              'ATB' => 0.05,
              'BRIA' => 0.05,
              'KZC' => 0.05,
              'HWC' => 1,
              'SPA' => 1,
              'SMS' => 0.001,
              'REC' => 0.01,
              'SUP' => 1,
              'BQ' => 100,
              'GDS' => 0.1,
              'EVN' => 300,
              'TRKC' => 0.01,
              'UNI' => 1,
              'STN' => 1,
              'BCH' => nil,
              'QBIC' => 0.5
            }
          }
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetPairs
      result = []
      for i in (0...markets.length)
        market = markets[i]
        id = market['name']
        base = self.common_currency_code(market['currency1'])
        quote = self.common_currency_code(market['currency2'])
        symbol = base + '/' + quote
        precision = {
          'amount' => 8,
          'price' => parse_int(market['price_precision'])
        }
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'active' => true,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => parse_float(market['minimum_order_size']),
              'max' => parse_float(market['maximum_order_size'])
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => 10**precision['price']
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          },
          'info' => market
        })
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'pair_name' => self.market_id(symbol)
      }
      if limit
        request['limit_sell'] = limit
        request['limit_buy'] = limit
      end
      reponse = self.publicGetOrderbookPairName(self.shallow_extend(request, params))
      return self.parse_order_book(reponse, nil, 'buy', 'sell', 'price', 'amount')
    end

    def parse_trade(trade, market = nil)
      symbol = nil
      if !market
        market = self.safe_value(self.marketsById, trade['pair'])
      end
      if market
        symbol = market['symbol']
      end
      timestamp = parse_int(trade['timestamp'] * 1000)
      price = parse_float(trade['price'])
      amount = parse_float(trade['amount'])
      cost = self.cost_to_precision(symbol, price * amount)
      id = self.safe_string(trade, 'id')
      side = nil
      if trade.include?('my_side')
        side = self.safe_string(trade, 'my_side')
      else
        side = self.safe_string(trade, 'side')
      end
      if !id
        id = self.safe_string(trade, 'tid')
      end
      return {
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'id' => id,
        'order' => self.safe_string(trade, 'o_id'),
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => parse_float(cost),
        'fee' => nil,
        'info' => trade
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      request = {}
      if symbol != nil
        market = self.market(symbol)
        request['pair'] = market['id']
      end
      if limit
        request['limit'] = limit
      end
      trades = self.publicGetExchanges(self.shallow_extend(request, params))
      return self.parse_trades(trades, market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '5m', since = nil, limit = nil)
      return [
        ohlcv['time'] * 1000,
        ohlcv['open'],
        ohlcv['high'],
        ohlcv['low'],
        ohlcv['close'],
        ohlcv['volume']
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '5m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'pair' => market['id'],
        'type' => self.timeframes[timeframe]
      }
      if limit
        request['limit'] = limit
      end
      if since
        request['since'] = parse_int(since / 1000)
      end
      response = self.publicGetChartsPairTypeChart(self.shallow_extend(request, params))
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privateGetWallets(params)
      result = { 'info' => balances }
      for i in (0...balances.length)
        balance = balances[i]
        currency = self.common_currency_code(balance['currency'])
        used = self.safe_float(balance, 'reserve')
        total = self.safe_float(balance, 'balance')
        free = nil
        if used != nil
          if total != nil
            free = total - used
          end
        end
        result[currency] = {
          'free' => free,
          'used' => used,
          'total' => total
        }
      end
      return self.parse_balance(result)
    end

    def parse_order_status(status)
      statuses = {
        '1' => 'open',
        '2' => 'canceled',
        '3' => 'closed'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      symbol = nil
      if !market
        market = self.safe_value(self.marketsById, order['pair'])
      end
      if market
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'date')
      if timestamp != nil
        timestamp *= 1000
      end
      price = parse_float(order['price'])
      amount = self.safe_float(order, 'amount')
      status = self.parse_order_status(self.safe_string(order, 'status'))
      id = self.safe_string(order, 'oid')
      if !id
        id = self.safe_string(order, 'id')
      end
      trades = self.safe_value(order, 'trades')
      if trades
        trades = self.parse_trades(trades, market)
      end
      side = self.safe_string_2(order, 'my_side', 'type')
      return {
        'id' => id,
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'status' => status,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => nil,
        'amount' => amount,
        'filled' => nil,
        'remaining' => nil,
        'trades' => trades,
        'fee' => nil,
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostOrder(self.shallow_extend({
        'pair' => market['id'],
        'type' => side,
        'amount' => amount,
        'price' => self.price_to_precision(symbol, price)
      }, params))
      if !response['success']
        raise(InvalidOrder, self.id + ' ' + self.json(response))
      end
      return self.parse_order(response, market)
    end

    def cancel_order(id, symbol = nil, params = {})
      response = self.privatePostOrderCancel(self.shallow_extend({
        'order' => id
      }, params))
      return response
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      order = self.privateGetOrderId(self.shallow_extend({
        'id' => id
      }, params))
      return self.parse_order(order)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      market = nil
      if symbol
        market = self.market(symbol)
        request['pair'] = market['id']
      end
      if limit
        request['limit'] = limit
      end
      orders = self.privateGetOrdersOwn(self.shallow_extend(request, params))
      return self.parse_orders(orders, market, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'status' => '1'
      }, params))
      return orders
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, self.shallow_extend({
        'status' => '3'
      }, params))
      return orders
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      if symbol
        market = self.market(symbol)
        request['pair'] = market['id']
      end
      if limit
        request['limit'] = limit
      end
      trades = self.privateGetExchangesOwn(self.shallow_extend(request, params))
      return self.parse_trades(trades, nil, since, limit)
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      query = self.urlencode(self.keysort(self.omit(params, self.extract_params(path))))
      url = self.urls['api'] + '/'
      if path != 'charts/{pair}/{type}/chart/'
        url += 'v1/'
      end
      url += self.implode_params(path, params)
      headers = { 'Accept' => 'application/json' }
      if api == 'public'
        if query.length
          url += '?' + query
        end
      else
        self.check_required_credentials
        payload = self.apiKey
        if method == 'POST'
          headers['Content-Type'] = 'application/x-www-form-urlencoded'
          body = query
          payload += body
        elsif query.length
          url += '?' + query
        end
        headers['X-KEY'] = self.apiKey
        headers['X-SIGN'] = self.hmac(self.encode(payload), self.encode(self.secret))
        headers['X-NONCE'] = self.nonce.to_s
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if code < 400
        return
      end
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        message = self.id + ' ' + self.safe_value(response, 'detail', body)
        if code == 401 || code == 403
          raise(AuthenticationError, message)
        elsif code == 429
          raise(DDoSProtection, message)
        end
        raise(ExchangeError, message)
      end
    end
  end
end
