# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Gateio < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'gateio',
        'name' => 'Gate.io',
        'countries' => ['CN'],
        'version' => '2',
        'rateLimit' => 1000,
        'has' => {
          'CORS' => false,
          'createMarketOrder' => false,
          'fetchTickers' => true,
          'withdraw' => true,
          'fetchDeposits' => true,
          'fetchWithdrawals' => true,
          'fetchTransactions' => true,
          'createDepositAddress' => true,
          'fetchDepositAddress' => true,
          'fetchClosedOrders' => true,
          'fetchOHLCV' => true,
          'fetchOpenOrders' => true,
          'fetchOrderTrades' => true,
          'fetchOrders' => true,
          'fetchOrder' => true,
          'fetchMyTrades' => true
        },
        'timeframes' => {
          '1m' => '60',
          '5m' => '300',
          '10m' => '600',
          '15m' => '900',
          '30m' => '1800',
          '1h' => '3600',
          '2h' => '7200',
          '4h' => '14400',
          '6h' => '21600',
          '12h' => '43200',
          '1d' => '86400',
          '1w' => '604800'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg',
          'api' => {
            'public' => 'https://data.gate.io/api',
            'private' => 'https://data.gate.io/api'
          },
          'www' => 'https://gate.io/',
          'doc' => 'https://gate.io/api2',
          'fees' => [
            'https://gate.io/fee',
            'https://support.gate.io/hc/en-us/articles/115003577673'
          ],
          'referral' => 'https://www.gate.io/signup/2436035'
        },
        'api' => {
          'public' => {
            'get' => [
              'candlestick2/{id}',
              'pairs',
              'marketinfo',
              'marketlist',
              'tickers',
              'ticker/{id}',
              'orderBook/{id}',
              'trade/{id}',
              'tradeHistory/{id}',
              'tradeHistory/{id}/{tid}'
            ]
          },
          'private' => {
            'post' => [
              'balances',
              'depositAddress',
              'newAddress',
              'depositsWithdrawals',
              'buy',
              'sell',
              'cancelOrder',
              'cancelAllOrders',
              'getOrder',
              'openOrders',
              'tradeHistory',
              'withdraw'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'percentage' => true,
            'maker' => 0.002,
            'taker' => 0.002
          }
        },
        'exceptions' => {
          '4' => DDoSProtection,
          '7' => NotSupported,
          '8' => NotSupported,
          '9' => NotSupported,
          '15' => DDoSProtection,
          '16' => OrderNotFound,
          '17' => OrderNotFound,
          '21' => InsufficientFunds
        },
        # https://gate.io/api2#errCode
        'errorCodeNames' => {
          '1' => 'Invalid request',
          '2' => 'Invalid version',
          '3' => 'Invalid request',
          '4' => 'Too many attempts',
          '5' => 'Invalid sign',
          '6' => 'Invalid sign',
          '7' => 'Currency is not supported',
          '8' => 'Currency is not supported',
          '9' => 'Currency is not supported',
          '10' => 'Verified failed',
          '11' => 'Obtaining address failed',
          '12' => 'Empty params',
          '13' => 'Internal error, please report to administrator',
          '14' => 'Invalid user',
          '15' => 'Cancel order too fast, please wait 1 min and try again',
          '16' => 'Invalid order id or order is already closed',
          '17' => 'Invalid orderid',
          '18' => 'Invalid amount',
          '19' => 'Not permitted or trade is disabled',
          '20' => 'Your order size is too small',
          '21' => 'You don\'t have enough fund'
        },
        'options' => {
          'limits' => {
            'cost' => {
              'min' => {
                'BTC' => 0.0001,
                'ETH' => 0.001,
                'USDT' => 1
              }
            }
          }
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetMarketinfo
      markets = self.safe_value(response, 'pairs')
      if !markets
        raise(ExchangeError, self.id + ' fetchMarkets got an unrecognized response')
      end
      result = []
      for i in (0...markets.length)
        market = markets[i]
        keys = market.keys
        id = keys[0]
        details = market[id]
        # all of their symbols are separated with an underscore
        # but not boe_eth_eth(BOE_ETH/ETH) which has two underscores
        # https://github.com/ccxt/ccxt/issues/4894
        parts = id.split('_')
        numParts = parts.length
        baseId = parts[0]
        quoteId = parts[1]
        if numParts > 2
          baseId = parts[0] + '_' + parts[1]
          quoteId = parts[2]
        end
        base = baseId.upcase
        quote = quoteId.upcase
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        precision = {
          'amount' => 8,
          'price' => details['decimal_places']
        }
        amountLimits = {
          'min' => details['min_amount'],
          'max' => nil
        }
        priceLimits = {
          'min' => 10**-details['decimal_places'],
          'max' => nil
        }
        defaultCost = amountLimits['min'] * priceLimits['min']
        minCost = self.safe_float(self.options['limits']['cost']['min'], quote, defaultCost)
        costLimits = {
          'min' => minCost,
          'max' => nil
        }
        limits = {
          'amount' => amountLimits,
          'price' => priceLimits,
          'cost' => costLimits
        }
        active = true
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'info' => market,
          'active' => active,
          'maker' => details['fee'] / 100,
          'taker' => details['fee'] / 100,
          'precision' => precision,
          'limits' => limits
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      balance = self.privatePostBalances
      result = { 'info' => balance }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        code = self.common_currency_code(currency)
        account = self.account
        if balance.include?('available')
          if balance['available'].include?(currency)
            account['free'] = parse_float(balance['available'][currency])
          end
        end
        if balance.include?('locked')
          if balance['locked'].include?(currency)
            account['used'] = parse_float(balance['locked'][currency])
          end
        end
        account['total'] = self.sum(account['free'], account['used'])
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'id' => self.market_id(symbol)
      }
      response = self.publicGetOrderBookId(self.shallow_extend(request, params))
      return self.parse_order_book(response)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      # they return [Timestamp, Volume, Close, High, Low, Open]
      return [
        parse_int(ohlcv[0]),   # t
        parse_float(ohlcv[5]), # o
        parse_float(ohlcv[3]), # h
        parse_float(ohlcv[4]), # l
        parse_float(ohlcv[2]), # c
        parse_float(ohlcv[1]), # v
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'id' => market['id'],
        'group_sec' => self.timeframes[timeframe]
      }
      # max limit = 1001
      if limit != nil
        periodDurationInSeconds = self.parse_timeframe(timeframe)
        hours = parse_int((periodDurationInSeconds * limit) / 3600)
        request['range_hour'] = Math.max(0, hours - 1)
      end
      response = self.publicGetCandlestick2Id(self.shallow_extend(request, params))
      #
      #     {
      #         "elapsed" => "15ms",
      #         "result" => "true",
      #         "data" => [
      #             ["1553930820000", "1.005299", "4081.05", "4086.18", "4081.05", "4086.18"],
      #             ["1553930880000", "0.110923277", "4095.2", "4095.23", "4091.15", "4091.15"],
      #             ...
      #             ["1553934420000", "0", "4089.42", "4089.42", "4089.42", "4089.42"],
      #         ]
      #     }
      #
      return self.parse_ohlcvs(response['data'], market, timeframe, since, limit)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.milliseconds
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      percentage = self.safe_float(ticker, 'percentChange')
      open = nil
      change = nil
      average = nil
      if (last != nil) && (percentage != nil)
        relativeChange = percentage / 100
        open = last / self.sum(1, relativeChange)
        change = last - open
        average = self.sum(last, open) / 2
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high24hr'),
        'low' => self.safe_float(ticker, 'low24hr'),
        'bid' => self.safe_float(ticker, 'highestBid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'lowestAsk'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => open,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => percentage,
        'average' => average,
        'baseVolume' => self.safe_float(ticker, 'baseVolume'),
        'quoteVolume' => self.safe_float(ticker, 'quoteVolume'),
        'info' => ticker
      }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if body.length <= 0
        return
      end
      if body[0] != '{'
        return
      end
      resultString = self.safe_string(response, 'result', '')
      if resultString != 'false'
        return
      end
      errorCode = self.safe_string(response, 'code')
      if errorCode != nil
        exceptions = self.exceptions
        errorCodeNames = self.errorCodeNames
        if exceptions.include?(errorCode)
          message = ''
          if errorCodeNames.include?(errorCode)
            message = errorCodeNames[errorCode]
          else
            message = self.safe_string(response, 'message', '(unknown)')
          end
          raise(exceptions[errorCode], message)
        end
      end
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.publicGetTickers(params)
      result = {}
      ids = tickers.keys
      for i in (0...ids.length)
        id = ids[i]
        baseId, quoteId = id.split('_')
        base = baseId.upcase
        quote = quoteId.upcase
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        ticker = tickers[id]
        market = nil
        if self.markets.include?(symbol)
          market = self.markets[symbol]
        end
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
        end
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetTickerId(self.shallow_extend({
        'id' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      # public fetchTrades
      timestamp = self.safe_integer(trade, 'timestamp')
      # private fetchMyTrades
      timestamp = self.safe_integer(trade, 'time_unix', timestamp)
      if timestamp != nil
        timestamp *= 1000
      end
      id = self.safe_string(trade, 'tradeID')
      id = self.safe_string(trade, 'id', id)
      # take either of orderid or orderId
      orderId = self.safe_string(trade, 'orderid')
      orderId = self.safe_string(trade, 'orderNumber', orderId)
      price = self.safe_float(trade, 'rate')
      amount = self.safe_float(trade, 'amount')
      cost = nil
      if price != nil
        if amount != nil
          cost = price * amount
        end
      end
      return {
        'id' => id,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'order' => orderId,
        'type' => nil,
        'side' => trade['type'],
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => nil
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTradeHistoryId(self.shallow_extend({
        'id' => market['id']
      }, params))
      return self.parse_trades(response['data'], market, since, limit)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      response = self.privatePostOpenOrders(params)
      return self.parse_orders(response['orders'], nil, since, limit)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePostGetOrder(self.shallow_extend({
        'orderNumber' => id,
        'currencyPair' => self.market_id(symbol)
      }, params))
      return self.parse_order(response['order'])
    end

    def parse_order_status(status)
      statuses = {
        'cancelled' => 'canceled',
        # 'closed' => 'closed', # these two statuses aren't actually needed
        # 'open' => 'open', # as they are mapped one-to-one
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      #
      #    {'amount' => '0.00000000',
      #     'currencyPair' => 'xlm_usdt',
      #     'fee' => '0.0113766632239302 USDT',
      #     'feeCurrency' => 'USDT',
      #     'feePercentage' => 0.18,
      #     'feeValue' => '0.0113766632239302',
      #     'filledAmount' => '30.14004987',
      #     'filledRate' => 0.2097,
      #     'initialAmount' => '30.14004987',
      #     'initialRate' => '0.2097',
      #     'left' => 0,
      #     'orderNumber' => '998307286',
      #     'rate' => '0.2097',
      #     'status' => 'closed',
      #     'timestamp' => 1531158583,
      #     'type' => 'sell'},
      #
      id = self.safe_string(order, 'orderNumber')
      symbol = nil
      marketId = self.safe_string(order, 'currencyPair')
      if self.markets_by_id.include?(marketId)
        market = self.markets_by_id[marketId]
      end
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'timestamp')
      if timestamp != nil
        timestamp *= 1000
      end
      status = self.parse_order_status(self.safe_string(order, 'status'))
      side = self.safe_string(order, 'type')
      price = self.safe_float(order, 'filledRate')
      amount = self.safe_float(order, 'initialAmount')
      filled = self.safe_float(order, 'filledAmount')
      remaining = self.safe_float(order, 'leftAmount')
      if remaining.nil?
        # In the order status response, self field has a different name.
        remaining = self.safe_float(order, 'left')
      end
      feeCost = self.safe_float(order, 'feeValue')
      feeCurrency = self.safe_string(order, 'feeCurrency')
      feeRate = self.safe_float(order, 'feePercentage')
      if feeRate != nil
        feeRate = feeRate / 100
      end
      if feeCurrency != nil
        if self.currencies_by_id.include?(feeCurrency)
          feeCurrency = self.currencies_by_id[feeCurrency]['code']
        end
      end
      return {
        'id' => id,
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'status' => status,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => nil,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => {
          'cost' => feeCost,
          'currency' => feeCurrency,
          'rate' => feeRate
        },
        'info' => order
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      self.load_markets
      method = 'privatePost' + self.capitalize(side)
      market = self.market(symbol)
      order = {
        'currencyPair' => market['id'],
        'rate' => price,
        'amount' => amount
      }
      response = self.send_wrapper(method, self.shallow_extend(order, params))
      return self.parse_order(self.shallow_extend({
        'status' => 'open',
        'type' => side,
        'initialAmount' => amount
      }, response), market)
    end

    def cancel_order(id, symbol = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' cancelOrder requires symbol argument')
      end
      self.load_markets
      return self.privatePostCancelOrder({
        'orderNumber' => id,
        'currencyPair' => self.market_id(symbol)
      })
    end

    def query_deposit_address(method, code, params = {})
      self.load_markets
      currency = self.currency(code)
      method = 'privatePost' + method + 'Address'
      response = self.send_wrapper(method, self.shallow_extend({
        'currency' => currency['id']
      }, params))
      address = self.safe_string(response, 'addr')
      tag = nil
      if (address != nil) && (address.include?('address'))
        raise(InvalidAddress, self.id + ' queryDepositAddress ' + address)
      end
      if code == 'XRP'
        parts = address.split(' ')
        address = parts[0]
        tag = parts[1]
      end
      return {
        'currency' => currency,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def create_deposit_address(code, params = {})
      return self.query_deposit_address('New', code, params)
    end

    def fetch_deposit_address(code, params = {})
      return self.query_deposit_address('Deposit', code, params)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      response = self.privatePostOpenOrders
      return self.parse_orders(response['orders'], market, since, limit)
    end

    def fetch_order_trades(id, symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      response = self.privatePostTradeHistory(self.shallow_extend({
        'currencyPair' => market['id'],
        'orderNumber' => id
      }, params))
      return self.parse_trades(response['trades'], market, since, limit)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ExchangeError, self.id + ' fetchMyTrades requires symbol param')
      end
      self.load_markets
      market = self.market(symbol)
      id = market['id']
      response = self.privatePostTradeHistory(self.shallow_extend({ 'currencyPair' => id }, params))
      return self.parse_trades(response['trades'], market, since, limit)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'amount' => amount,
        'address' => address, # Address must exist in you AddressBook in security settings
      }
      if tag != nil
        request['address'] += ' ' + tag
      end
      response = self.privatePostWithdraw(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => nil
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      prefix = (api == 'private') ?(api + '/') : ''
      url = self.urls['api'][api] + self.version + '/1/' + prefix + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        request = { 'nonce' => nonce }
        body = self.urlencode(self.shallow_extend(request, query))
        signature = self.hmac(self.encode(body), self.encode(self.secret), 'sha512')
        headers = {
          'Key' => self.apiKey,
          'Sign' => signature,
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def fetch_transactions_by_type(type = nil, code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      if since != nil
        request['start'] = since
      end
      response = self.privatePostDepositsWithdrawals(self.shallow_extend(request, params))
      transactions = nil
      if type.nil?
        deposits = self.safe_value(response, 'deposits', [])
        withdrawals = self.safe_value(response, 'withdraws', [])
        transactions = self.array_concat(deposits, withdrawals)
      else
        transactions = self.safe_value(response, type, [])
      end
      currency = nil
      if code != nil
        currency = self.currency(code)
      end
      return self.parseTransactions(transactions, currency, since, limit)
    end

    def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions_by_type(nil, code, since, limit, params)
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions_by_type('deposits', code, since, limit, params)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      return self.fetch_transactions_by_type('withdraws', code, since, limit, params)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # deposit
      #
      #     {
      #         'id' => 'd16520849',
      #         'currency' => 'NEO',
      #         'address' => False,
      #         'amount' => '1',
      #         'txid' => '01acf6b8ce4d24a....',
      #         'timestamp' => '1553125968',
      #         'status' => 'DONE',
      #         'type' => 'deposit'
      #     }
      #
      # withdrawal
      #
      #     {
      #         'id' => 'w5864259',
      #         'currency' => 'ETH',
      #         'address' => '0x72632f462....',
      #         'amount' => '0.4947',
      #         'txid' => '0x111167d120f736....',
      #         'timestamp' => '1553123688',
      #         'status' => 'DONE',
      #         'type' => 'withdrawal'
      #     }
      #
      code = nil
      currencyId = self.safe_string(transaction, 'currency')
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency.nil?
        code = self.common_currency_code(currencyId)
      end
      if currency != nil
        code = currency['code']
      end
      id = self.safe_string(transaction, 'id')
      txid = self.safe_string(transaction, 'txid')
      amount = self.safe_float(transaction, 'amount')
      address = self.safe_string(transaction, 'address')
      timestamp = self.safe_integer(transaction, 'timestamp')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
      type = self.parse_transaction_type(id[0])
      return {
        'info' => transaction,
        'id' => id,
        'txid' => txid,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => nil,
        'status' => status,
        'type' => type,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => nil
      }
    end

    def parse_transaction_status(status)
      statuses = {
        'PEND' => 'pending',
        'REQUEST' => 'pending',
        'CANCEL' => 'failed',
        'DONE' => 'ok'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction_type(type)
      types = {
        'd' => 'deposit',
        'w' => 'withdrawal'
      }
      return self.safe_string(types, type, type)
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('result')
        result = response['result']
        message = self.id + ' ' + self.json(response)
        if result.nil?
          raise(ExchangeError, message)
        end
        if result.is_a?(String)
          if result != 'true'
            raise(ExchangeError, message)
          end
        elsif !result
          raise(ExchangeError, message)
        end
      end
      return response
    end
  end
end
