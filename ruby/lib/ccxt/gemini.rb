# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Gemini < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'gemini',
        'name' => 'Gemini',
        'countries' => ['US'],
        'rateLimit' => 1500, # 200 for private API
        'version' => 'v1',
        'has' => {
          'fetchDepositAddress' => false,
          'createDepositAddress' => true,
          'CORS' => false,
          'fetchBidsAsks' => false,
          'fetchTickers' => false,
          'fetchMyTrades' => true,
          'fetchOrder' => true,
          'fetchOrders' => false,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => false,
          'createMarketOrder' => false,
          'withdraw' => true,
          'fetchTransactions' => true,
          'fetchWithdrawals' => false,
          'fetchDeposits' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg',
          'api' => 'https://api.gemini.com',
          'www' => 'https://gemini.com',
          'doc' => [
            'https://docs.gemini.com/rest-api',
            'https://docs.sandbox.gemini.com'
          ],
          'test' => 'https://api.sandbox.gemini.com',
          'fees' => [
            'https://gemini.com/fee-schedule/',
            'https://gemini.com/transfer-fees/'
          ]
        },
        'api' => {
          'public' => {
            'get' => [
              'symbols',
              'pubticker/{symbol}',
              'book/{symbol}',
              'trades/{symbol}',
              'auction/{symbol}',
              'auction/{symbol}/history'
            ]
          },
          'private' => {
            'post' => [
              'order/new',
              'order/cancel',
              'order/cancel/session',
              'order/cancel/all',
              'order/status',
              'orders',
              'mytrades',
              'tradevolume',
              'transfers',
              'balances',
              'deposit/{currency}/newAddress',
              'withdraw/{currency}',
              'heartbeat',
              'transfers'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'taker' => 0.0035,
            'maker' => 0.001
          }
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetSymbols
      result = []
      for p in (0...markets.length)
        id = markets[p]
        market = id
        uppercase = market.upcase
        base = uppercase[0...3]
        quote = uppercase[3...6]
        symbol = base + '/' + quote
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'info' => market
        })
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'symbol' => self.market_id(symbol)
      }
      if limit != nil
        request['limit_bids'] = limit
        request['limit_asks'] = limit
      end
      response = self.publicGetBookSymbol(self.shallow_extend(request, params))
      return self.parse_order_book(response, nil, 'bids', 'asks', 'price', 'amount')
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetPubtickerSymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      timestamp = ticker['volume']['timestamp']
      baseVolume = market['base']
      quoteVolume = market['quote']
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => parse_float(ticker['volume'][baseVolume]),
        'quoteVolume' => parse_float(ticker['volume'][quoteVolume]),
        'info' => ticker
      }
    end

    def parse_trade(trade, market)
      timestamp = trade['timestampms']
      order = nil
      if trade.include?('order_id')
        order = trade['order_id'].to_s
      end
      fee = self.safe_float(trade, 'fee_amount')
      if fee != nil
        currency = self.safe_string(trade, 'fee_currency')
        if currency != nil
          if self.currencies_by_id.include?(currency)
            currency = self.currencies_by_id[currency]['code']
          end
          currency = self.common_currency_code(currency)
        end
        fee = {
          'cost' => self.safe_float(trade, 'fee_amount'),
          'currency' => currency
        }
      end
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      return {
        'id' => trade['tid'].to_s,
        'order' => order,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => trade['type'].downcase,
        'price' => price,
        'cost' => price * amount,
        'amount' => amount,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTradesSymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privatePostBalances
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency']
        account = {
          'free' => parse_float(balance['available']),
          'used' => 0.0,
          'total' => parse_float(balance['amount'])
        }
        account['used'] = account['total'] - account['free']
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def parse_order(order, market = nil)
      timestamp = order['timestampms']
      amount = self.safe_float(order, 'original_amount')
      remaining = self.safe_float(order, 'remaining_amount')
      filled = self.safe_float(order, 'executed_amount')
      status = 'closed'
      if order['is_live']
        status = 'open'
      end
      if order['is_cancelled']
        status = 'canceled'
      end
      price = self.safe_float(order, 'price')
      average = self.safe_float(order, 'avg_execution_price')
      if average != 0.0
        price = average # prefer filling(execution) price over the submitted price
      end
      cost = nil
      if filled != nil
        if average != nil
          cost = filled * average
        end
      end
      type = self.safe_string(order, 'type')
      if type == 'exchange limit'
        type = 'limit'
      elsif type == 'market buy' || type == 'market sell'
        type = 'market'
      else
        type = order['type']
      end
      fee = nil
      symbol = nil
      if market.nil?
        marketId = self.safe_string(order, 'symbol')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      return {
        'id' => order['order_id'],
        'info' => order,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => type,
        'side' => order['side'].downcase,
        'price' => price,
        'average' => average,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'fee' => fee
      }
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePostOrderStatus(self.shallow_extend({
        'order_id' => id
      }, params))
      return self.parse_order(response)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      response = self.privatePostOrders(params)
      orders = self.parse_orders(response, nil, since, limit)
      if symbol != nil
        market = self.market(symbol) # throws on non-existent symbol
        orders = self.filter_by_symbol(orders, market['symbol'])
      end
      return orders
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      if type == 'market'
        raise(ExchangeError, self.id + ' allows limit orders only')
      end
      nonce = self.nonce
      order = {
        'client_order_id' => nonce.to_s,
        'symbol' => self.market_id(symbol),
        'amount' => amount.to_s,
        'price' => price.to_s,
        'side' => side,
        'type' => 'exchange limit', # gemini allows limit orders only
      }
      response = self.privatePostOrderNew(self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['order_id']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostOrderCancel({ 'order_id' => id })
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id']
      }
      if limit != nil
        request['limit_trades'] = limit
      end
      if since != nil
        request['timestamp'] = parse_int(since / 1000)
      end
      response = self.privatePostMytrades(self.shallow_extend(request, params))
      return self.parse_trades(response, market, since, limit)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostWithdrawCurrency(self.shallow_extend({
        'currency' => currency['id'],
        'amount' => amount,
        'address' => address
      }, params))
      return {
        'info' => response,
        'id' => self.safe_string(response, 'txHash')
      }
    end

    def nonce
      return self.milliseconds
    end

    def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      response = self.privatePostTransfers(self.shallow_extend(request, params))
      return self.parseTransactions(response)
    end

    def parse_transaction(transaction, currency = nil)
      timestamp = self.safe_integer(transaction, 'timestampms')
      code = nil
      if currency.nil?
        currencyId = self.safe_string(transaction, 'currency')
        if self.currencies_by_id.include?(currencyId)
          currency = self.currencies_by_id[currencyId]
        end
      end
      if currency != nil
        code = currency['code']
      end
      type = self.safe_string(transaction, 'type')
      if type != nil
        type = type.downcase
      end
      status = 'pending'
      # When deposits show as Advanced or Complete they are available for trading.
      if transaction['status']
        status = 'ok'
      end
      return {
        'info' => transaction,
        'id' => self.safe_string(transaction, 'eid'),
        'txid' => self.safe_string(transaction, 'txHash'),
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => nil, # or is it defined?
        'tag' => nil, # or is it defined?
        'type' => type, # direction of the transaction,('deposit' | 'withdraw')
        'amount' => self.safe_float(transaction, 'amount'),
        'currency' => code,
        'status' => status,
        'updated' => nil,
        'fee' => {
          'cost' => nil,
          'rate' => nil
        }
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        request = self.shallow_extend({
          'request' => url,
          'nonce' => nonce
        }, query)
        payload = self.json(request)
        payload = Base64.encode64(self.encode(payload))
        signature = self.hmac(payload, self.encode(self.secret), 'sha384')
        headers = {
          'Content-Type' => 'text/plain',
          'X-GEMINI-APIKEY' => self.apiKey,
          'X-GEMINI-PAYLOAD' => self.decode(payload),
          'X-GEMINI-SIGNATURE' => signature
        }
      end
      url = self.urls['api'] + url
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('result')
        if response['result'] == 'error'
          raise(ExchangeError, self.id + ' ' + self.json(response))
        end
      end
      return response
    end

    def create_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privatePostDepositCurrencyNewAddress(self.shallow_extend({
        'currency' => currency['id']
      }, params))
      address = self.safe_string(response, 'address')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => nil,
        'info' => response
      }
    end
  end
end
