# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Independentreserve < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'independentreserve',
        'name' => 'Independent Reserve',
        'countries' => ['AU', 'NZ'], # Australia, New Zealand
        'rateLimit' => 1000,
        'has' => {
          'CORS' => false
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/30521662-cf3f477c-9bcb-11e7-89bc-d1ac85012eda.jpg',
          'api' => {
            'public' => 'https://api.independentreserve.com/Public',
            'private' => 'https://api.independentreserve.com/Private'
          },
          'www' => 'https://www.independentreserve.com',
          'doc' => 'https://www.independentreserve.com/API'
        },
        'api' => {
          'public' => {
            'get' => [
              'GetValidPrimaryCurrencyCodes',
              'GetValidSecondaryCurrencyCodes',
              'GetValidLimitOrderTypes',
              'GetValidMarketOrderTypes',
              'GetValidOrderTypes',
              'GetValidTransactionTypes',
              'GetMarketSummary',
              'GetOrderBook',
              'GetTradeHistorySummary',
              'GetRecentTrades',
              'GetFxRates'
            ]
          },
          'private' => {
            'post' => [
              'PlaceLimitOrder',
              'PlaceMarketOrder',
              'CancelOrder',
              'GetOpenOrders',
              'GetClosedOrders',
              'GetClosedFilledOrders',
              'GetOrderDetails',
              'GetAccounts',
              'GetTransactions',
              'GetDigitalCurrencyDepositAddress',
              'GetDigitalCurrencyDepositAddresses',
              'SynchDigitalCurrencyDepositAddressWithBlockchain',
              'WithdrawDigitalCurrency',
              'RequestFiatWithdrawal',
              'GetTrades'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'taker' => 0.5 / 100,
            'maker' => 0.5 / 100,
            'percentage' => true,
            'tierBased' => false
          }
        }
      })
    end

    def fetch_markets(params = {})
      baseCurrencies = self.publicGetGetValidPrimaryCurrencyCodes
      quoteCurrencies = self.publicGetGetValidSecondaryCurrencyCodes
      result = []
      for i in (0...baseCurrencies.length)
        baseId = baseCurrencies[i]
        baseIdUppercase = baseId.upcase
        base = self.common_currency_code(baseIdUppercase)
        for j in (0...quoteCurrencies.length)
          quoteId = quoteCurrencies[j]
          quoteIdUppercase = quoteId.upcase
          quote = self.common_currency_code(quoteIdUppercase)
          id = baseId + '/' + quoteId
          symbol = base + '/' + quote
          result.push({
            'id' => id,
            'symbol' => symbol,
            'base' => base,
            'quote' => quote,
            'baseId' => baseId,
            'quoteId' => quoteId,
            'info' => id
          })
        end
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privatePostGetAccounts
      result = { 'info' => balances }
      for i in (0...balances.length)
        balance = balances[i]
        currencyCode = balance['CurrencyCode']
        uppercase = currencyCode.upcase
        currency = self.common_currency_code(uppercase)
        account = self.account
        account['free'] = balance['AvailableBalance']
        account['total'] = balance['TotalBalance']
        account['used'] = account['total'] - account['free']
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetGetOrderBook(self.shallow_extend({
        'primaryCurrencyCode' => market['baseId'],
        'secondaryCurrencyCode' => market['quoteId']
      }, params))
      timestamp = self.parse8601(response['CreatedTimestampUtc'])
      return self.parse_order_book(response, timestamp, 'BuyOrders', 'SellOrders', 'Price', 'Volume')
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.parse8601(ticker['CreatedTimestampUtc'])
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = ticker['LastPrice']
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => ticker['DayHighestPrice'],
        'low' => ticker['DayLowestPrice'],
        'bid' => ticker['CurrentHighestBidPrice'],
        'bidVolume' => nil,
        'ask' => ticker['CurrentLowestOfferPrice'],
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => ticker['DayAvgPrice'],
        'baseVolume' => ticker['DayVolumeXbtInSecondaryCurrrency'],
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetGetMarketSummary(self.shallow_extend({
        'primaryCurrencyCode' => market['baseId'],
        'secondaryCurrencyCode' => market['quoteId']
      }, params))
      return self.parse_ticker(response, market)
    end

    def parse_order(order, market = nil)
      symbol = nil
      if market.nil?
        symbol = market['symbol']
      else
        market = self.find_market(order['PrimaryCurrencyCode'] + '/' + order['SecondaryCurrencyCode'])
      end
      orderType = self.safe_value(order, 'Type')
      if orderType.include?('Market')
        orderType = 'market'
      elsif orderType.include?('Limit')
        orderType = 'limit'
      end
      side = nil
      if orderType.include?('Bid')
        side = 'buy'
      elsif orderType.include?('Offer')
        side = 'sell'
      end
      timestamp = self.parse8601(order['CreatedTimestampUtc'])
      amount = self.safe_float(order, 'VolumeOrdered')
      if amount.nil?
        amount = self.safe_float(order, 'Volume')
      end
      filled = self.safe_float(order, 'VolumeFilled')
      remaining = nil
      feeRate = self.safe_float(order, 'FeePercent')
      feeCost = nil
      if amount != nil
        if filled != nil
          remaining = amount - filled
          if feeRate != nil
            feeCost = feeRate * filled
          end
        end
      end
      feeCurrency = nil
      if market != nil
        symbol = market['symbol']
        feeCurrency = market['base']
      end
      fee = {
        'rate' => feeRate,
        'cost' => feeCost,
        'currency' => feeCurrency
      }
      id = order['OrderGuid']
      status = self.parse_order_status(self.safe_string(order, 'Status'))
      cost = self.safe_float(order, 'Value')
      average = self.safe_float(order, 'AvgPrice')
      price = self.safe_float(order, 'Price', average)
      return {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => orderType,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => average,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee
      }
    end

    def parse_order_status(status)
      statuses = {
        'Open' => 'open',
        'PartiallyFilled' => 'open',
        'Filled' => 'closed',
        'PartiallyFilledAndCancelled' => 'canceled',
        'Cancelled' => 'canceled',
        'PartiallyFilledAndExpired' => 'canceled',
        'Expired' => 'canceled'
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePostGetOrderDetails(self.shallow_extend({
        'orderGuid' => id
      }, params))
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      return self.parse_order(response, market)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = 50, params = {})
      self.load_markets
      pageIndex = self.safe_integer(params, 'pageIndex', 1)
      if limit.nil?
        limit = 50
      end
      request = self.ordered({
        'pageIndex' => pageIndex,
        'pageSize' => limit
      })
      response = self.privatePostGetTrades(self.shallow_extend(request, params))
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      return self.parse_trades(response['Data'], market, since, limit)
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(trade['TradeTimestampUtc'])
      id = self.safe_string(trade, 'TradeGuid')
      orderId = self.safe_string(trade, 'OrderGuid')
      price = self.safe_float(trade, 'Price')
      if price.nil?
        price = self.safe_float(trade, 'SecondaryCurrencyTradePrice')
      end
      amount = self.safe_float(trade, 'VolumeTraded')
      if amount.nil?
        amount = self.safe_float(trade, 'PrimaryCurrencyAmount')
      end
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      side = self.safe_string(trade, 'OrderType')
      if side != nil
        if side.include?('Bid')
          side = 'buy'
        elsif side.include?('Offer')
          side = 'sell'
        end
      end
      return {
        'id' => id,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => orderId,
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'fee' => nil
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetGetRecentTrades(self.shallow_extend({
        'primaryCurrencyCode' => market['baseId'],
        'secondaryCurrencyCode' => market['quoteId'],
        'numberOfRecentTradesToRetrieve' => 50, # max = 50
      }, params))
      return self.parse_trades(response['Trades'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      capitalizedOrderType = self.capitalize(type)
      method = 'privatePostPlace' + capitalizedOrderType + 'Order'
      orderType = capitalizedOrderType
      orderType += (side == 'sell') ? 'Offer' : 'Bid'
      order = self.ordered({
        'primaryCurrencyCode' => market['baseId'],
        'secondaryCurrencyCode' => market['quoteId'],
        'orderType' => orderType
      })
      if type == 'limit'
        order['price'] = price
      end
      order['volume'] = amount
      response = self.send_wrapper(method, self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['OrderGuid']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostCancelOrder({ 'orderGuid' => id })
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + path
      if api == 'public'
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        auth = [
          url,
          'apiKey=' + self.apiKey,
          'nonce=' + nonce.to_s
        ]
        keys = params.keys
        for i in (0...keys.length)
          key = keys[i]
          value = params[key].to_s
          auth.push(key + '=' + value)
        end
        message = auth.join(',')
        signature = self.hmac(self.encode(message), self.encode(self.secret))
        query = self.ordered({})
        query['apiKey'] = self.apiKey
        query['nonce'] = nonce
        query['signature'] = signature.upcase
        for i in (0...keys.length)
          key = keys[i]
          query[key] = params[key]
        end
        body = self.json(query)
        headers = { 'Content-Type' => 'application/json' }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
