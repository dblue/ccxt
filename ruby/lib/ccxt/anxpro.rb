# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Anxpro < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'anxpro',
        'name' => 'ANXPro',
        'countries' => ['JP', 'SG', 'HK', 'NZ'],
        'rateLimit' => 1500,
        'has' => {
          'CORS' => false,
          'fetchCurrencies' => true,
          'fetchOHLCV' => false,
          'fetchTrades' => false,
          'fetchOpenOrders' => true,
          'fetchDepositAddress' => true,
          'createDepositAddress' => false,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27765983-fd8595da-5ec9-11e7-82e3-adb3ab8c2612.jpg',
          'api' => {
            'public' => 'https://anxpro.com/api/2',
            'private' => 'https://anxpro.com/api/2',
            'v3public' => 'https://anxpro.com/api/3'
          },
          'www' => 'https://anxpro.com',
          'doc' => [
            'https://anxv2.docs.apiary.io',
            'https://anxv3.docs.apiary.io',
            'https://anxpro.com/pages/api'
          ]
        },
        'api' => {
          'v3public' => {
            'get' => [
              'currencyStatic'
            ]
          },
          'public' => {
            'get' => [
              '{currency_pair}/money/ticker',
              '{currency_pair}/money/depth/full',
              '{currency_pair}/money/trade/fetch', # disabled by ANXPro
            ]
          },
          'private' => {
            'post' => [
              '{currency_pair}/money/order/add',
              '{currency_pair}/money/order/cancel',
              '{currency_pair}/money/order/quote',
              '{currency_pair}/money/order/result',
              '{currency_pair}/money/orders',
              'money/{currency}/address',
              'money/{currency}/send_simple',
              'money/info',
              'money/trade/list',
              'money/wallet/history'
            ]
          }
        },
        'httpExceptions' => {
          '403' => AuthenticationError
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.1 / 100,
            'taker' => 0.2 / 100
          }
        }
      })
    end

    def fetch_currencies(params = {})
      response = self.v3publicGetCurrencyStatic(params)
      result = {}
      currencies = response['currencyStatic']['currencies']
      #       "currencies" => {
      #         "HKD" => {
      #           "decimals" => 2,
      #           "minOrderSize" => 1.00000000,
      #           "maxOrderSize" => 10000000000.00000000,
      #           "displayDenominator" => 1,
      #           "summaryDecimals" => 0,
      #           "displayUnit" => "HKD",
      #           "symbol" => "$",
      #           "type" => "FIAT",
      #           "engineSettings" => {
      #             "depositsEnabled" => false,
      #             "withdrawalsEnabled" => true,
      #             "displayEnabled" => true,
      #             "mobileAccessEnabled" => true
      #           },
      #           "minOrderValue" => 1.00000000,
      #           "maxOrderValue" => 10000000000.00000000,
      #           "maxMarketOrderValue" => 36000.00000000,
      #           "maxMarketOrderSize" => 36000.00000000,
      #           "assetDivisibility" => 0
      #         },
      #         "ETH" => {
      #           "decimals" => 8,
      #           "minOrderSize" => 0.00010000,
      #           "maxOrderSize" => 1000000000.00000000,
      #           "type" => "CRYPTO",
      #           "confirmationThresholds" => [
      #             { "confosRequired" => 30, "threshold" => 0.50000000 },
      #             { "confosRequired" => 45, "threshold" => 10.00000000 },
      #             { "confosRequired" => 70 }
      #           ],
      #           "networkFee" => 0.00500000,
      #           "engineSettings" => {
      #             "depositsEnabled" => true,
      #             "withdrawalsEnabled" => true,
      #             "displayEnabled" => true,
      #             "mobileAccessEnabled" => true
      #           },
      #           "minOrderValue" => 0.00010000,
      #           "maxOrderValue" => 10000000000.00000000,
      #           "maxMarketOrderValue" => 10000000000.00000000,
      #           "maxMarketOrderSize" => 1000000000.00000000,
      #           "digitalCurrencyType" => "ETHEREUM",
      #           "assetDivisibility" => 0,
      #           "assetIcon" => "/images/currencies/crypto/ETH.svg"
      #         },
      #       },
      ids = currencies.keys
      for i in (0...ids.length)
        id = ids[i]
        currency = currencies[id]
        code = self.common_currency_code(id)
        engineSettings = self.safe_value(currency, 'engineSettings')
        depositsEnabled = self.safe_value(engineSettings, 'depositsEnabled')
        withdrawalsEnabled = self.safe_value(engineSettings, 'withdrawalsEnabled')
        displayEnabled = self.safe_value(engineSettings, 'displayEnabled')
        active = depositsEnabled && withdrawalsEnabled && displayEnabled
        precision = self.safe_integer(currency, 'decimals')
        fee = self.safe_float(currency, 'networkFee')
        type = self.safe_string(currency, 'type')
        if type != 'nil'
          type = type.downcase
        end
        result[code] = {
          'id' => id,
          'code' => code,
          'info' => currency,
          'name' => code,
          'type' => type,
          'active' => active,
          'precision' => precision,
          'fee' => fee,
          'limits' => {
            'amount' => {
              'min' => self.safe_float(currency, 'minOrderSize'),
              'max' => self.safe_float(currency, 'maxOrderSize')
            },
            'price' => {
              'min' => nil,
              'max' => nil
            },
            'cost' => {
              'min' => self.safe_float(currency, 'minOrderValue'),
              'max' => self.safe_float(currency, 'maxOrderValue')
            },
            'withdraw' => {
              'min' => nil,
              'max' => nil
            }
          }
        }
      end
      return result
    end

    def fetch_markets(params = {})
      response = self.v3publicGetCurrencyStatic(params)
      #
      #   {
      #     "currencyStatic" => {
      #       "currencies" => {
      #         "HKD" => {
      #           "decimals" => 2,
      #           "minOrderSize" => 1.00000000,
      #           "maxOrderSize" => 10000000000.00000000,
      #           "displayDenominator" => 1,
      #           "summaryDecimals" => 0,
      #           "displayUnit" => "HKD",
      #           "symbol" => "$",
      #           "type" => "FIAT",
      #           "engineSettings" => {
      #             "depositsEnabled" => false,
      #             "withdrawalsEnabled" => true,
      #             "displayEnabled" => true,
      #             "mobileAccessEnabled" => true
      #           },
      #           "minOrderValue" => 1.00000000,
      #           "maxOrderValue" => 10000000000.00000000,
      #           "maxMarketOrderValue" => 36000.00000000,
      #           "maxMarketOrderSize" => 36000.00000000,
      #           "assetDivisibility" => 0
      #         },
      #         "ETH" => {
      #           "decimals" => 8,
      #           "minOrderSize" => 0.00010000,
      #           "maxOrderSize" => 1000000000.00000000,
      #           "type" => "CRYPTO",
      #           "confirmationThresholds" => [
      #             { "confosRequired" => 30, "threshold" => 0.50000000 },
      #             { "confosRequired" => 45, "threshold" => 10.00000000 },
      #             { "confosRequired" => 70 }
      #           ],
      #           "networkFee" => 0.00500000,
      #           "engineSettings" => {
      #             "depositsEnabled" => true,
      #             "withdrawalsEnabled" => true,
      #             "displayEnabled" => true,
      #             "mobileAccessEnabled" => true
      #           },
      #           "minOrderValue" => 0.00010000,
      #           "maxOrderValue" => 10000000000.00000000,
      #           "maxMarketOrderValue" => 10000000000.00000000,
      #           "maxMarketOrderSize" => 1000000000.00000000,
      #           "digitalCurrencyType" => "ETHEREUM",
      #           "assetDivisibility" => 0,
      #           "assetIcon" => "/images/currencies/crypto/ETH.svg"
      #         },
      #       },
      #       "currencyPairs" => {
      #         "ETHUSD" => {
      #           "priceDecimals" => 5,
      #           "engineSettings" => {
      #             "tradingEnabled" => true,
      #             "displayEnabled" => true,
      #             "cancelOnly" => true,
      #             "verifyRequired" => false,
      #             "restrictedBuy" => false,
      #             "restrictedSell" => false
      #           },
      #           "minOrderRate" => 10.00000000,
      #           "maxOrderRate" => 10000.00000000,
      #           "displayPriceDecimals" => 5,
      #           "tradedCcy" => "ETH",
      #           "settlementCcy" => "USD",
      #           "preferredMarket" => "ANX",
      #           "chartEnabled" => true,
      #           "simpleTradeEnabled" => false
      #         },
      #       },
      #     },
      #     "timestamp" => "1549840691039",
      #     "resultCode" => "OK"
      #   }
      #
      currencyStatic = self.safe_value(response, 'currencyStatic', {})
      currencies = self.safe_value(currencyStatic, 'currencies', {})
      currencyPairs = self.safe_value(currencyStatic, 'currencyPairs', {})
      result = []
      ids = currencyPairs.keys
      for i in (0...ids.length)
        id = ids[i]
        market = currencyPairs[id]
        #
        #     "ETHUSD" => {
        #       "priceDecimals" => 5,
        #       "engineSettings" => {
        #         "tradingEnabled" => true,
        #         "displayEnabled" => true,
        #         "cancelOnly" => true,
        #         "verifyRequired" => false,
        #         "restrictedBuy" => false,
        #         "restrictedSell" => false
        #       },
        #       "minOrderRate" => 10.00000000,
        #       "maxOrderRate" => 10000.00000000,
        #       "displayPriceDecimals" => 5,
        #       "tradedCcy" => "ETH",
        #       "settlementCcy" => "USD",
        #       "preferredMarket" => "ANX",
        #       "chartEnabled" => true,
        #       "simpleTradeEnabled" => false
        #     },
        #
        baseId = self.safe_string(market, 'tradedCcy')
        quoteId = self.safe_string(market, 'settlementCcy')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        baseCurrency = self.safe_value(currencies, baseId, {})
        quoteCurrency = self.safe_value(currencies, quoteId, {})
        precision = {
          'price' => self.safe_integer(market, 'priceDecimals'),
          'amount' => self.safe_integer(baseCurrency, 'decimals')
        }
        engineSettings = self.safe_value(market, 'engineSettings')
        displayEnabled = self.safe_value(engineSettings, 'displayEnabled')
        tradingEnabled = self.safe_value(engineSettings, 'tradingEnabled')
        active = displayEnabled && tradingEnabled
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'precision' => precision,
          'active' => active,
          'limits' => {
            'price' => {
              'min' => self.safe_float(market, 'minOrderRate'),
              'max' => self.safe_float(market, 'maxOrderRate')
            },
            'amount' => {
              'min' => self.safe_float(baseCurrency, 'minOrderSize'),
              'max' => self.safe_float(baseCurrency, 'maxOrderSize')
            },
            'cost' => {
              'min' => self.safe_float(quoteCurrency, 'minOrderValue'),
              'max' => self.safe_float(quoteCurrency, 'maxOrderValue')
            }
          },
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      response = self.privatePostMoneyInfo
      balance = response['data']
      currencies = balance['Wallets'].keys
      result = { 'info' => balance }
      for c in (0...currencies.length)
        currency = currencies[c]
        account = self.account
        if balance['Wallets'].include?(currency)
          wallet = balance['Wallets'][currency]
          account['free'] = parse_float(wallet['Available_Balance']['value'])
          account['total'] = parse_float(wallet['Balance']['value'])
          account['used'] = account['total'] - account['free']
        end
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      response = self.publicGetCurrencyPairMoneyDepthFull(self.shallow_extend({
        'currency_pair' => self.market_id(symbol)
      }, params))
      orderbook = response['data']
      t = parse_int(orderbook['dataUpdateTime'])
      timestamp = parse_int(t / 1000)
      return self.parse_order_book(orderbook, timestamp, 'bids', 'asks', 'price', 'amount')
    end

    def fetch_ticker(symbol, params = {})
      response = self.publicGetCurrencyPairMoneyTicker(self.shallow_extend({
        'currency_pair' => self.market_id(symbol)
      }, params))
      ticker = response['data']
      t = parse_int(ticker['dataUpdateTime'])
      timestamp = parse_int(t / 1000)
      bid = self.safe_float(ticker['buy'], 'value')
      ask = self.safe_float(ticker['sell'], 'value')
      baseVolume = parse_float(ticker['vol']['value'])
      last = parse_float(ticker['last']['value'])
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => parse_float(ticker['high']['value']),
        'low' => parse_float(ticker['low']['value']),
        'bid' => bid,
        'bidVolume' => nil,
        'ask' => ask,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => parse_float(ticker['avg']['value']),
        'baseVolume' => baseVolume,
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      raise(ExchangeError, self.id + ' switched off the trades endpoint, see their docs at https://docs.anxv2.apiary.io')
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'currency_pair' => market['id']
      }
      # ANXPro will return all symbol pairs regardless of what is specified in request
      response = self.privatePostCurrencyPairMoneyOrders(self.shallow_extend(request, params))
      #
      #     {
      #         "result" => "success",
      #         "data" => [
      #             {
      #                 "oid" => "e74305c7-c424-4fbc-a8a2-b41d8329deb0",
      #                 "currency" => "HKD",
      #                 "item" => "BTC",
      #                 "type" => "offer",
      #                 "amount" => {
      #                     "currency" => "BTC",
      #                     "display" => "10.00000000 BTC",
      #                     "display_short" => "10.00 BTC",
      #                     "value" => "10.00000000",
      #                     "value_int" => "1000000000"
      #                 },
      #                 "effective_amount" => {
      #                     "currency" => "BTC",
      #                     "display" => "10.00000000 BTC",
      #                     "display_short" => "10.00 BTC",
      #                     "value" => "10.00000000",
      #                     "value_int" => "1000000000"
      #                 },
      #                 "price" => {
      #                     "currency" => "HKD",
      #                     "display" => "412.34567 HKD",
      #                     "display_short" => "412.35 HKD",
      #                     "value" => "412.34567",
      #                     "value_int" => "41234567"
      #                 },
      #                 "status" => "open",
      #                 "date" => 1393411075000,
      #                 "priority" => 1393411075000000,
      #                 "actions" => []
      #             },
      #            ...
      #         ]
      #     }
      #
      return self.parse_orders(self.safe_value(response, 'data', {}), symbol, since, limit)
    end

    def parse_order(order, market = nil)
      #
      #     {
      #       "oid" => "e74305c7-c424-4fbc-a8a2-b41d8329deb0",
      #       "currency" => "HKD",
      #       "item" => "BTC",
      #       "type" => "offer",  <-- bid/offer
      #       "amount" => {
      #         "currency" => "BTC",
      #         "display" => "10.00000000 BTC",
      #         "display_short" => "10.00 BTC",
      #         "value" => "10.00000000",
      #         "value_int" => "1000000000"
      #       },
      #       "effective_amount" => {
      #         "currency" => "BTC",
      #         "display" => "10.00000000 BTC",
      #         "display_short" => "10.00 BTC",
      #         "value" => "10.00000000",
      #         "value_int" => "1000000000"
      #       },
      #       "price" => {
      #         "currency" => "HKD",
      #         "display" => "412.34567 HKD",
      #         "display_short" => "412.35 HKD",
      #         "value" => "412.34567",
      #         "value_int" => "41234567"
      #       },
      #       "status" => "open",
      #       "date" => 1393411075000,
      #       "priority" => 1393411075000000,
      #       "actions" => []
      #     }
      #
      id = self.safe_string(order, 'oid')
      status = self.safe_string(order, 'status')
      timestamp = self.safe_integer(order, 'date')
      baseId = self.safe_string(order, 'item')
      quoteId = self.safe_string(order, 'currency')
      marketId = baseId + '/' + quoteId
      market = self.safe_value(self.markets_by_id, marketId)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      amount_info = self.safe_value(order, 'amount', {})
      effective_info = self.safe_value(order, 'effective_amount', {})
      price_info = self.safe_value(order, 'price', {})
      remaining = self.safe_float(effective_info, 'value')
      amount = self.safe_float(amount_info, 'volume')
      price = self.safe_float(price_info, 'value')
      filled = nil
      cost = nil
      if amount != nil
        if remaining != nil
          filled = amount - remaining
          cost = price * filled
        end
      end
      orderType = 'limit'
      side = self.safe_string(order, 'type')
      if side == 'offer'
        side = 'sell'
      else
        side = 'buy'
      end
      fee = nil
      trades = nil # todo parse trades
      lastTradeTimestamp = nil
      return {
        'info' => order,
        'id' => id,
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'type' => orderType,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'remaining' => remaining,
        'filled' => filled,
        'status' => status,
        'fee' => fee,
        'trades' => trades
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      market = self.market(symbol)
      order = {
        'currency_pair' => market['id'],
        'amount_int' => parse_int(amount * 100000000), # 10^8
      }
      if type == 'limit'
        order['price_int'] = parse_int(price * market['multiplier']) # 10^5 or 10^8
      end
      order['type'] = (side == 'buy') ? 'bid' : 'ask'
      result = self.privatePostCurrencyPairMoneyOrderAdd(self.shallow_extend(order, params))
      return {
        'info' => result,
        'id' => result['data']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCurrencyPairMoneyOrderCancel({ 'oid' => id })
    end

    def get_amount_multiplier(code)
      multipliers = {
        'BTC' => 100000000,
        'LTC' => 100000000,
        'STR' => 100000000,
        'XRP' => 100000000,
        'DOGE' => 100000000
      }
      defaultValue = 100
      return self.safe_integer(multipliers, code, defaultValue)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      multiplier = self.get_amount_multiplier(code)
      request = {
        'currency' => currency,
        'amount_int' => parse_int(amount * multiplier),
        'address' => address
      }
      if tag != nil
        request['destinationTag'] = tag
      end
      response = self.privatePostMoneyCurrencySendSimple(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => response['data']['transactionId']
      }
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = self.privatePostMoneyCurrencyAddress(self.shallow_extend(request, params))
      result = response['data']
      address = self.safe_string(result, 'addr')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'info' => response
      }
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      url = self.urls['api'][api] + '/' + request
      if api == 'public' || api == 'v3public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({ 'nonce' => nonce }, query))
        secret = Base64.decode64(self.secret)
        # eslint-disable-next-line quotes
        auth = request + "\0" + body
        signature = self.hmac(self.encode(auth), secret, 'sha512', 'base64')
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'Rest-Key' => self.apiKey,
          'Rest-Sign' => self.decode(signature)
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if response.nil? || response == ''
        return
      end
      result = self.safe_string(response, 'result')
      if (result != nil) && (result != 'success')
        raise(ExchangeError, self.id + ' ' + body)
      else
        resultCode = self.safe_string(response, 'resultCode')
        if (resultCode != nil) && (resultCode != 'OK')
          raise(ExchangeError, self.id + ' ' + body)
        end
      end
    end
  end
end
