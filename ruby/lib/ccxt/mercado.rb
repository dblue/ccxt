# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Mercado < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'mercado',
        'name' => 'Mercado Bitcoin',
        'countries' => ['BR'], # Brazil
        'rateLimit' => 1000,
        'version' => 'v3',
        'has' => {
          'CORS' => true,
          'createMarketOrder' => true,
          'fetchOrder' => true,
          'withdraw' => true,
          'fetchOHLCV' => true,
          'fetchOrders' => true,
          'fetchOpenOrders' => true,
          'fetchTicker' => true,
          'fetchTickers' => false
        },
        'timeframes' => {
          '5m' => '5m',
          '15m' => '15m',
          '30m' => '30m',
          '1h' => '1h',
          '6h' => '6h',
          '12h' => '12h',
          '1d' => '1d',
          '3d' => '3d',
          '1w' => '1w',
          '2w' => '2w'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg',
          'api' => {
            'public' => 'https://www.mercadobitcoin.net/api',
            'private' => 'https://www.mercadobitcoin.net/tapi',
            'v4Public' => 'https://www.mercadobitcoin.com.br/v4'
          },
          'www' => 'https://www.mercadobitcoin.com.br',
          'doc' => [
            'https://www.mercadobitcoin.com.br/api-doc',
            'https://www.mercadobitcoin.com.br/trade-api'
          ]
        },
        'api' => {
          'public' => {
            'get' => [
              '{coin}/orderbook/', # last slash critical
              '{coin}/ticker/',
              '{coin}/trades/',
              '{coin}/trades/{from}/',
              '{coin}/trades/{from}/{to}',
              '{coin}/day-summary/{year}/{month}/{day}/'
            ]
          },
          'private' => {
            'post' => [
              'cancel_order',
              'get_account_info',
              'get_order',
              'get_withdrawal',
              'list_system_messages',
              'list_orders',
              'list_orderbook',
              'place_buy_order',
              'place_sell_order',
              'place_market_buy_order',
              'place_market_sell_order',
              'withdraw_coin'
            ]
          },
          'v4Public' => {
            'get' => [
              '{coin}/candle/'
            ]
          }
        },
        'markets' => {
          'BTC/BRL' => { 'id' => 'BRLBTC', 'symbol' => 'BTC/BRL', 'base' => 'BTC', 'quote' => 'BRL', 'precision' => { 'amount' => 8, 'price' => 5 }, 'suffix' => 'Bitcoin' },
          'LTC/BRL' => { 'id' => 'BRLLTC', 'symbol' => 'LTC/BRL', 'base' => 'LTC', 'quote' => 'BRL', 'precision' => { 'amount' => 8, 'price' => 5 }, 'suffix' => 'Litecoin' },
          'BCH/BRL' => { 'id' => 'BRLBCH', 'symbol' => 'BCH/BRL', 'base' => 'BCH', 'quote' => 'BRL', 'precision' => { 'amount' => 8, 'price' => 5 }, 'suffix' => 'BCash' },
          'XRP/BRL' => { 'id' => 'BRLXRP', 'symbol' => 'XRP/BRL', 'base' => 'XRP', 'quote' => 'BRL', 'precision' => { 'amount' => 8, 'price' => 5 }, 'suffix' => 'Ripple' },
          'ETH/BRL' => { 'id' => 'BRLETH', 'symbol' => 'ETH/BRL', 'base' => 'ETH', 'quote' => 'BRL', 'precision' => { 'amount' => 8, 'price' => 5 }, 'suffix' => 'Ethereum' }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.3 / 100,
            'taker' => 0.7 / 100
          }
        }
      })
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      market = self.market(symbol)
      orderbook = self.publicGetCoinOrderbook(self.shallow_extend({
        'coin' => market['base']
      }, params))
      return self.parse_order_book(orderbook)
    end

    def fetch_ticker(symbol, params = {})
      market = self.market(symbol)
      response = self.publicGetCoinTicker(self.shallow_extend({
        'coin' => market['base']
      }, params))
      ticker = response['ticker']
      timestamp = parse_int(ticker['date']) * 1000
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'vol'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def parse_trade(trade, market)
      timestamp = trade['date'] * 1000
      return {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'id' => trade['tid'].to_s,
        'order' => nil,
        'type' => nil,
        'side' => trade['type'],
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      method = 'publicGetCoinTrades'
      request = {
        'coin' => market['base']
      }
      if since != nil
        method += 'From'
        request['from'] = parse_int(since / 1000)
      end
      to = self.safe_integer(params, 'to')
      if to != nil
        method += 'To'
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_balance(params = {})
      response = self.privatePostGetAccountInfo
      balances = response['response_data']['balance']
      result = { 'info' => response }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        lowercase = currency.downcase
        account = self.account
        if balances.include?(lowercase)
          account['free'] = parse_float(balances[lowercase]['available'])
          account['total'] = parse_float(balances[lowercase]['total'])
          account['used'] = account['total'] - account['free']
        end
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      request = {
        'coin_pair' => self.market_id(symbol)
      }
      method = self.capitalize(side) + 'Order'
      if type == 'limit'
        method = 'privatePostPlace' + method
        request['limit_price'] = self.price_to_precision(symbol, price)
        request['quantity'] = self.amount_to_precision(symbol, amount)
      else
        method = 'privatePostPlaceMarket' + method
        if side == 'buy'
          if price.nil?
            raise(InvalidOrder, self.id + ' createOrder requires the price argument with market buy orders to calculate total order cost(amount to spend), where cost = amount * price. Supply a price argument to createOrder call if you want the cost to be calculated for you from price and amount')
          end
          request['cost'] = self.price_to_precision(symbol, amount * price)
        else
          request['quantity'] = self.amount_to_precision(symbol, amount)
        end
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      # TODO => replace self with a call to parseOrder for unification
      return {
        'info' => response,
        'id' => response['response_data']['order']['order_id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' cancelOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'coin_pair' => market['id'],
        'order_id' => id
      }
      response = self.privatePostCancelOrder(self.shallow_extend(request, params))
      #
      #     {
      #         response_data => {
      #             order => {
      #                 order_id => 2176769,
      #                 coin_pair => 'BRLBCH',
      #                 order_type => 2,
      #                 status => 3,
      #                 has_fills => false,
      #                 quantity => '0.10000000',
      #                 limit_price => '1996.15999',
      #                 executed_quantity => '0.00000000',
      #                 executed_price_avg => '0.00000',
      #                 fee => '0.00000000',
      #                 created_timestamp => '1536956488',
      #                 updated_timestamp => '1536956499',
      #                 operations => []
      #             }
      #         },
      #         status_code => 100,
      #         server_unix_timestamp => '1536956499'
      #     }
      #
      responseData = self.safe_value(response, 'response_data', {})
      order = self.safe_value(responseData, 'order', {})
      return self.parse_order(order, market)
    end

    def parse_order_status(status)
      statuses = {
        '2' => 'open',
        '3' => 'canceled',
        '4' => 'closed'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      #
      #     {
      #         "order_id" => 4,
      #         "coin_pair" => "BRLBTC",
      #         "order_type" => 1,
      #         "status" => 2,
      #         "has_fills" => true,
      #         "quantity" => "2.00000000",
      #         "limit_price" => "900.00000",
      #         "executed_quantity" => "1.00000000",
      #         "executed_price_avg" => "900.00000",
      #         "fee" => "0.00300000",
      #         "created_timestamp" => "1453838494",
      #         "updated_timestamp" => "1453838494",
      #         "operations" => [
      #             {
      #                 "operation_id" => 1,
      #                 "quantity" => "1.00000000",
      #                 "price" => "900.00000",
      #                 "fee_rate" => "0.30",
      #                 "executed_timestamp" => "1453838494",
      #             },
      #         ],
      #     }
      #
      id = self.safe_string(order, 'order_id')
      side = nil
      if order.include?('order_type')
        side = (order['order_type'] == 1) ? 'buy' : 'sell'
      end
      status = self.parse_order_status(self.safe_string(order, 'status'))
      symbol = nil
      if market.nil?
        marketId = self.safe_string(order, 'coin_pair')
        market = self.safe_value(self.markets_by_id, marketId)
      end
      if market != nil
        symbol = market['symbol']
      end
      timestamp = self.safe_integer(order, 'created_timestamp')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      fee = {
        'cost' => self.safe_float(order, 'fee'),
        'currency' => market['quote']
      }
      price = self.safe_float(order, 'limit_price')
      # price = self.safe_float(order, 'executed_price_avg', price)
      average = self.safe_float(order, 'executed_price_avg')
      amount = self.safe_float(order, 'quantity')
      filled = self.safe_float(order, 'executed_quantity')
      remaining = amount - filled
      cost = amount * average
      lastTradeTimestamp = self.safe_integer(order, 'updated_timestamp')
      if lastTradeTimestamp != nil
        lastTradeTimestamp = lastTradeTimestamp * 1000
      end
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => average,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee,
        'trades' => nil, # todo parse trades(operations)
      }
      return result
    end

    def fetch_order(id, symbol = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'coin_pair' => market['id'],
        'order_id' => parse_int(id)
      }
      response = self.privatePostGetOrder(self.shallow_extend(request, params))
      responseData = self.safe_value(response, 'response_data', {})
      order = self.safe_value(responseData, 'order')
      return self.parse_order(order, market)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      request = {
        'coin' => currency['id'],
        'quantity' => amount.to_f,
        'address' => address
      }
      if code == 'BRL'
        account_ref = (params.include?('account_ref'))
        if !account_ref
          raise(ExchangeError, self.id + ' requires account_ref parameter to withdraw ' + code)
        end
      elsif code != 'LTC'
        tx_fee = (params.include?('tx_fee'))
        if !tx_fee
          raise(ExchangeError, self.id + ' requires tx_fee parameter to withdraw ' + code)
        end
        if code == 'XRP'
          if tag.nil?
            if params.include?(!('destination_tag'))
              raise(ExchangeError, self.id + ' requires a tag argument or destination_tag parameter to withdraw ' + code)
            end
          else
            request['destination_tag'] = tag
          end
        end
      end
      response = self.privatePostWithdrawCoin(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => response['response_data']['withdrawal']['id']
      }
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      timestamp = self.safe_integer(ohlcv, 'timestamp')
      if timestamp != nil
        timestamp = timestamp * 1000
      end
      return [
        timestamp,
        self.safe_float(ohlcv, 'open'),
        self.safe_float(ohlcv, 'high'),
        self.safe_float(ohlcv, 'low'),
        self.safe_float(ohlcv, 'close'),
        self.safe_float(ohlcv, 'volume')
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'precision' => self.timeframes[timeframe],
        'coin' => market['id'].downcase
      }
      if limit != nil && since != nil
        request['from'] = parse_int(since / 1000)
        request['to'] = self.sum(request['from'], limit * self.parse_timeframe(timeframe))
      elsif since != nil
        request['from'] = parse_int(since / 1000)
        request['to'] = self.sum(self.seconds, 1)
      elsif limit != nil
        request['to'] = self.seconds
        request['from'] = request['to'] - (limit * self.parse_timeframe(timeframe))
      end
      response = self.v4PublicGetCoinCandle(self.shallow_extend(request, params))
      return self.parse_ohlcvs(response['candles'], market, timeframe, since, limit)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrders requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'coin_pair' => market['base']
      }
      response = self.privatePostListOrders(self.shallow_extend(request, params))
      responseData = self.safe_value(response, 'response_data', {})
      orders = self.safe_value(responseData, 'orders', [])
      return self.parse_orders(orders, market, since, limit)
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/'
      query = self.omit(params, self.extract_params(path))
      if api == 'public' || (api == 'v4Public')
        url += self.implode_params(path, params)
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        url += self.version + '/'
        nonce = self.nonce
        body = self.urlencode(self.shallow_extend({
          'tapi_method' => path,
          'tapi_nonce' => nonce
        }, params))
        auth = '/tapi/' + self.version + '/' + '?' + body
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'TAPI-ID' => self.apiKey,
          'TAPI-MAC' => self.hmac(self.encode(auth), self.encode(self.secret), 'sha512')
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('error_message')
        raise(ExchangeError, self.id + ' ' + self.json(response))
      end
      return response
    end
  end
end
