# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Cex < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'cex',
        'name' => 'CEX.IO',
        'countries' => ['GB', 'EU', 'CY', 'RU'],
        'rateLimit' => 1500,
        'has' => {
          'CORS' => true,
          'fetchTickers' => true,
          'fetchOHLCV' => true,
          'fetchOrder' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchDepositAddress' => true
        },
        'timeframes' => {
          '1m' => '1m'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg',
          'api' => 'https://cex.io/api',
          'www' => 'https://cex.io',
          'doc' => 'https://cex.io/cex-api',
          'fees' => [
            'https://cex.io/fee-schedule',
            'https://cex.io/limits-commissions'
          ],
          'referral' => 'https://cex.io/r/0/up105393824/0/'
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true,
          'uid' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'currency_limits/',
              'last_price/{pair}/',
              'last_prices/{currencies}/',
              'ohlcv/hd/{yyyymmdd}/{pair}',
              'order_book/{pair}/',
              'ticker/{pair}/',
              'tickers/{currencies}/',
              'trade_history/{pair}/'
            ],
            'post' => [
              'convert/{pair}',
              'price_stats/{pair}'
            ]
          },
          'private' => {
            'post' => [
              'active_orders_status/',
              'archived_orders/{pair}/',
              'balance/',
              'cancel_order/',
              'cancel_orders/{pair}/',
              'cancel_replace_order/{pair}/',
              'close_position/{pair}/',
              'get_address/',
              'get_myfee/',
              'get_order/',
              'get_order_tx/',
              'open_orders/{pair}/',
              'open_orders/',
              'open_position/{pair}/',
              'open_positions/{pair}/',
              'place_order/{pair}/'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.16 / 100,
            'taker' => 0.25 / 100
          },
          'funding' => {
            'withdraw' => {
              # 'USD' => nil,
              # 'EUR' => nil,
              # 'RUB' => nil,
              # 'GBP' => nil,
              'BTC' => 0.001,
              'ETH' => 0.01,
              'BCH' => 0.001,
              'DASH' => 0.01,
              'BTG' => 0.001,
              'ZEC' => 0.001,
              'XRP' => 0.02
            },
            'deposit' => {
              # 'USD' => amount => amount * 0.035 + 0.25,
              # 'EUR' => amount => amount * 0.035 + 0.24,
              # 'RUB' => amount => amount * 0.05 + 15.57,
              # 'GBP' => amount => amount * 0.035 + 0.2,
              'BTC' => 0.0,
              'ETH' => 0.0,
              'BCH' => 0.0,
              'DASH' => 0.0,
              'BTG' => 0.0,
              'ZEC' => 0.0,
              'XRP' => 0.0,
              'XLM' => 0.0
            }
          }
        },
        'options' => {
          'fetchOHLCVWarning' => true,
          'createMarketBuyOrderRequiresPrice' => true
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetCurrencyLimits
      result = []
      for p in (0...markets['data']['pairs'].length)
        market = markets['data']['pairs'][p]
        id = market['symbol1'] + '/' + market['symbol2']
        symbol = id
        base, quote = symbol.split('/')
        result.push({
          'id' => id,
          'info' => market,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'precision' => {
            'price' => self.precision_from_string(self.safe_string(market, 'minPrice')),
            'amount' => self.precision_from_string(self.safe_string(market, 'minLotSize'))
          },
          'limits' => {
            'amount' => {
              'min' => market['minLotSize'],
              'max' => market['maxLotSize']
            },
            'price' => {
              'min' => self.safe_float(market, 'minPrice'),
              'max' => self.safe_float(market, 'maxPrice')
            },
            'cost' => {
              'min' => market['minLotSizeS2'],
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privatePostBalance
      result = { 'info' => response }
      ommited = ['username', 'timestamp']
      balances = self.omit(response, ommited)
      currencies = balances.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        if balances.include?(currency)
          account = {
            'free' => self.safe_float(balances[currency], 'available', 0.0),
            'used' => self.safe_float(balances[currency], 'orders', 0.0),
            'total' => 0.0
          }
          account['total'] = self.sum(account['free'], account['used'])
          result[currency] = account
        end
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'pair' => self.market_id(symbol)
      }
      if limit != nil
        request['depth'] = limit
      end
      orderbook = self.publicGetOrderBookPair(self.shallow_extend(request, params))
      timestamp = orderbook['timestamp'] * 1000
      return self.parse_order_book(orderbook, timestamp)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv[0] * 1000,
        ohlcv[1],
        ohlcv[2],
        ohlcv[3],
        ohlcv[4],
        ohlcv[5]
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      if since.nil?
        since = self.milliseconds - 86400000 # yesterday
      else
        if self.options['fetchOHLCVWarning']
          raise(ExchangeError, self.id + " fetchOHLCV warning => CEX can return historical candles for a certain date only, self might produce an empty or null reply. Set exchange.options['fetchOHLCVWarning'] = false or add({ 'options' => { 'fetchOHLCVWarning' => false }}) to constructor params to suppress self warning message.")
        end
      end
      ymd = self.ymd(since)
      ymd = ymd.split('-')
      ymd = ymd.join('')
      request = {
        'pair' => market['id'],
        'yyyymmdd' => ymd
      }
      begin
        response = self.publicGetOhlcvHdYyyymmddPair(self.shallow_extend(request, params))
        key = 'data' + self.timeframes[timeframe]
        ohlcvs = JSON.loads(response[key])
        return self.parse_ohlcvs(ohlcvs, market, timeframe, since, limit)
      rescue BaseError => e
        if e.is_a?(NullResponse)
          return []
        end
      end
    end

    def parse_ticker(ticker, market = nil)
      timestamp = nil
      if ticker.include?('timestamp')
        timestamp = parse_int(ticker['timestamp']) * 1000
      end
      volume = self.safe_float(ticker, 'volume')
      high = self.safe_float(ticker, 'high')
      low = self.safe_float(ticker, 'low')
      bid = self.safe_float(ticker, 'bid')
      ask = self.safe_float(ticker, 'ask')
      last = self.safe_float(ticker, 'last')
      symbol = nil
      if market
        symbol = market['symbol']
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => high,
        'low' => low,
        'bid' => bid,
        'bidVolume' => nil,
        'ask' => ask,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => volume,
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      currencies = self.currencies.keys
      response = self.publicGetTickersCurrencies(self.shallow_extend({
        'currencies' => currencies.join('/')
      }, params))
      tickers = response['data']
      result = {}
      for t in (0...tickers.length)
        ticker = tickers[t]
        symbol = ticker['pair'].gsub(':', '/')
        market = self.markets[symbol]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetTickerPair(self.shallow_extend({
        'pair' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market = nil)
      timestamp = parse_int(trade['date']) * 1000
      return {
        'info' => trade,
        'id' => trade['tid'],
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => trade['type'],
        'price' => self.safe_float(trade, 'price'),
        'amount' => self.safe_float(trade, 'amount')
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTradeHistoryPair(self.shallow_extend({
        'pair' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        # for market buy it requires the amount of quote currency to spend
        if side == 'buy'
          if self.options['createMarketBuyOrderRequiresPrice']
            if price.nil?
              raise(InvalidOrder, self.id + " createOrder requires the price argument with market buy orders to calculate total order cost(amount to spend), where cost = amount * price. Supply a price argument to createOrder call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument(the exchange-specific behaviour)")
            else
              amount = amount * price
            end
          end
        end
      end
      self.load_markets
      request = {
        'pair' => self.market_id(symbol),
        'type' => side,
        'amount' => amount
      }
      if type == 'limit'
        request['price'] = price
      else
        request['order_type'] = type
      end
      response = self.privatePostPlaceOrderPair(self.shallow_extend(request, params))
      return {
        'info' => response,
        'id' => response['id']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostCancelOrder({ 'id' => id })
    end

    def parse_order_status(status)
      statuses = {
        'a' => 'open',
        'cd' => 'canceled',
        'c' => 'canceled',
        'd' => 'closed'
      }
      return self.safe_value(statuses, status, status)
    end

    def parse_order(order, market = nil)
      # Depending on the call, 'time' can be a unix int, unix string or ISO string
      # Yes, really
      timestamp = self.safe_value(order, 'time')
      if timestamp.is_a?(String) && timestamp.include?('T')
        # ISO8601 string
        timestamp = self.parse8601(timestamp)
      else
        # either integer or string integer
        timestamp = parse_int(timestamp)
      end
      symbol = nil
      if market.nil?
        symbol = order['symbol1'] + '/' + order['symbol2']
        if self.markets.include?(symbol)
          market = self.market(symbol)
        end
      end
      status = order['status']
      if status == 'a'
        status = 'open' # the unified status
      elsif status == 'cd'
        status = 'canceled'
      elsif status == 'c'
        status = 'canceled'
      elsif status == 'd'
        status = 'closed'
      end
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'amount')
      remaining = self.safe_float(order, 'pending')
      if !remaining
        remaining = self.safe_float(order, 'remains')
      end
      filled = amount - remaining
      fee = nil
      cost = nil
      if market != nil
        symbol = market['symbol']
        cost = self.safe_float(order, 'ta:' + market['quote'])
        if cost.nil?
          cost = self.safe_float(order, 'tta:' + market['quote'])
        end
        baseFee = 'fa:' + market['base']
        baseTakerFee = 'tfa:' + market['base']
        quoteFee = 'fa:' + market['quote']
        quoteTakerFee = 'tfa:' + market['quote']
        feeRate = self.safe_float(order, 'tradingFeeMaker')
        if !feeRate
          feeRate = self.safe_float(order, 'tradingFeeTaker', feeRate)
        end
        if feeRate
          feeRate /= 100.0
        end # convert to mathematically-correct percentage coefficients => 1.0 = 100%
        if order.include?((baseFee)) || (order.include?(baseTakerFee))
          baseFeeCost = self.safe_float(order, baseFee)
          if baseFeeCost.nil?
            baseFeeCost = self.safe_float(order, baseTakerFee)
          end
          fee = {
            'currency' => market['base'],
            'rate' => feeRate,
            'cost' => baseFeeCost
          }
        elsif order.include?((quoteFee)) || (order.include?(quoteTakerFee))
          quoteFeeCost = self.safe_float(order, quoteFee)
          if quoteFeeCost.nil?
            quoteFeeCost = self.safe_float(order, quoteTakerFee)
          end
          fee = {
            'currency' => market['quote'],
            'rate' => feeRate,
            'cost' => quoteFeeCost
          }
        end
      end
      if !cost
        cost = price * filled
      end
      return {
        'id' => order['id'],
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => nil,
        'side' => order['type'],
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => nil,
        'fee' => fee,
        'info' => order
      }
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      method = 'privatePostOpenOrders'
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['pair'] = market['id']
        method += 'Pair'
      end
      orders = self.send_wrapper(method, self.shallow_extend(request, params))
      for i in (0...orders.length)
        orders[i] = self.shallow_extend(orders[i], { 'status' => 'open' })
      end
      return self.parse_orders(orders, market, since, limit)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      method = 'privatePostArchivedOrdersPair'
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchClosedOrders requires a symbol argument')
      end
      market = self.market(symbol)
      request = { 'pair' => market['id'] }
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      return self.parse_orders(response, market, since, limit)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'id' => id.to_s
      }
      response = self.privatePostGetOrder(self.shallow_extend(request, params))
      return self.parse_order(response)
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        auth = nonce + self.uid + self.apiKey
        signature = self.hmac(self.encode(auth), self.encode(self.secret))
        body = self.urlencode(self.shallow_extend({
          'key' => self.apiKey,
          'signature' => signature.upcase,
          'nonce' => nonce
        }, query))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if !response
        raise(NullResponse, self.id + ' returned ' + self.json(response))
      elsif response == true || response == 'true'
        return response
      elsif response.include?('e')
        if response.include?('ok')
          if response['ok'] == 'ok'
            return response
          end
        end
        raise(ExchangeError, self.id + ' ' + self.json(response))
      elsif response.include?('error')
        if response['error']
          raise(ExchangeError, self.id + ' ' + self.json(response))
        end
      end
      return response
    end

    def fetch_deposit_address(code, params = {})
      if code == 'XRP' || code == 'XLM'
        # https://github.com/ccxt/ccxt/pull/2327#issuecomment-375204856
        raise(NotSupported, self.id + ' fetchDepositAddress does not support XRP and XLM addresses yet(awaiting docs from CEX.io)')
      end
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = self.privatePostGetAddress(self.shallow_extend(request, params))
      address = self.safe_string(response, 'data')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => nil,
        'info' => response
      }
    end
  end
end
