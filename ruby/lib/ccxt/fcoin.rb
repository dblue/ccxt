# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Fcoin < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'fcoin',
        'name' => 'FCoin',
        'countries' => ['CN'],
        'rateLimit' => 2000,
        'userAgent' => self.userAgents['chrome39'],
        'version' => 'v2',
        'accounts' => nil,
        'accountsById' => nil,
        'hostname' => 'fcoin.com',
        'has' => {
          'CORS' => false,
          'fetchDepositAddress' => false,
          'fetchOHLCV' => true,
          'fetchOpenOrders' => true,
          'fetchClosedOrders' => true,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOrderBook' => true,
          'fetchOrderBooks' => false,
          'fetchTradingLimits' => false,
          'withdraw' => false,
          'fetchCurrencies' => false
        },
        'timeframes' => {
          '1m' => 'M1',
          '3m' => 'M3',
          '5m' => 'M5',
          '15m' => 'M15',
          '30m' => 'M30',
          '1h' => 'H1',
          '1d' => 'D1',
          '1w' => 'W1',
          '1M' => 'MN'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/42244210-c8c42e1e-7f1c-11e8-8710-a5fb63b165c4.jpg',
          'api' => 'https://api.{hostname}',
          'www' => 'https://www.fcoin.com',
          'referral' => 'https://www.fcoin.com/i/Z5P7V',
          'doc' => 'https://developer.fcoin.com',
          'fees' => 'https://fcoinjp.zendesk.com/hc/en-us/articles/360018727371'
        },
        'api' => {
          'market' => {
            'get' => [
              'ticker/{symbol}',
              'depth/{level}/{symbol}',
              'trades/{symbol}',
              'candles/{timeframe}/{symbol}'
            ]
          },
          'public' => {
            'get' => [
              'symbols',
              'currencies',
              'server-time'
            ]
          },
          'private' => {
            'get' => [
              'accounts/balance',
              'orders',
              'orders/{order_id}',
              'orders/{order_id}/match-results', # check order result
            ],
            'post' => [
              'orders',
              'orders/{order_id}/submit-cancel', # cancel order
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.001,
            'taker' => 0.001
          }
        },
        'limits' => {
          'amount' => { 'min' => 0.01, 'max' => 100000 }
        },
        'options' => {
          'createMarketBuyOrderRequiresPrice' => true,
          'limits' => {
            'BTM/USDT' => { 'amount' => { 'min' => 0.1, 'max' => 10000000 }},
            'ETC/USDT' => { 'amount' => { 'min' => 0.001, 'max' => 400000 }},
            'ETH/USDT' => { 'amount' => { 'min' => 0.001, 'max' => 10000 }},
            'LTC/USDT' => { 'amount' => { 'min' => 0.001, 'max' => 40000 }},
            'BCH/USDT' => { 'amount' => { 'min' => 0.001, 'max' => 5000 }},
            'BTC/USDT' => { 'amount' => { 'min' => 0.001, 'max' => 1000 }},
            'ICX/ETH' => { 'amount' => { 'min' => 0.01, 'max' => 3000000 }},
            'OMG/ETH' => { 'amount' => { 'min' => 0.01, 'max' => 500000 }},
            'FT/USDT' => { 'amount' => { 'min' => 1, 'max' => 10000000 }},
            'ZIL/ETH' => { 'amount' => { 'min' => 1, 'max' => 10000000 }},
            'ZIP/ETH' => { 'amount' => { 'min' => 1, 'max' => 10000000 }},
            'FT/BTC' => { 'amount' => { 'min' => 1, 'max' => 10000000 }},
            'FT/ETH' => { 'amount' => { 'min' => 1, 'max' => 10000000 }}
          }
        },
        'exceptions' => {
          '400' => NotSupported, # Bad Request
          '401' => AuthenticationError,
          '405' => NotSupported,
          '429' => DDoSProtection, # Too Many Requests, exceed api request limit
          '1002' => ExchangeNotAvailable, # System busy
          '1016' => InsufficientFunds,
          '3008' => InvalidOrder,
          '6004' => InvalidNonce,
          '6005' => AuthenticationError, # Illegal API Signature
        },
        'commonCurrencies' => {
          'DAG' => 'DAGX',
          'PAI' => 'PCHAIN',
          'MT' => 'Mariana Token'
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetSymbols
      result = []
      markets = response['data']
      for i in (0...markets.length)
        market = markets[i]
        id = market['name']
        baseId = market['base_currency']
        quoteId = market['quote_currency']
        base = baseId.upcase
        base = self.common_currency_code(base)
        quote = quoteId.upcase
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        precision = {
          'price' => market['price_decimal'],
          'amount' => market['amount_decimal']
        }
        limits = {
          'price' => {
            'min' => 10**-precision['price'],
            'max' => 10**precision['price']
          }
        }
        active = self.safe_value(market, 'tradable', false)
        if self.options['limits'].include?(symbol)
          limits = self.shallow_extend(self.options['limits'][symbol], limits)
        end
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'precision' => precision,
          'limits' => limits,
          'info' => market
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetAccountsBalance(params)
      result = { 'info' => response }
      balances = response['data']
      for i in (0...balances.length)
        balance = balances[i]
        currencyId = balance['currency']
        code = currencyId.upcase
        if self.currencies_by_id.include?(currencyId)
          code = self.currencies_by_id[currencyId]['code']
        else
          code = self.common_currency_code(code)
        end
        account = self.account
        account['free'] = parse_float(balance['available'])
        account['total'] = parse_float(balance['balance'])
        account['used'] = parse_float(balance['frozen'])
        result[code] = account
      end
      return self.parse_balance(result)
    end

    def parse_bids_asks(orders, priceKey = 0, amountKey = 1)
      result = []
      length = orders.length
      halfLength = parse_int(length / 2)
      # += 2 in the for loop below won't transpile
      for i in (0...halfLength)
        index = i * 2
        priceField = self.sum(index, priceKey)
        amountField = self.sum(index, amountKey)
        result.push([
          self.safe_float(orders, priceField),
          self.safe_float(orders, amountField)
        ])
      end
      return result
    end

    def fetch_order_book(symbol = nil, limit = nil, params = {})
      self.load_markets
      if limit != nil
        if (limit == 20) || (limit == 150)
          limit = 'L' + limit.to_s
        else
          raise(ExchangeError, self.id + ' fetchOrderBook supports limit of 20 or 150. Other values are not accepted')
        end
      else
        limit = 'L20'
      end
      request = self.shallow_extend({
        'symbol' => self.market_id(symbol),
        'level' => limit, # L20, L150
      }, params)
      response = self.marketGetDepthLevelSymbol(request)
      orderbook = response['data']
      return self.parse_order_book(orderbook, orderbook['ts'], 'bids', 'asks', 0, 1)
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.marketGetTickerSymbol(self.shallow_extend({
        'symbol' => market['id']
      }, params))
      return self.parse_ticker(ticker['data'], market)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = nil
      symbol = nil
      if market.nil?
        tickerType = self.safe_string(ticker, 'type')
        if tickerType != nil
          parts = tickerType.split('.')
          id = parts[1]
          if self.markets_by_id.include?(id)
            market = self.markets_by_id[id]
          end
        end
      end
      values = ticker['ticker']
      last = values[0]
      if market != nil
        symbol = market['symbol']
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => values[7],
        'low' => values[8],
        'bid' => values[2],
        'bidVolume' => values[3],
        'ask' => values[4],
        'askVolume' => values[5],
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => values[9],
        'quoteVolume' => values[10],
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      timestamp = parse_int(trade['ts'])
      side = trade['side'].downcase
      orderId = self.safe_string(trade, 'id')
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      cost = price * amount
      fee = nil
      return {
        'id' => orderId,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => nil,
        'order' => orderId,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = 50, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'limit' => limit
      }
      if since != nil
        request['timestamp'] = parse_int(since / 1000)
      end
      response = self.marketGetTradesSymbol(self.shallow_extend(request, params))
      return self.parse_trades(response['data'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type == 'market'
        # for market buy it requires the amount of quote currency to spend
        if side == 'buy'
          if self.options['createMarketBuyOrderRequiresPrice']
            if price.nil?
              raise(InvalidOrder, self.id + " createOrder requires the price argument with market buy orders to calculate total order cost(amount to spend), where cost = amount * price. Supply a price argument to createOrder call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument(the exchange-specific behaviour)")
            else
              amount = amount * price
            end
          end
        end
      end
      self.load_markets
      orderType = type
      request = {
        'symbol' => self.market_id(symbol),
        'amount' => self.amount_to_precision(symbol, amount),
        'side' => side,
        'type' => orderType
      }
      if type == 'limit'
        request['price'] = self.price_to_precision(symbol, price)
      end
      result = self.privatePostOrders(self.shallow_extend(request, params))
      return {
        'info' => result,
        'id' => result['data']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.privatePostOrdersOrderIdSubmitCancel(self.shallow_extend({
        'order_id' => id
      }, params))
      order = self.parse_order(response)
      return self.shallow_extend(order, {
        'id' => id,
        'status' => 'canceled'
      })
    end

    def parse_order_status(status)
      statuses = {
        'submitted' => 'open',
        'canceled' => 'canceled',
        'partial_filled' => 'open',
        'partial_canceled' => 'canceled',
        'filled' => 'closed',
        'pending_cancel' => 'canceled'
      }
      if statuses.include?(status)
        return statuses[status]
      end
      return status
    end

    def parse_order(order, market = nil)
      id = self.safe_string(order, 'id')
      side = self.safe_string(order, 'side')
      status = self.parse_order_status(self.safe_string(order, 'state'))
      symbol = nil
      if market.nil?
        marketId = self.safe_string(order, 'symbol')
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
        end
      end
      orderType = self.safe_string(order, 'type')
      timestamp = self.safe_integer(order, 'created_at')
      amount = self.safe_float(order, 'amount')
      filled = self.safe_float(order, 'filled_amount')
      remaining = nil
      price = self.safe_float(order, 'price')
      cost = self.safe_float(order, 'executed_value')
      if filled != nil
        if amount != nil
          remaining = amount - filled
        end
        if cost.nil?
          if price != nil
            cost = price * filled
          end
        elsif (cost > 0) && (filled > 0)
          price = cost / filled
        end
      end
      feeCurrency = nil
      if market != nil
        symbol = market['symbol']
        feeCurrency = (side == 'buy') ? market['base'] : market['quote']
      end
      feeCost = self.safe_float(order, 'fill_fees')
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => orderType,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'remaining' => remaining,
        'filled' => filled,
        'average' => nil,
        'status' => status,
        'fee' => {
          'cost' => feeCost,
          'currency' => feeCurrency
        },
        'trades' => nil
      }
      return result
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = self.shallow_extend({
        'order_id' => id
      }, params)
      response = self.privateGetOrdersOrderId(request)
      return self.parse_order(response['data'])
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      result = self.fetch_orders(symbol, since, limit, { 'states' => 'submitted,partial_filled' })
      return result
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      result = self.fetch_orders(symbol, since, limit, { 'states' => 'filled' })
      return result
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'states' => 'submitted,partial_filled,partial_canceled,filled,canceled'
      }
      if limit != nil
        request['limit'] = limit
      end
      response = self.privateGetOrders(self.shallow_extend(request, params))
      return self.parse_orders(response['data'], market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv['id'] * 1000,
        ohlcv['open'],
        ohlcv['high'],
        ohlcv['low'],
        ohlcv['close'],
        ohlcv['base_vol']
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = 100, params = {})
      self.load_markets
      if limit.nil?
        raise(ExchangeError, self.id + ' fetchOHLCV requires a limit argument')
      end
      market = self.market(symbol)
      request = self.shallow_extend({
        'symbol' => market['id'],
        'timeframe' => self.timeframes[timeframe],
        'limit' => limit
      }, params)
      response = self.marketGetCandlesTimeframeSymbol(request)
      return self.parse_ohlcvs(response['data'], market, timeframe, since, limit)
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = '/' + self.version + '/'
      request += (api == 'private') ? '' : (api + '/')
      request += self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      url = self.implode_params(self.urls['api'], {
        'hostname' => self.hostname
      })
      url += request
      if (api == 'public') || (api == 'market')
        if query
          url += '?' + self.urlencode(query)
        end
      elsif api == 'private'
        self.check_required_credentials
        timestamp = self.nonce.to_s
        query = self.keysort(query)
        if method == 'GET'
          if query
            url += '?' + self.rawencode(query)
          end
        end
        # HTTP_METHOD + HTTP_REQUEST_URI + TIMESTAMP + POST_BODY
        auth = method + url + timestamp
        if method == 'POST'
          if query
            body = self.json(query)
            auth += self.urlencode(query)
          end
        end
        payload = Base64.encode64(self.encode(auth))
        signature = self.hmac(payload, self.encode(self.secret), 'sha1', 'binary')
        signature = self.decode(Base64.encode64(signature))
        headers = {
          'FC-ACCESS-KEY' => self.apiKey,
          'FC-ACCESS-SIGNATURE' => signature,
          'FC-ACCESS-TIMESTAMP' => timestamp,
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if !body.is_a?(String)
        return
      end # fallback to default error handler
      if body.length < 2
        return
      end # fallback to default error handler
      if (body[0] == '{') || (body[0] == '[')
        status = self.safe_string(response, 'status')
        if status != '0'
          feedback = self.id + ' ' + body
          if self.exceptions.include?(status)
            exceptions = self.exceptions
            raise(exceptions[status], feedback)
          end
          raise(ExchangeError, feedback)
        end
      end
    end
  end
end
