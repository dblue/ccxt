# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Therock < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'therock',
        'name' => 'TheRockTrading',
        'countries' => ['MT'],
        'rateLimit' => 1000,
        'version' => 'v1',
        'has' => {
          'CORS' => false,
          'fetchTickers' => true,
          'fetchMyTrades' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766869-75057fa2-5ee9-11e7-9a6f-13e641fa4707.jpg',
          'api' => 'https://api.therocktrading.com',
          'www' => 'https://therocktrading.com',
          'doc' => [
            'https://api.therocktrading.com/doc/v1/index.html',
            'https://api.therocktrading.com/doc/'
          ]
        },
        'api' => {
          'public' => {
            'get' => [
              'funds',
              'funds/{id}/orderbook',
              'funds/{id}/ticker',
              'funds/{id}/trades',
              'funds/tickers'
            ]
          },
          'private' => {
            'get' => [
              'balances',
              'balances/{id}',
              'discounts',
              'discounts/{id}',
              'funds',
              'funds/{id}',
              'funds/{id}/trades',
              'funds/{fund_id}/orders',
              'funds/{fund_id}/orders/{id}',
              'funds/{fund_id}/position_balances',
              'funds/{fund_id}/positions',
              'funds/{fund_id}/positions/{id}',
              'transactions',
              'transactions/{id}',
              'withdraw_limits/{id}',
              'withdraw_limits'
            ],
            'post' => [
              'atms/withdraw',
              'funds/{fund_id}/orders'
            ],
            'delete' => [
              'funds/{fund_id}/orders/{id}',
              'funds/{fund_id}/orders/remove_all'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'maker' => 0.2 / 100,
            'taker' => 0.2 / 100
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {
              'BTC' => 0.0005,
              'BCH' => 0.0005,
              'PPC' => 0.02,
              'ETH' => 0.001,
              'ZEC' => 0.001,
              'LTC' => 0.002,
              'EUR' => 2.5,  # worst-case scenario => https://therocktrading.com/en/pages/fees
            },
            'deposit' => {
              'BTC' => 0,
              'BCH' => 0,
              'PPC' => 0,
              'ETH' => 0,
              'ZEC' => 0,
              'LTC' => 0,
              'EUR' => 0
            }
          }
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetFunds
      #
      #     { funds => [{                      id =>   "BTCEUR",
      #                              description =>   "Trade Bitcoin with Euro",
      #                                     type =>   "currency",
      #                            base_currency =>   "EUR",
      #                           trade_currency =>   "BTC",
      #                                  buy_fee =>    0.2,
      #                                 sell_fee =>    0.2,
      #                      minimum_price_offer =>    0.01,
      #                   minimum_quantity_offer =>    0.0005,
      #                   base_currency_decimals =>    2,
      #                  trade_currency_decimals =>    4,
      #                                leverages => []                           },
      #                {                      id =>   "LTCEUR",
      #                              description =>   "Trade Litecoin with Euro",
      #                                     type =>   "currency",
      #                            base_currency =>   "EUR",
      #                           trade_currency =>   "LTC",
      #                                  buy_fee =>    0.2,
      #                                 sell_fee =>    0.2,
      #                      minimum_price_offer =>    0.01,
      #                   minimum_quantity_offer =>    0.01,
      #                   base_currency_decimals =>    2,
      #                  trade_currency_decimals =>    2,
      #                                leverages => []                            }] }
      #
      markets = self.safe_value(response, 'funds')
      result = []
      if markets.nil?
        raise(ExchangeError, self.id + ' fetchMarkets got an unexpected response')
      else
        for i in (0...markets.length)
          market = markets[i]
          id = self.safe_string(market, 'id')
          baseId = self.safe_string(market, 'trade_currency')
          quoteId = self.safe_string(market, 'base_currency')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
          buy_fee = self.safe_float(market, 'buy_fee')
          sell_fee = self.safe_float(market, 'sell_fee')
          taker = maximum_wrapper(buy_fee, sell_fee)
          taker = taker / 100
          maker = taker
          result.push({
            'id' => id,
            'symbol' => symbol,
            'base' => base,
            'quote' => quote,
            'baseId' => baseId,
            'quoteId' => quoteId,
            'info' => market,
            'active' => true,
            'maker' => maker,
            'taker' => taker,
            'precision' => {
              'amount' => self.safe_integer(market, 'trade_currency_decimals'),
              'price' => self.safe_integer(market, 'base_currency_decimals')
            },
            'limits' => {
              'amount' => {
                'min' => self.safe_float(market, 'minimum_quantity_offer'),
                'max' => nil
              },
              'price' => {
                'min' => self.safe_float(market, 'minimum_price_offer'),
                'max' => nil
              },
              'cost' => {
                'min' => nil,
                'max' => nil
              }
            }
          })
        end
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetBalances
      balances = response['balances']
      result = { 'info' => response }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency']
        free = balance['trading_balance']
        total = balance['balance']
        used = total - free
        account = {
          'free' => free,
          'used' => used,
          'total' => total
        }
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetFundsIdOrderbook(self.shallow_extend({
        'id' => self.market_id(symbol)
      }, params))
      timestamp = self.parse8601(orderbook['date'])
      return self.parse_order_book(orderbook, timestamp, 'bids', 'asks', 'price', 'amount')
    end

    def parse_ticker(ticker, market = nil)
      timestamp = self.parse8601(ticker['date'])
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'open'),
        'close' => last,
        'last' => last,
        'previousClose' => self.safe_float(ticker, 'close'), # previous day close, if any
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'volume_traded'),
        'quoteVolume' => self.safe_float(ticker, 'volume'),
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.publicGetFundsTickers(params)
      tickers = self.index_by(response['tickers'], 'fund_id')
      ids = tickers.keys
      result = {}
      for i in (0...ids.length)
        id = ids[i]
        market = self.markets_by_id[id]
        symbol = market['symbol']
        ticker = tickers[id]
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetFundsIdTicker(self.shallow_extend({
        'id' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades
      #
      #     {      id =>  4493548,
      #       fund_id => "ETHBTC",
      #        amount =>  0.203,
      #         price =>  0.02783576,
      #          side => "buy",
      #          dark =>  false,
      #          date => "2018-11-30T08:19:18.236Z" }
      #
      # fetchMyTrades
      #
      #     {           id =>    237338,
      #            fund_id =>   "BTCEUR",
      #             amount =>    0.348,
      #              price =>    348,
      #               side =>   "sell",
      #               dark =>    false,
      #           order_id =>    14920648,
      #               date =>   "2015-06-03T00:49:49.000Z",
      #       transactions => [{       id =>  2770768,
      #                             date => "2015-06-03T00:49:49.000Z",
      #                             type => "sold_currency_to_fund",
      #                            price =>  121.1,
      #                         currency => "EUR"                       },
      #                       {       id =>  2770769,
      #                             date => "2015-06-03T00:49:49.000Z",
      #                             type => "released_currency_to_fund",
      #                            price =>  0.348,
      #                         currency => "BTC"                        },
      #                       {       id =>  2770772,
      #                             date => "2015-06-03T00:49:49.000Z",
      #                             type => "paid_commission",
      #                            price =>  0.06,
      #                         currency => "EUR",
      #                         trade_id =>  440492                     }   ] }
      #
      if !market
        market = self.markets_by_id[trade['fund_id']]
      end
      timestamp = self.parse8601(self.safe_string(trade, 'date'))
      id = self.safe_string(trade, 'id')
      orderId = self.safe_string(trade, 'order_id')
      side = self.safe_string(trade, 'side')
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      cost = nil
      if price != nil
        if amount != nil
          cost = price * amount
        end
      end
      fee = nil
      feeCost = nil
      transactions = self.safe_value(trade, 'transactions', [])
      transactionsByType = self.group_by(transactions, 'type')
      feeTransactions = self.safe_value(transactionsByType, 'paid_commission', [])
      for i in (0...feeTransactions.length)
        if feeCost.nil?
          feeCost = 0
        end
        feeCost = self.sum(feeCost, self.safe_float(feeTransactions[i], 'price'))
      end
      if feeCost != nil
        fee = {
          'cost' => feeCost,
          'currency' => market['quote']
        }
      end
      return {
        'info' => trade,
        'id' => id,
        'order' => orderId,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'id' => market['id']
      }
      if limit != nil
        request['per_page'] = limit # default 25 max 200
      end
      if since != nil
        request['after'] = self.iso8601(since)
      end
      response = self.privateGetFundsIdTrades(self.shallow_extend(request, params))
      #
      #     { trades => [{           id =>    237338,
      #                        fund_id =>   "BTCEUR",
      #                         amount =>    0.348,
      #                          price =>    348,
      #                           side =>   "sell",
      #                           dark =>    false,
      #                       order_id =>    14920648,
      #                           date =>   "2015-06-03T00:49:49.000Z",
      #                   transactions => [{       id =>  2770768,
      #                                         date => "2015-06-03T00:49:49.000Z",
      #                                         type => "sold_currency_to_fund",
      #                                        price =>  121.1,
      #                                     currency => "EUR"                       },
      #                                   {       id =>  2770769,
      #                                         date => "2015-06-03T00:49:49.000Z",
      #                                         type => "released_currency_to_fund",
      #                                        price =>  0.348,
      #                                     currency => "BTC"                        },
      #                                   {       id =>  2770772,
      #                                         date => "2015-06-03T00:49:49.000Z",
      #                                         type => "paid_commission",
      #                                        price =>  0.06,
      #                                     currency => "EUR",
      #                                     trade_id =>  440492                     }   ] }],
      #         meta => { total_count =>    31,
      #                       first => { href => "https://api.therocktrading.com/v1/funds/BTCXRP/trades?page=1" },
      #                    previous =>    null,
      #                     current => { href => "https://api.therocktrading.com/v1/funds/BTCXRP/trades?page=1" },
      #                        next => { href => "https://api.therocktrading.com/v1/funds/BTCXRP/trades?page=2" },
      #                        last => { href => "https://api.therocktrading.com/v1/funds/BTCXRP/trades?page=2" }  } }
      #
      return self.parse_trades(response['trades'], market, since, limit)
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'id' => market['id']
      }
      if limit != nil
        request['per_page'] = limit # default 25 max 200
      end
      if since != nil
        request['after'] = self.iso8601(since)
      end
      response = self.publicGetFundsIdTrades(self.shallow_extend(request, params))
      #
      #     { trades => [{      id =>  4493548,
      #                   fund_id => "ETHBTC",
      #                    amount =>  0.203,
      #                     price =>  0.02783576,
      #                      side => "buy",
      #                      dark =>  false,
      #                      date => "2018-11-30T08:19:18.236Z" },
      #                 {      id =>  4492926,
      #                   fund_id => "ETHBTC",
      #                    amount =>  0.04,
      #                     price =>  0.02767034,
      #                      side => "buy",
      #                      dark =>  false,
      #                      date => "2018-11-30T07:03:03.897Z" }  ],
      #         meta => { total_count =>    null,
      #                       first => { page =>  1,
      #                                href => "https://api.therocktrading.com/v1/funds/ETHBTC/trades?page=1" },
      #                    previous =>    null,
      #                     current => { page =>  1,
      #                                href => "https://api.therocktrading.com/v1/funds/ETHBTC/trades?page=1" },
      #                        next => { page =>  2,
      #                                href => "https://api.therocktrading.com/v1/funds/ETHBTC/trades?page=2" },
      #                        last =>    null                                                                   } }
      #
      return self.parse_trades(response['trades'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      if type == 'market'
        price = 0
      end
      response = self.privatePostFundsFundIdOrders(self.shallow_extend({
        'fund_id' => self.market_id(symbol),
        'side' => side,
        'amount' => amount,
        'price' => price
      }, params))
      return {
        'info' => response,
        'id' => response['id'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privateDeleteFundsFundIdOrdersId(self.shallow_extend({
        'id' => id,
        'fund_id' => self.market_id(symbol)
      }, params))
    end

    def parse_order_status(status)
      statuses = {
        'active' => 'open',
        'executed' => 'closed',
        'deleted' => 'canceled',
        # don't know what self status means
        # 'conditional' => '?'
      }
      return self.safe_string(statuses, status, status)
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce.to_s
        auth = nonce + url
        headers = {
          'X-TRT-KEY' => self.apiKey,
          'X-TRT-NONCE' => nonce,
          'X-TRT-SIGN' => self.hmac(self.encode(auth), self.encode(self.secret), 'sha512')
        }
        if query
          body = self.json(query)
          headers['Content-Type'] = 'application/json'
        end
      elsif api == 'public'
        if query
          url += '?' + self.rawencode(query)
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('errors')
        raise(ExchangeError, self.id + ' ' + self.json(response))
      end
      return response
    end
  end
end
