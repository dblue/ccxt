# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Upbit < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'upbit',
        'name' => 'Upbit',
        'countries' => ['KR'],
        'version' => 'v1',
        'rateLimit' => 1000,
        'certified' => true,
        # new metainfo interface
        'has' => {
          'CORS' => true,
          'createDepositAddress' => true,
          'createMarketOrder' => false,
          'fetchDepositAddress' => true,
          'fetchClosedOrders' => true,
          'fetchMyTrades' => false,
          'fetchOHLCV' => true,
          'fetchOrder' => true,
          'fetchOrderBooks' => true,
          'fetchOpenOrders' => true,
          'fetchOrders' => false,
          'fetchTickers' => true,
          'withdraw' => true,
          'fetchDeposits' => true,
          'fetchWithdrawals' => true,
          'fetchTransactions' => false
        },
        'timeframes' => {
          '1m' => 'minutes',
          '3m' => 'minutes',
          '5m' => 'minutes',
          '15m' => 'minutes',
          '30m' => 'minutes',
          '1h' => 'minutes',
          '4h' => 'minutes',
          '1d' => 'days',
          '1w' => 'weeks',
          '1M' => 'months'
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/49245610-eeaabe00-f423-11e8-9cba-4b0aed794799.jpg',
          'api' => 'https://api.upbit.com',
          'www' => 'https://upbit.com',
          'doc' => 'https://docs.upbit.com/docs/%EC%9A%94%EC%B2%AD-%EC%88%98-%EC%A0%9C%ED%95%9C',
          'fees' => 'https://upbit.com/service_center/guide'
        },
        'api' => {
          'public' => {
            'get' => [
              'market/all',
              'candles/{timeframe}',
              'candles/{timeframe}/{unit}',
              'candles/minutes/{unit}',
              'candles/minutes/1',
              'candles/minutes/3',
              'candles/minutes/5',
              'candles/minutes/15',
              'candles/minutes/30',
              'candles/minutes/60',
              'candles/minutes/240',
              'candles/days',
              'candles/weeks',
              'candles/months',
              'trades/ticks',
              'ticker',
              'orderbook'
            ]
          },
          'private' => {
            'get' => [
              'accounts',
              'orders/chance',
              'order',
              'orders',
              'withdraws',
              'withdraw',
              'withdraws/chance',
              'deposits',
              'deposit',
              'deposits/coin_addresses',
              'deposits/coin_address'
            ],
            'post' => [
              'orders',
              'withdraws/coin',
              'withdraws/krw',
              'deposits/generate_coin_address'
            ],
            'delete' => [
              'order'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => false,
            'percentage' => true,
            'maker' => 0.0025,
            'taker' => 0.0025
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {},
            'deposit' => {}
          }
        },
        'exceptions' => {
          'exact' => {
            'Missing request parameter error. Check the required parameters!' => BadRequest,
            'side is missing, side does not have a valid value' => InvalidOrder
          },
          'broad' => {
            'thirdparty_agreement_required' => PermissionDenied,
            'out_of_scope' => PermissionDenied,
            'order_not_found' => OrderNotFound,
            'insufficient_funds_ask' => InsufficientFunds,
            'insufficient_funds_bid' => InsufficientFunds,
            'invalid_access_key' => AuthenticationError,
            'jwt_verification' => AuthenticationError
          }
        },
        'options' => {
          'fetchTickersMaxLength' => 4096, # 2048,
          'fetchOrderBooksMaxLength' => 4096, # 2048,
          'symbolSeparator' => '-',
          'tradingFeesByQuoteCurrency' => {
            'KRW' => 0.0005
          }
        },
        'commonCurrencies' => {
          'CPT' => 'Contents Protocol', # conflict with CPT(Cryptaur) https://github.com/ccxt/ccxt/issues/4920
        }
      })
    end

    def fetch_currency(code, params = {})
      # self method is for retrieving funding fees and limits per currency
      # it requires private access and API keys properly set up
      self.load_markets
      currency = self.currency(code)
      return self.fetch_currency_by_id(currency['id'], params)
    end

    def fetch_currency_by_id(id, params = {})
      # self method is for retrieving funding fees and limits per currency
      # it requires private access and API keys properly set up
      request = {
        'currency' => id
      }
      response = self.privateGetWithdrawsChance(self.shallow_extend(request, params))
      #
      #     {
      #         "member_level" => {
      #             "security_level" => 3,
      #             "fee_level" => 0,
      #             "email_verified" => true,
      #             "identity_auth_verified" => true,
      #             "bank_account_verified" => true,
      #             "kakao_pay_auth_verified" => false,
      #             "locked" => false,
      #             "wallet_locked" => false
      #         },
      #         "currency" => {
      #             "code" => "BTC",
      #             "withdraw_fee" => "0.0005",
      #             "is_coin" => true,
      #             "wallet_state" => "working",
      #             "wallet_support" => ["deposit", "withdraw"]
      #         },
      #         "account" => {
      #             "currency" => "BTC",
      #             "balance" => "10.0",
      #             "locked" => "0.0",
      #             "avg_krw_buy_price" => "8042000",
      #             "modified" => false
      #         },
      #         "withdraw_limit" => {
      #             "currency" => "BTC",
      #             "minimum" => null,
      #             "onetime" => null,
      #             "daily" => "10.0",
      #             "remaining_daily" => "10.0",
      #             "remaining_daily_krw" => "0.0",
      #             "fixed" => null,
      #             "can_withdraw" => true
      #         }
      #     }
      #
      memberInfo = self.safe_value(response, 'member_level', {})
      currencyInfo = self.safe_value(response, 'currency', {})
      withdrawLimits = self.safe_value(response, 'withdraw_limit', {})
      canWithdraw = self.safe_value(withdrawLimits, 'can_withdraw')
      walletState = self.safe_string(currencyInfo, 'wallet_state')
      walletLocked = self.safe_value(memberInfo, 'wallet_locked')
      locked = self.safe_value(memberInfo, 'locked')
      active = true
      if (canWithdraw != nil) && canWithdraw
        active = false
      elsif walletState != 'working'
        active = false
      elsif (walletLocked != nil) && walletLocked
        active = false
      elsif (locked != nil) && locked
        active = false
      end
      maxOnetimeWithdrawal = self.safe_float(withdrawLimits, 'onetime')
      maxDailyWithdrawal = self.safe_float(withdrawLimits, 'daily', maxOnetimeWithdrawal)
      remainingDailyWithdrawal = self.safe_float(withdrawLimits, 'remaining_daily', maxDailyWithdrawal)
      maxWithdrawLimit = nil
      if remainingDailyWithdrawal > 0
        maxWithdrawLimit = remainingDailyWithdrawal
      else
        maxWithdrawLimit = maxDailyWithdrawal
      end
      precision = nil
      currencyId = self.safe_string(currencyInfo, 'code')
      code = self.common_currency_code(currencyId)
      return {
        'info' => response,
        'id' => currencyId,
        'code' => code,
        'name' => code,
        'active' => active,
        'fee' => self.safe_float(currencyInfo, 'withdraw_fee'),
        'precision' => precision,
        'limits' => {
          'withdraw' => {
            'min' => self.safe_float(withdrawLimits, 'minimum'),
            'max' => maxWithdrawLimit
          }
        }
      }
    end

    def fetch_market(symbol, params = {})
      # self method is for retrieving trading fees and limits per market
      # it requires private access and API keys properly set up
      self.load_markets
      market = self.market(symbol)
      return self.fetch_market_by_id(market['id'], params)
    end

    def fetch_market_by_id(id, params = {})
      # self method is for retrieving trading fees and limits per market
      # it requires private access and API keys properly set up
      request = {
        'market' => id
      }
      response = self.privateGetOrdersChance(self.shallow_extend(request, params))
      #
      #     {     bid_fee =>   "0.0005",
      #           ask_fee =>   "0.0005",
      #            market => {          id =>   "KRW-BTC",
      #                             name =>   "BTC/KRW",
      #                      order_types => ["limit"],
      #                      order_sides => ["ask", "bid"],
      #                              bid => {   currency => "KRW",
      #                                     price_unit =>  null,
      #                                      min_total =>  1000  },
      #                              ask => {   currency => "BTC",
      #                                     price_unit =>  null,
      #                                      min_total =>  1000  },
      #                        max_total =>   "1000000000.0",
      #                            state =>   "active"              },
      #       bid_account => {          currency => "KRW",
      #                                balance => "0.0",
      #                                 locked => "0.0",
      #                      avg_krw_buy_price => "0",
      #                               modified =>  false },
      #       ask_account => {          currency => "BTC",
      #                                balance => "0.00780836",
      #                                 locked => "0.0",
      #                      avg_krw_buy_price => "6465564.67",
      #                               modified =>  false        }      }
      #
      marketInfo = self.safe_value(response, 'market')
      bid = self.safe_value(marketInfo, 'bid')
      ask = self.safe_value(marketInfo, 'ask')
      marketId = self.safe_string(marketInfo, 'id')
      baseId = self.safe_string(ask, 'currency')
      quoteId = self.safe_string(bid, 'currency')
      base = self.common_currency_code(baseId)
      quote = self.common_currency_code(quoteId)
      symbol = base + '/' + quote
      precision = {
        'amount' => 8,
        'price' => 8
      }
      state = self.safe_string(marketInfo, 'state')
      active = (state == 'active')
      bidFee = self.safe_float(response, 'bid_fee')
      askFee = self.safe_float(response, 'ask_fee')
      fee = maximum_wrapper(bidFee, askFee)
      return {
        'info' => response,
        'id' => marketId,
        'symbol' => symbol,
        'base' => base,
        'quote' => quote,
        'baseId' => baseId,
        'quoteId' => quoteId,
        'active' => active,
        'precision' => precision,
        'maker' => fee,
        'taker' => fee,
        'limits' => {
          'amount' => {
            'min' => self.safe_float(ask, 'min_total'),
            'max' => nil
          },
          'price' => {
            'min' => 10**-precision['price'],
            'max' => nil
          },
          'cost' => {
            'min' => self.safe_float(bid, 'min_total'),
            'max' => self.safe_float(marketInfo, 'max_total')
          }
        }
      }
    end

    def fetch_markets(params = {})
      response = self.publicGetMarketAll(params)
      #
      #     [{       market => "KRW-BTC",
      #          korean_name => "비트코인",
      #         english_name => "Bitcoin"  },
      #       {       market => "KRW-DASH",
      #          korean_name => "대시",
      #         english_name => "Dash"      },
      #       {       market => "KRW-ETH",
      #          korean_name => "이더리움",
      #         english_name => "Ethereum" },
      #       {       market => "BTC-ETH",
      #          korean_name => "이더리움",
      #         english_name => "Ethereum" },
      #       ...,
      #       {       market => "BTC-BSV",
      #          korean_name => "비트코인에스브이",
      #         english_name => "Bitcoin SV" }]
      #
      result = []
      for i in (0...response.length)
        market = response[i]
        id = self.safe_string(market, 'market')
        quoteId, baseId = id.split('-')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => 8,
          'price' => 8
        }
        active = true
        makerFee = self.safe_float(self.options['tradingFeesByQuoteCurrency'], quote, self.fees['trading']['maker'])
        takerFee = self.safe_float(self.options['tradingFeesByQuoteCurrency'], quote, self.fees['trading']['taker'])
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'active' => active,
          'info' => market,
          'precision' => precision,
          'maker' => makerFee,
          'taker' => takerFee,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => nil
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            },
            'cost' => {
              'min' => nil,
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetAccounts(params)
      #
      #     [{          currency => "BTC",
      #                   balance => "0.005",
      #                    locked => "0.0",
      #         avg_krw_buy_price => "7446000",
      #                  modified =>  false     },
      #       {          currency => "ETH",
      #                   balance => "0.1",
      #                    locked => "0.0",
      #         avg_krw_buy_price => "250000",
      #                  modified =>  false    }   ]
      #
      result = { 'info' => response }
      indexed = self.index_by(response, 'currency')
      ids = indexed.keys
      for i in (0...ids.length)
        id = ids[i]
        currency = self.common_currency_code(id)
        account = self.account
        balance = indexed[id]
        free = self.safe_float(balance, 'balance')
        used = self.safe_float(balance, 'locked')
        total = self.sum(free, used)
        account['free'] = free
        account['used'] = used
        account['total'] = total
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def get_symbol_from_market_id(marketId, market = nil)
      if marketId.nil?
        return nil
      end
      market = self.safe_value(self.markets_by_id, marketId, market)
      if market != nil
        return market['symbol']
      end
      baseId, quoteId = marketId.split(self.options['symbolSeparator'])
      base = self.common_currency_code(baseId)
      quote = self.common_currency_code(quoteId)
      return base + '/' + quote
    end

    def fetch_order_books(symbols = nil, params = {})
      self.load_markets
      ids = nil
      if symbols.nil?
        ids = self.ids.join(',')
        # max URL length is 2083 symbols, including http schema, hostname, tld, etc...
        if ids.length > self.options['fetchOrderBooksMaxLength']
          numIds = self.ids.length
          raise(ExchangeError, self.id + ' has ' + numIds.to_s + ' symbols(' + ids.length.to_s + ' characters) exceeding max URL length(' + self.options['fetchOrderBooksMaxLength'].to_s + ' characters), you are required to specify a list of symbols in the first argument to fetchOrderBooks')
        end
      else
        ids = self.market_ids(symbols)
        ids = ids.join(',')
      end
      request = {
        'markets' => ids
      }
      response = self.publicGetOrderbook(self.shallow_extend(request, params))
      #
      #     [{          market =>   "BTC-ETH",
      #               timestamp =>    1542899030043,
      #          total_ask_size =>    109.57065201,
      #          total_bid_size =>    125.74430631,
      #         orderbook_units => [{ ask_price => 0.02926679,
      #                              bid_price => 0.02919904,
      #                               ask_size => 4.20293961,
      #                               bid_size => 11.65043576 },
      #                            ...,
      #                            { ask_price => 0.02938209,
      #                              bid_price => 0.0291231,
      #                               ask_size => 0.05135782,
      #                               bid_size => 13.5595     }   ] },
      #       {          market =>   "KRW-BTC",
      #               timestamp =>    1542899034662,
      #          total_ask_size =>    12.89790974,
      #          total_bid_size =>    4.88395783,
      #         orderbook_units => [{ ask_price => 5164000,
      #                              bid_price => 5162000,
      #                               ask_size => 2.57606495,
      #                               bid_size => 0.214       },
      #                            ...,
      #                            { ask_price => 5176000,
      #                              bid_price => 5152000,
      #                               ask_size => 2.752,
      #                               bid_size => 0.4650305 }    ] }   ]
      #
      result = {}
      for i in (0...response.length)
        orderbook = response[i]
        symbol = self.get_symbol_from_market_id(self.safe_string(orderbook, 'market'))
        timestamp = self.safe_integer(orderbook, 'timestamp')
        result[symbol] = {
          'bids' => self.sort_by(self.parse_bids_asks(orderbook['orderbook_units'], 'bid_price', 'bid_size'), 0, true),
          'asks' => self.sort_by(self.parse_bids_asks(orderbook['orderbook_units'], 'ask_price', 'ask_size'), 0),
          'timestamp' => timestamp,
          'datetime' => self.iso8601(timestamp),
          'nonce' => nil
        }
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      orderbooks = self.fetch_order_books([symbol], params)
      return self.safe_value(orderbooks, symbol)
    end

    def parse_ticker(ticker, market = nil)
      #
      #       {                market => "BTC-ETH",
      #                    trade_date => "20181122",
      #                    trade_time => "104543",
      #                trade_date_kst => "20181122",
      #                trade_time_kst => "194543",
      #               trade_timestamp =>  1542883543097,
      #                 opening_price =>  0.02976455,
      #                    high_price =>  0.02992577,
      #                     low_price =>  0.02934283,
      #                   trade_price =>  0.02947773,
      #            prev_closing_price =>  0.02966,
      #                        change => "FALL",
      #                  change_price =>  0.00018227,
      #                   change_rate =>  0.0061453136,
      #           signed_change_price =>  -0.00018227,
      #            signed_change_rate =>  -0.0061453136,
      #                  trade_volume =>  1.00000005,
      #               acc_trade_price =>  100.95825586,
      #           acc_trade_price_24h =>  289.58650166,
      #              acc_trade_volume =>  3409.85311036,
      #          acc_trade_volume_24h =>  9754.40510513,
      #         highest_52_week_price =>  0.12345678,
      #          highest_52_week_date => "2018-02-01",
      #          lowest_52_week_price =>  0.023936,
      #           lowest_52_week_date => "2017-12-08",
      #                     timestamp =>  1542883543813  }
      #
      timestamp = self.safe_integer(ticker, 'trade_timestamp')
      symbol = self.get_symbol_from_market_id(self.safe_string(ticker, 'market'), market)
      previous = self.safe_float(ticker, 'prev_closing_price')
      last = self.safe_float(ticker, 'trade_price')
      change = self.safe_float(ticker, 'signed_change_price')
      percentage = self.safe_float(ticker, 'signed_change_rate')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high_price'),
        'low' => self.safe_float(ticker, 'low_price'),
        'bid' => nil,
        'bidVolume' => nil,
        'ask' => nil,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => self.safe_float(ticker, 'opening_price'),
        'close' => last,
        'last' => last,
        'previousClose' => previous,
        'change' => change,
        'percentage' => percentage,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'acc_trade_volume_24h'),
        'quoteVolume' => self.safe_float(ticker, 'acc_trade_price_24h'),
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      ids = nil
      if symbols.nil?
        ids = self.ids.join(',')
        # max URL length is 2083 symbols, including http schema, hostname, tld, etc...
        if ids.length > self.options['fetchTickersMaxLength']
          numIds = self.ids.length
          raise(ExchangeError, self.id + ' has ' + numIds.to_s + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers')
        end
      else
        ids = self.market_ids(symbols)
        ids = ids.join(',')
      end
      request = {
        'markets' => ids
      }
      response = self.publicGetTicker(self.shallow_extend(request, params))
      #
      #     [{                market => "BTC-ETH",
      #                    trade_date => "20181122",
      #                    trade_time => "104543",
      #                trade_date_kst => "20181122",
      #                trade_time_kst => "194543",
      #               trade_timestamp =>  1542883543097,
      #                 opening_price =>  0.02976455,
      #                    high_price =>  0.02992577,
      #                     low_price =>  0.02934283,
      #                   trade_price =>  0.02947773,
      #            prev_closing_price =>  0.02966,
      #                        change => "FALL",
      #                  change_price =>  0.00018227,
      #                   change_rate =>  0.0061453136,
      #           signed_change_price =>  -0.00018227,
      #            signed_change_rate =>  -0.0061453136,
      #                  trade_volume =>  1.00000005,
      #               acc_trade_price =>  100.95825586,
      #           acc_trade_price_24h =>  289.58650166,
      #              acc_trade_volume =>  3409.85311036,
      #          acc_trade_volume_24h =>  9754.40510513,
      #         highest_52_week_price =>  0.12345678,
      #          highest_52_week_date => "2018-02-01",
      #          lowest_52_week_price =>  0.023936,
      #           lowest_52_week_date => "2017-12-08",
      #                     timestamp =>  1542883543813  }]
      #
      result = {}
      for t in (0...response.length)
        ticker = self.parse_ticker(response[t])
        symbol = ticker['symbol']
        result[symbol] = ticker
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      tickers = self.fetch_tickers([symbol], params)
      return self.safe_value(tickers, symbol)
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades
      #
      #       {             market => "BTC-ETH",
      #             trade_date_utc => "2018-11-22",
      #             trade_time_utc => "13:55:24",
      #                  timestamp =>  1542894924397,
      #                trade_price =>  0.02914289,
      #               trade_volume =>  0.20074397,
      #         prev_closing_price =>  0.02966,
      #               change_price =>  -0.00051711,
      #                    ask_bid => "ASK",
      #              sequential_id =>  15428949259430000 }
      #
      # fetchOrder
      #
      #         {
      #             "market" => "KRW-BTC",
      #             "uuid" => "78162304-1a4d-4524-b9e6-c9a9e14d76c3",
      #             "price" => "101000.0",
      #             "volume" => "0.77368323",
      #             "funds" => "78142.00623",
      #             "ask_fee" => "117.213009345",
      #             "bid_fee" => "117.213009345",
      #             "created_at" => "2018-04-05T14:09:15+09:00",
      #             "side" => "bid",
      #         }
      #
      id = self.safe_string_2(trade, 'sequential_id', 'uuid')
      orderId = nil
      timestamp = self.safe_integer(trade, 'timestamp')
      if timestamp.nil?
        timestamp = self.parse8601(self.safe_string(trade, 'created_at'))
      end
      side = nil
      askOrBid = self.safe_string_2(trade, 'ask_bid', 'side')
      if askOrBid != nil
        askOrBid = askOrBid.downcase
      end
      if askOrBid == 'ask'
        side = 'sell'
      elsif askOrBid == 'bid'
        side = 'buy'
      end
      cost = self.safe_float(trade, 'funds')
      price = self.safe_float_2(trade, 'trade_price', 'price')
      amount = self.safe_float_2(trade, 'trade_volume', 'volume')
      if cost.nil?
        if amount != nil
          if price != nil
            cost = price * amount
          end
        end
      end
      marketId = self.safe_string(trade, 'market')
      market = self.safe_value(self.markets_by_id, marketId)
      fee = nil
      feeCurrency = nil
      symbol = nil
      if market != nil
        symbol = market['symbol']
        feeCurrency = market['quote']
      else
        baseId, quoteId = marketId.split('-')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        feeCurrency = quote
      end
      feeCost = self.safe_string(trade, askOrBid + '_fee')
      if feeCost != nil
        fee = {
          'currency' => feeCurrency,
          'cost' => feeCost
        }
      end
      return {
        'id' => id,
        'info' => trade,
        'order' => orderId,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => 'limit',
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      if limit.nil?
        limit = 200
      end
      request = {
        'market' => market['id'],
        'count' => limit
      }
      response = self.publicGetTradesTicks(self.shallow_extend(request, params))
      #
      #     [{             market => "BTC-ETH",
      #             trade_date_utc => "2018-11-22",
      #             trade_time_utc => "13:55:24",
      #                  timestamp =>  1542894924397,
      #                trade_price =>  0.02914289,
      #               trade_volume =>  0.20074397,
      #         prev_closing_price =>  0.02966,
      #               change_price =>  -0.00051711,
      #                    ask_bid => "ASK",
      #              sequential_id =>  15428949259430000 },
      #       {             market => "BTC-ETH",
      #             trade_date_utc => "2018-11-22",
      #             trade_time_utc => "13:03:10",
      #                  timestamp =>  1542891790123,
      #                trade_price =>  0.02917,
      #               trade_volume =>  7.392,
      #         prev_closing_price =>  0.02966,
      #               change_price =>  -0.00049,
      #                    ask_bid => "ASK",
      #              sequential_id =>  15428917910540000 }  ]
      #
      return self.parse_trades(response, market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1d', since = nil, limit = nil)
      #
      #       {                  market => "BTC-ETH",
      #            candle_date_time_utc => "2018-11-22T13:47:00",
      #            candle_date_time_kst => "2018-11-22T22:47:00",
      #                   opening_price =>  0.02915963,
      #                      high_price =>  0.02915963,
      #                       low_price =>  0.02915448,
      #                     trade_price =>  0.02915448,
      #                       timestamp =>  1542894473674,
      #          candle_acc_trade_price =>  0.0981629437535248,
      #         candle_acc_trade_volume =>  3.36693173,
      #                            unit =>  1                     },
      #
      return [
        self.parse8601(self.safe_string(ohlcv, 'candle_date_time_utc')),
        self.safe_float(ohlcv, 'opening_price'),
        self.safe_float(ohlcv, 'high_price'),
        self.safe_float(ohlcv, 'low_price'),
        self.safe_float(ohlcv, 'trade_price'),
        self.safe_float(ohlcv, 'candle_acc_trade_volume'), # base volume
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      timeframePeriod = self.parse_timeframe(timeframe)
      timeframeValue = self.timeframes[timeframe]
      if limit.nil?
        limit = 200
      end
      request = {
        'market' => market['id'],
        'timeframe' => timeframeValue,
        'count' => limit
      }
      method = 'publicGetCandlesTimeframe'
      if timeframeValue == 'minutes'
        numMinutes = timeframePeriod / 60.round
        request['unit'] = numMinutes
        method += 'Unit'
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      #
      #     [{                  market => "BTC-ETH",
      #            candle_date_time_utc => "2018-11-22T13:47:00",
      #            candle_date_time_kst => "2018-11-22T22:47:00",
      #                   opening_price =>  0.02915963,
      #                      high_price =>  0.02915963,
      #                       low_price =>  0.02915448,
      #                     trade_price =>  0.02915448,
      #                       timestamp =>  1542894473674,
      #          candle_acc_trade_price =>  0.0981629437535248,
      #         candle_acc_trade_volume =>  3.36693173,
      #                            unit =>  1                     },
      #       {                  market => "BTC-ETH",
      #            candle_date_time_utc => "2018-11-22T10:06:00",
      #            candle_date_time_kst => "2018-11-22T19:06:00",
      #                   opening_price =>  0.0294,
      #                      high_price =>  0.02940882,
      #                       low_price =>  0.02934283,
      #                     trade_price =>  0.02937354,
      #                       timestamp =>  1542881219276,
      #          candle_acc_trade_price =>  0.0762597110943884,
      #         candle_acc_trade_volume =>  2.5949617,
      #                            unit =>  1                     }  ]
      #
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      if type != 'limit'
        raise(InvalidOrder, self.id + ' createOrder allows limit orders only!')
      end
      orderSide = nil
      if side == 'buy'
        orderSide = 'bid'
      elsif side == 'sell'
        orderSide = 'ask'
      else
        raise(InvalidOrder, self.id + ' createOrder allows buy or sell side only!')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'market' => market['id'],
        'side' => orderSide,
        'volume' => self.amount_to_precision(symbol, amount),
        'price' => self.price_to_precision(symbol, price),
        'ord_type' => type
      }
      response = self.privatePostOrders(self.shallow_extend(request, params))
      #
      #     {
      #         'uuid' => 'cdd92199-2897-4e14-9448-f923320408ad',
      #         'side' => 'bid',
      #         'ord_type' => 'limit',
      #         'price' => '100.0',
      #         'avg_price' => '0.0',
      #         'state' => 'wait',
      #         'market' => 'KRW-BTC',
      #         'created_at' => '2018-04-10T15:42:23+09:00',
      #         'volume' => '0.01',
      #         'remaining_volume' => '0.01',
      #         'reserved_fee' => '0.0015',
      #         'remaining_fee' => '0.0015',
      #         'paid_fee' => '0.0',
      #         'locked' => '1.0015',
      #         'executed_volume' => '0.0',
      #         'trades_count' => 0
      #     }
      #
      return self.parse_order(response)
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'uuid' => id
      }
      response = self.privateDeleteOrder(self.shallow_extend(request, params))
      #
      #     {
      #         "uuid" => "cdd92199-2897-4e14-9448-f923320408ad",
      #         "side" => "bid",
      #         "ord_type" => "limit",
      #         "price" => "100.0",
      #         "state" => "wait",
      #         "market" => "KRW-BTC",
      #         "created_at" => "2018-04-10T15:42:23+09:00",
      #         "volume" => "0.01",
      #         "remaining_volume" => "0.01",
      #         "reserved_fee" => "0.0015",
      #         "remaining_fee" => "0.0015",
      #         "paid_fee" => "0.0",
      #         "locked" => "1.0015",
      #         "executed_volume" => "0.0",
      #         "trades_count" => 0
      #     }
      #
      return self.parse_order(response)
    end

    def fetch_deposits(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {
        # 'page' => 1,
        # 'order_by' => 'asc', # 'desc'
      }
      currency = nil
      if code != nil
        currency = self.currency(code)
        request['currency'] = currency['id']
      end
      if limit != nil
        request['limit'] = limit # default is 100
      end
      response = self.privateGetDeposits(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #             "type" => "deposit",
      #             "uuid" => "94332e99-3a87-4a35-ad98-28b0c969f830",
      #             "currency" => "KRW",
      #             "txid" => "9e37c537-6849-4c8b-a134-57313f5dfc5a",
      #             "state" => "ACCEPTED",
      #             "created_at" => "2017-12-08T15:38:02+09:00",
      #             "done_at" => "2017-12-08T15:38:02+09:00",
      #             "amount" => "100000.0",
      #             "fee" => "0.0"
      #         },
      #         ...,
      #     ]
      #
      return self.parseTransactions(response, currency, since, limit)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {
        # 'state' => 'submitting', # 'submitted', 'almost_accepted', 'rejected', 'accepted', 'processing', 'done', 'canceled'
      }
      currency = nil
      if code != nil
        currency = self.currency(code)
        request['currency'] = currency['id']
      end
      if limit != nil
        request['limit'] = limit # default is 100
      end
      response = self.privateGetWithdraws(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #             "type" => "withdraw",
      #             "uuid" => "9f432943-54e0-40b7-825f-b6fec8b42b79",
      #             "currency" => "BTC",
      #             "txid" => null,
      #             "state" => "processing",
      #             "created_at" => "2018-04-13T11:24:01+09:00",
      #             "done_at" => null,
      #             "amount" => "0.01",
      #             "fee" => "0.0",
      #             "krw_amount" => "80420.0"
      #         },
      #         ...,
      #     ]
      #
      return self.parseTransactions(response, currency, since, limit)
    end

    def parse_transaction_status(status)
      statuses = {
        'ACCEPTED' => 'ok', # deposits
        # withdrawals:
        'submitting' => 'pending', # 처리 중
        'submitted' => 'pending', # 처리 완료
        'almost_accepted' => 'pending', # 출금대기중
        'rejected' => 'failed', # 거부
        'accepted' => 'pending', # 승인됨
        'processing' => 'pending', # 처리 중
        'done' => 'ok', # 완료
        'canceled' => 'canceled', # 취소됨
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchDeposits
      #
      #     {
      #         "type" => "deposit",
      #         "uuid" => "94332e99-3a87-4a35-ad98-28b0c969f830",
      #         "currency" => "KRW",
      #         "txid" => "9e37c537-6849-4c8b-a134-57313f5dfc5a",
      #         "state" => "ACCEPTED",
      #         "created_at" => "2017-12-08T15:38:02+09:00",
      #         "done_at" => "2017-12-08T15:38:02+09:00",
      #         "amount" => "100000.0",
      #         "fee" => "0.0"
      #     }
      #
      # fetchWithdrawals
      #
      #     {
      #         "type" => "withdraw",
      #         "uuid" => "9f432943-54e0-40b7-825f-b6fec8b42b79",
      #         "currency" => "BTC",
      #         "txid" => "cd81e9b45df8da29f936836e58c907a106057e454a45767a7b06fcb19b966bba",
      #         "state" => "processing",
      #         "created_at" => "2018-04-13T11:24:01+09:00",
      #         "done_at" => null,
      #         "amount" => "0.01",
      #         "fee" => "0.0",
      #         "krw_amount" => "80420.0"
      #     }
      #
      id = self.safe_string(transaction, 'uuid')
      amount = self.safe_float(transaction, 'amount')
      address = nil # not present in the data structure received from the exchange
      tag = nil # not present in the data structure received from the exchange
      txid = self.safe_string(transaction, 'txid')
      updated = self.parse8601(self.safe_string(transaction, 'done_at'))
      timestamp = self.parse8601(self.safe_string(transaction, 'created_at', updated))
      type = self.safe_string(transaction, 'type')
      if type == 'withdraw'
        type = 'withdrawal'
      end
      code = nil
      currencyId = self.safe_string(transaction, 'currency')
      currency = self.safe_value(self.currencies_by_id, currencyId)
      if currency != nil
        code = currency['code']
      else
        code = self.common_currency_code(currencyId)
      end
      status = self.parse_transaction_status(self.safe_string(transaction, 'state'))
      feeCost = self.safe_float(transaction, 'fee')
      return {
        'info' => transaction,
        'id' => id,
        'currency' => code,
        'amount' => amount,
        'address' => address,
        'tag' => tag,
        'status' => status,
        'type' => type,
        'updated' => updated,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'fee' => {
          'currency' => code,
          'cost' => feeCost
        }
      }
    end

    def parse_order_status(status)
      statuses = {
        'wait' => 'open',
        'done' => 'closed',
        'cancel' => 'canceled'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      #
      #     {
      #         "uuid" => "a08f09b1-1718-42e2-9358-f0e5e083d3ee",
      #         "side" => "bid",
      #         "ord_type" => "limit",
      #         "price" => "17417000.0",
      #         "state" => "done",
      #         "market" => "KRW-BTC",
      #         "created_at" => "2018-04-05T14:09:14+09:00",
      #         "volume" => "1.0",
      #         "remaining_volume" => "0.0",
      #         "reserved_fee" => "26125.5",
      #         "remaining_fee" => "25974.0",
      #         "paid_fee" => "151.5",
      #         "locked" => "17341974.0",
      #         "executed_volume" => "1.0",
      #         "trades_count" => 2,
      #         "trades" => [
      #             {
      #                 "market" => "KRW-BTC",
      #                 "uuid" => "78162304-1a4d-4524-b9e6-c9a9e14d76c3",
      #                 "price" => "101000.0",
      #                 "volume" => "0.77368323",
      #                 "funds" => "78142.00623",
      #                 "ask_fee" => "117.213009345",
      #                 "bid_fee" => "117.213009345",
      #                 "created_at" => "2018-04-05T14:09:15+09:00",
      #                 "side" => "bid",
      #             },
      #             {
      #                 "market" => "KRW-BTC",
      #                 "uuid" => "f73da467-c42f-407d-92fa-e10d86450a20",
      #                 "price" => "101000.0",
      #                 "volume" => "0.22631677",
      #                 "funds" => "22857.99377",
      #                 "ask_fee" => "34.286990655",
      #                 "bid_fee" => "34.286990655",
      #                 "created_at" => "2018-04-05T14:09:15+09:00",
      #                 "side" => "bid",
      #             },
      #         ],
      #     }
      #
      id = self.safe_string(order, 'uuid')
      side = self.safe_string(order, 'side')
      if side == 'bid'
        side = 'buy'
      else
        side = 'sell'
      end
      type = self.safe_string(order, 'ord_type')
      timestamp = self.parse8601(self.safe_string(order, 'created_at'))
      status = self.parse_order_status(self.safe_string(order, 'state'))
      lastTradeTimestamp = nil
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'volume')
      remaining = self.safe_float(order, 'remaining_volume')
      filled = self.safe_float(order, 'executed_volume')
      cost = nil
      average = price # they support limit orders only for now
      if cost.nil?
        if (price != nil) && (filled != nil)
          cost = price * filled
        end
      end
      orderTrades = self.safe_value(order, 'trades')
      trades = nil
      if orderTrades != nil
        trades = self.parse_trades(orderTrades)
      end
      fee = nil
      feeCost = self.safe_float(order, 'paid_fee')
      feeCurrency = nil
      marketId = self.safe_string(order, 'market')
      market = self.safe_value(self.markets_by_id, marketId)
      symbol = nil
      if market != nil
        symbol = market['symbol']
        feeCurrency = market['quote']
      else
        baseId, quoteId = marketId.split('-')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        feeCurrency = quote
      end
      if trades != nil
        numTrades = trades.length
        if numTrades > 0
          if lastTradeTimestamp.nil?
            lastTradeTimestamp = trades[numTrades - 1]['timestamp']
          end
          if feeCost.nil?
            for i in (0...numTrades)
              tradeFee = self.safe_value(trades[i], 'fee', {})
              tradeFeeCost = self.safe_float(tradeFee, 'cost')
              if tradeFeeCost != nil
                if feeCost.nil?
                  feeCost = 0
                end
                feeCost = self.sum(feeCost, tradeFeeCost)
              end
            end
          end
        end
      end
      if feeCost != nil
        fee = {
          'currency' => feeCurrency,
          'cost' => feeCost
        }
      end
      result = {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => lastTradeTimestamp,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'average' => average,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee,
        'trades' => trades
      }
      return result
    end

    def fetch_orders_by_state(state, symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {
        # 'market' => self.market_id(symbol),
        'state' => state,
        # 'page' => 1,
        # 'order_by' => 'asc'
      }
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['market'] = market['id']
      end
      response = self.privateGetOrders(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #             "uuid" => "a08f09b1-1718-42e2-9358-f0e5e083d3ee",
      #             "side" => "bid",
      #             "ord_type" => "limit",
      #             "price" => "17417000.0",
      #             "state" => "done",
      #             "market" => "KRW-BTC",
      #             "created_at" => "2018-04-05T14:09:14+09:00",
      #             "volume" => "1.0",
      #             "remaining_volume" => "0.0",
      #             "reserved_fee" => "26125.5",
      #             "remaining_fee" => "25974.0",
      #             "paid_fee" => "151.5",
      #             "locked" => "17341974.0",
      #             "executed_volume" => "1.0",
      #             "trades_count":2
      #         },
      #     ]
      #
      return self.parse_orders(response, market, since, limit)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_state('wait', symbol, since, limit, params)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_state('done', symbol, since, limit, params)
    end

    def fetch_canceled_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_state('cancel', symbol, since, limit, params)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      request = {
        'uuid' => id
      }
      response = self.privateGetOrder(self.shallow_extend(request, params))
      #
      #     {
      #         "uuid" => "a08f09b1-1718-42e2-9358-f0e5e083d3ee",
      #         "side" => "bid",
      #         "ord_type" => "limit",
      #         "price" => "17417000.0",
      #         "state" => "done",
      #         "market" => "KRW-BTC",
      #         "created_at" => "2018-04-05T14:09:14+09:00",
      #         "volume" => "1.0",
      #         "remaining_volume" => "0.0",
      #         "reserved_fee" => "26125.5",
      #         "remaining_fee" => "25974.0",
      #         "paid_fee" => "151.5",
      #         "locked" => "17341974.0",
      #         "executed_volume" => "1.0",
      #         "trades_count" => 2,
      #         "trades" => [
      #             {
      #                 "market" => "KRW-BTC",
      #                 "uuid" => "78162304-1a4d-4524-b9e6-c9a9e14d76c3",
      #                 "price" => "101000.0",
      #                 "volume" => "0.77368323",
      #                 "funds" => "78142.00623",
      #                 "ask_fee" => "117.213009345",
      #                 "bid_fee" => "117.213009345",
      #                 "created_at" => "2018-04-05T14:09:15+09:00",
      #                 "side" => "bid"
      #             },
      #             {
      #                 "market" => "KRW-BTC",
      #                 "uuid" => "f73da467-c42f-407d-92fa-e10d86450a20",
      #                 "price" => "101000.0",
      #                 "volume" => "0.22631677",
      #                 "funds" => "22857.99377",
      #                 "ask_fee" => "34.286990655",
      #                 "bid_fee" => "34.286990655",
      #                 "created_at" => "2018-04-05T14:09:15+09:00",
      #                 "side" => "bid"
      #             }
      #         ]
      #     }
      #
      return self.parse_order(response)
    end

    def parse_deposit_addresses(addresses)
      result = []
      for i in (0...addresses.length)
        result.push(self.parse_deposit_address(addresses[i]))
      end
      return result
    end

    def fetch_deposit_addresses(codes = nil, params = {})
      self.load_markets
      response = self.privateGetDepositsCoinAddresses(params)
      #
      #     [
      #         {
      #             "currency" => "BTC",
      #             "deposit_address" => "3EusRwybuZUhVDeHL7gh3HSLmbhLcy7NqD",
      #             "secondary_address" => null
      #         },
      #         {
      #             "currency" => "ETH",
      #             "deposit_address" => "0x0d73e0a482b8cf568976d2e8688f4a899d29301c",
      #             "secondary_address" => null
      #         },
      #         {
      #             "currency" => "XRP",
      #             "deposit_address" => "rN9qNpgnBaZwqCg8CvUZRPqCcPPY7wfWep",
      #             "secondary_address" => "3057887915"
      #         }
      #     ]
      #
      return self.parse_deposit_addresses(response)
    end

    def parse_deposit_address(depositAddress, currency = nil)
      #
      #     {
      #         "currency" => "BTC",
      #         "deposit_address" => "3EusRwybuZUhVDeHL7gh3HSLmbhLcy7NqD",
      #         "secondary_address" => null
      #     }
      #
      address = self.safe_string(depositAddress, 'deposit_address')
      tag = self.safe_string(depositAddress, 'secondary_address')
      code = self.common_currency_code(self.safe_string(depositAddress, 'currency'))
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => depositAddress
      }
    end

    def fetch_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      response = self.privateGetDepositsCoinAddress(self.shallow_extend({
        'currency' => currency['id']
      }, params))
      #
      #     {
      #         "currency" => "BTC",
      #         "deposit_address" => "3EusRwybuZUhVDeHL7gh3HSLmbhLcy7NqD",
      #         "secondary_address" => null
      #     }
      #
      return self.parse_deposit_address(response)
    end

    def create_deposit_address(code, params = {})
      self.load_markets
      currency = self.currency(code)
      request = {
        'currency' => currency['id']
      }
      response = self.fetch_deposit_address(code, self.shallow_extend(request, params))
      #
      # https://docs.upbit.com/v1.0/reference#%EC%9E%85%EA%B8%88-%EC%A3%BC%EC%86%8C-%EC%83%9D%EC%84%B1-%EC%9A%94%EC%B2%AD
      # can be any of the two responses:
      #
      #     {
      #         "success" : true,
      #         "message" : "Creating BTC deposit address."
      #     }
      #
      #     {
      #         "currency" => "BTC",
      #         "deposit_address" => "3EusRwybuZUhVDeHL7gh3HSLmbhLcy7NqD",
      #         "secondary_address" => null
      #     }
      #
      message = self.safe_string(response, 'message')
      if message != nil
        return {
          'currency' => code,
          'address' => nil,
          'tag' => nil,
          'info' => response
        }
      end
      return self.parse_deposit_address(response)
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      self.load_markets
      currency = self.currency(code)
      request = {
        'amount' => amount
      }
      method = 'privatePostWithdraws'
      if code != 'KRW'
        method += 'Coin'
        request['currency'] = currency['id']
        request['address'] = address
        if tag != nil
          request['secondary_address'] = tag
        end
      else
        method += 'Krw'
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      #
      #     {
      #         "type" => "withdraw",
      #         "uuid" => "9f432943-54e0-40b7-825f-b6fec8b42b79",
      #         "currency" => "BTC",
      #         "txid" => "ebe6937b-130e-4066-8ac6-4b0e67f28adc",
      #         "state" => "processing",
      #         "created_at" => "2018-04-13T11:24:01+09:00",
      #         "done_at" => null,
      #         "amount" => "0.01",
      #         "fee" => "0.0",
      #         "krw_amount" => "80420.0"
      #     }
      #
      return self.parse_transaction(response)
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + self.version + '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if method == 'GET'
        if query
          url += '?' + self.urlencode(query)
        end
      end
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce
        request = {
          'access_key' => self.apiKey,
          'nonce' => nonce
        }
        if query
          request['query'] = self.urlencode(query)
        end
        jwt = self.jwt(request, self.secret)
        headers = {
          'Authorization' => 'Bearer ' + jwt
        }
        if method != 'GET'
          body = self.json(params)
          headers['Content-Type'] = 'application/json'
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if response.nil?
        return
      end # fallback to default error handler
      #
      #   { 'error' => { 'message' => "Missing request parameter error. Check the required parameters!", 'name' =>  400 } },
      #   { 'error' => { 'message' => "side is missing, side does not have a valid value", 'name' => "validation_error" } },
      #   { 'error' => { 'message' => "개인정보 제 3자 제공 동의가 필요합니다.", 'name' => "thirdparty_agreement_required" } },
      #   { 'error' => { 'message' => "권한이 부족합니다.", 'name' => "out_of_scope" } },
      #   { 'error' => { 'message' => "주문을 찾지 못했습니다.", 'name' => "order_not_found" } },
      #   { 'error' => { 'message' => "주문가능한 금액(ETH)이 부족합니다.", 'name' => "insufficient_funds_ask" } },
      #   { 'error' => { 'message' => "주문가능한 금액(BTC)이 부족합니다.", 'name' => "insufficient_funds_bid" } },
      #   { 'error' => { 'message' => "잘못된 엑세스 키입니다.", 'name' => "invalid_access_key" } },
      #   { 'error' => { 'message' => "Jwt 토큰 검증에 실패했습니다.", 'name' => "jwt_verification" } }
      #
      error = self.safe_value(response, 'error')
      if error != nil
        message = self.safe_string(error, 'message')
        name = self.safe_string(error, 'name')
        feedback = self.id + ' ' + self.json(response)
        exact = self.exceptions['exact']
        if exact.include?(message)
          raise(exact[message], feedback)
        end
        if exact.include?(name)
          raise(exact[name], feedback)
        end
        broad = self.exceptions['broad']
        broadKey = self.findBroadlyMatchedKey(broad, message)
        if broadKey != nil
          raise(broad[broadKey], feedback)
        end
        broadKey = self.findBroadlyMatchedKey(broad, name)
        if broadKey != nil
          raise(broad[broadKey], feedback)
        end
        raise(ExchangeError, feedback) # unknown message
      end
    end
  end
end
