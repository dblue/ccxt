# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Bitstamp < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'bitstamp',
        'name' => 'Bitstamp',
        'countries' => ['GB'],
        'rateLimit' => 1000,
        'version' => 'v2',
        'has' => {
          'CORS' => true,
          'fetchDepositAddress' => true,
          'fetchOrder' => 'emulated',
          'fetchOpenOrders' => true,
          'fetchMyTrades' => true,
          'fetchTransactions' => true,
          'fetchWithdrawals' => true,
          'withdraw' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
          'api' => 'https://www.bitstamp.net/api',
          'www' => 'https://www.bitstamp.net',
          'doc' => 'https://www.bitstamp.net/api'
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true,
          'uid' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'order_book/{pair}/',
              'ticker_hour/{pair}/',
              'ticker/{pair}/',
              'transactions/{pair}/',
              'trading-pairs-info/'
            ]
          },
          'private' => {
            'post' => [
              'balance/',
              'balance/{pair}/',
              'bch_withdrawal/',
              'bch_address/',
              'user_transactions/',
              'user_transactions/{pair}/',
              'open_orders/all/',
              'open_orders/{pair}/',
              'order_status/',
              'cancel_order/',
              'buy/{pair}/',
              'buy/market/{pair}/',
              'buy/instant/{pair}/',
              'sell/{pair}/',
              'sell/market/{pair}/',
              'sell/instant/{pair}/',
              'ltc_withdrawal/',
              'ltc_address/',
              'eth_withdrawal/',
              'eth_address/',
              'xrp_withdrawal/',
              'xrp_address/',
              'transfer-to-main/',
              'transfer-from-main/',
              'withdrawal-requests/',
              'withdrawal/open/',
              'withdrawal/status/',
              'withdrawal/cancel/',
              'liquidation_address/new/',
              'liquidation_address/info/'
            ]
          },
          'v1' => {
            'post' => [
              'bitcoin_deposit_address/',
              'unconfirmed_btc/',
              'bitcoin_withdrawal/',
              'ripple_withdrawal/',
              'ripple_address/'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'percentage' => true,
            'taker' => 0.25 / 100,
            'maker' => 0.25 / 100,
            'tiers' => {
              'taker' => [
                [0, 0.25 / 100],
                [20000, 0.24 / 100],
                [100000, 0.22 / 100],
                [400000, 0.20 / 100],
                [600000, 0.15 / 100],
                [1000000, 0.14 / 100],
                [2000000, 0.13 / 100],
                [4000000, 0.12 / 100],
                [20000000, 0.11 / 100],
                [20000001, 0.10 / 100]
              ],
              'maker' => [
                [0, 0.25 / 100],
                [20000, 0.24 / 100],
                [100000, 0.22 / 100],
                [400000, 0.20 / 100],
                [600000, 0.15 / 100],
                [1000000, 0.14 / 100],
                [2000000, 0.13 / 100],
                [4000000, 0.12 / 100],
                [20000000, 0.11 / 100],
                [20000001, 0.10 / 100]
              ]
            }
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {
              'BTC' => 0,
              'BCH' => 0,
              'LTC' => 0,
              'ETH' => 0,
              'XRP' => 0,
              'USD' => 25,
              'EUR' => 0.90
            },
            'deposit' => {
              'BTC' => 0,
              'BCH' => 0,
              'LTC' => 0,
              'ETH' => 0,
              'XRP' => 0,
              'USD' => 25,
              'EUR' => 0
            }
          }
        },
        'exceptions' => {
          'exact' => {
            'No permission found' => PermissionDenied,
            'API key not found' => AuthenticationError,
            'IP address not allowed' => PermissionDenied,
            'Invalid nonce' => InvalidNonce,
            'Invalid signature' => AuthenticationError,
            'Authentication failed' => AuthenticationError,
            'Missing key, signature and nonce parameters' => AuthenticationError,
            'Your account is frozen' => PermissionDenied,
            'Please update your profile with your FATCA information, before using API.' => PermissionDenied,
            'Order not found' => OrderNotFound
          },
          'broad' => {
            'Check your account balance for details.' => InsufficientFunds, # You have only 0.00100000 BTC available. Check your account balance for details.
            'Ensure self value has at least' => InvalidAddress, # Ensure self value has at least 25 characters(it has 4).
          }
        }
      })
    end

    def fetch_markets(params = {})
      markets = self.publicGetTradingPairsInfo
      result = []
      for i in (0...markets.length)
        market = markets[i]
        symbol = market['name']
        base, quote = symbol.split('/')
        baseId = base.downcase
        quoteId = quote.downcase
        symbolId = baseId + '_' + quoteId
        id = market['url_symbol']
        precision = {
          'amount' => market['base_decimals'],
          'price' => market['counter_decimals']
        }
        parts = market['minimum_order'].split(' ')
        cost = parts[0]
        # cost, currency = market['minimum_order'].split(' ')
        active = (market['trading'] == 'Enabled')
        result.push({
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'symbolId' => symbolId,
          'info' => market,
          'active' => active,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => 10**-precision['amount'],
              'max' => nil
            },
            'price' => {
              'min' => 10**-precision['price'],
              'max' => nil
            },
            'cost' => {
              'min' => parse_float(cost),
              'max' => nil
            }
          }
        })
      end
      return result
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      orderbook = self.publicGetOrderBookPair(self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      timestamp = parse_int(orderbook['timestamp']) * 1000
      return self.parse_order_book(orderbook, timestamp)
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      ticker = self.publicGetTickerPair(self.shallow_extend({
        'pair' => self.market_id(symbol)
      }, params))
      timestamp = parse_int(ticker['timestamp']) * 1000
      vwap = self.safe_float(ticker, 'vwap')
      baseVolume = self.safe_float(ticker, 'volume')
      quoteVolume = nil
      if baseVolume != nil && vwap != nil
        quoteVolume = baseVolume * vwap
      end
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'askVolume' => nil,
        'vwap' => vwap,
        'open' => self.safe_float(ticker, 'open'),
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => baseVolume,
        'quoteVolume' => quoteVolume,
        'info' => ticker
      }
    end

    def get_currency_id_from_transaction(transaction)
      #
      #     {
      #         "fee" => "0.00000000",
      #         "btc_usd" => "0.00",
      #         "datetime" => XXX,
      #         "usd" => 0.0,
      #         "btc" => 0.0,
      #         "eth" => "0.05000000",
      #         "type" => "0",
      #         "id" => XXX,
      #         "eur" => 0.0
      #     }
      #
      if transaction.include?('currency')
        return transaction['currency'].downcase
      end
      transaction = self.omit(transaction, [
        'fee',
        'price',
        'datetime',
        'type',
        'status',
        'id'
      ])
      ids = transaction.keys
      for i in (0...ids.length)
        id = ids[i]
        if id.include?($2) < 0
          value = self.safe_float(transaction, id)
          if (value != nil) && (value != 0)
            return id
          end
        end
      end
      return nil
    end

    def get_market_from_trade(trade)
      trade = self.omit(trade, [
        'fee',
        'price',
        'datetime',
        'tid',
        'type',
        'order_id',
        'side'
      ])
      currencyIds = trade.keys
      numCurrencyIds = currencyIds.length
      if numCurrencyIds > 2
        raise(ExchangeError, self.id + ' getMarketFromTrade too many keys => ' + self.json(currencyIds) + ' in the trade => ' + self.json(trade))
      end
      if numCurrencyIds == 2
        marketId = currencyIds[0] + currencyIds[1]
        if self.markets_by_id.include?(marketId)
          return self.markets_by_id[marketId]
        end
        marketId = currencyIds[1] + currencyIds[0]
        if self.markets_by_id.include?(marketId)
          return self.markets_by_id[marketId]
        end
      end
      return nil
    end

    def get_market_from_trades(trades)
      tradesBySymbol = self.index_by(trades, 'symbol')
      symbols = tradesBySymbol.keys
      numSymbols = symbols.length
      if numSymbols == 1
        return self.markets[symbols[0]]
      end
      return nil
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #     {
      #         date => '1551814435',
      #         tid => '83581898',
      #         price => '0.03532850',
      #         type => '1',
      #         amount => '0.85945907'
      #     },
      #
      # fetchMyTrades, trades returned within fetchOrder(private)
      #
      #     {
      #         "usd" => "6.0134400000000000",
      #         "price" => "4008.96000000",
      #         "datetime" => "2019-03-28 23:07:37.233599",
      #         "fee" => "0.02",
      #         "btc" => "0.00150000",
      #         "tid" => 84452058,
      #         "type" => 2
      #     }
      #
      id = self.safe_string_2(trade, 'id', 'tid')
      symbol = nil
      side = nil
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'amount')
      orderId = self.safe_string(trade, 'order_id')
      type = nil
      cost = self.safe_float(trade, 'cost')
      if market.nil?
        keys = trade.keys
        for i in (0...keys.length)
          if keys[i].include?('_')
            marketId = keys[i].gsub('_', '')
            if self.markets_by_id.include?(marketId)
              market = self.markets_by_id[marketId]
            end
          end
        end
        # if the market is still not defined
        # try to deduce it from used keys
        if market.nil?
          market = self.get_market_from_trade(trade)
        end
      end
      feeCost = self.safe_float(trade, 'fee')
      feeCurrency = nil
      if market != nil
        price = self.safe_float(trade, market['symbolId'], price)
        amount = self.safe_float(trade, market['baseId'], amount)
        cost = self.safe_float(trade, market['quoteId'], cost)
        feeCurrency = market['quote']
        symbol = market['symbol']
      end
      timestamp = self.safe_string_2(trade, 'date', 'datetime')
      if timestamp != nil
        if timestamp.include?(' ')
          # iso8601
          timestamp = self.parse8601(timestamp)
        else
          # string unix epoch in seconds
          timestamp = parse_int(timestamp)
          timestamp = timestamp * 1000
        end
      end
      # if it is a private trade
      if trade.include?('id')
        if amount != nil
          if amount < 0
            side = 'sell'
            amount = -amount
          else
            side = 'buy'
          end
        end
      else
        side = self.safe_string(trade, 'type')
        if side == '1'
          side = 'sell'
        elsif side == '0'
          side = 'buy'
        end
      end
      if cost.nil?
        if price != nil
          if amount != nil
            cost = price * amount
          end
        end
      end
      if cost != nil
        cost = cost.abs
      end
      fee = nil
      if feeCost != nil
        fee = {
          'cost' => feeCost,
          'currency' => feeCurrency
        }
      end
      return {
        'id' => id,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'order' => orderId,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'fee' => fee
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetTransactionsPair(self.shallow_extend({
        'pair' => market['id'],
        'time' => 'hour'
      }, params))
      #
      #     [
      #         {
      #             date => '1551814435',
      #             tid => '83581898',
      #             price => '0.03532850',
      #             type => '1',
      #             amount => '0.85945907'
      #         },
      #         {
      #             date => '1551814434',
      #             tid => '83581896',
      #             price => '0.03532851',
      #             type => '1',
      #             amount => '11.34130961'
      #         },
      #     ]
      #
      return self.parse_trades(response, market, since, limit)
    end

    def fetch_balance(params = {})
      self.load_markets
      balance = self.privatePostBalance
      result = { 'info' => balance }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        lowercase = currency.downcase
        total = lowercase + '_balance'
        free = lowercase + '_available'
        used = lowercase + '_reserved'
        account = self.account
        if balance.include?(free)
          account['free'] = parse_float(balance[free])
        end
        if balance.include?(used)
          account['used'] = parse_float(balance[used])
        end
        if balance.include?(total)
          account['total'] = parse_float(balance[total])
        end
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      method = 'privatePost' + self.capitalize(side)
      request = {
        'pair' => market['id'],
        'amount' => self.amount_to_precision(symbol, amount)
      }
      if type == 'market'
        method += 'Market'
      else
        request['price'] = self.price_to_precision(symbol, price)
      end
      method += 'Pair'
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      order = self.parse_order(response, market)
      return self.shallow_extend(order, {
        'type' => type
      })
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privatePostCancelOrder({ 'id' => id })
    end

    def parse_order_status(status)
      statuses = {
        'In Queue' => 'open',
        'Open' => 'open',
        'Finished' => 'closed',
        'Canceled' => 'canceled'
      }
      return(statuses.include?(status)) ? statuses[status] : status
    end

    def fetch_order_status(id, symbol = nil, params = {})
      self.load_markets
      request = { 'id' => id }
      response = self.privatePostOrderStatus(self.shallow_extend(request, params))
      return self.parse_order_status(self.safe_string(response, 'status'))
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      request = { 'id' => id }
      response = self.privatePostOrderStatus(self.shallow_extend(request, params))
      #
      #     {
      #         "status" => "Finished",
      #         "id" => 3047704374,
      #         "transactions" => [
      #             {
      #                 "usd" => "6.0134400000000000",
      #                 "price" => "4008.96000000",
      #                 "datetime" => "2019-03-28 23:07:37.233599",
      #                 "fee" => "0.02",
      #                 "btc" => "0.00150000",
      #                 "tid" => 84452058,
      #                 "type" => 2
      #             }
      #         ]
      #     }
      return self.parse_order(response, market)
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      method = 'privatePostUserTransactions'
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['pair'] = market['id']
        method += 'Pair'
      end
      if limit != nil
        request['limit'] = limit
      end
      response = self.send_wrapper(method, self.shallow_extend(request, params))
      result = self.filter_by(response, 'type', '2')
      return self.parse_trades(result, market, since, limit)
    end

    def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      if limit != nil
        request['limit'] = limit
      end
      response = self.privatePostUserTransactions(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #             "fee" => "0.00000000",
      #             "btc_usd" => "0.00",
      #             "id" => 1234567894,
      #             "usd" => 0,
      #             "btc" => 0,
      #             "datetime" => "2018-09-08 09:00:31",
      #             "type" => "1",
      #             "xrp" => "-20.00000000",
      #             "eur" => 0,
      #         },
      #         {
      #             "fee" => "0.00000000",
      #             "btc_usd" => "0.00",
      #             "id" => 1134567891,
      #             "usd" => 0,
      #             "btc" => 0,
      #             "datetime" => "2018-09-07 18:47:52",
      #             "type" => "0",
      #             "xrp" => "20.00000000",
      #             "eur" => 0,
      #         },
      #     ]
      #
      currency = nil
      if code != nil
        currency = self.currency(code)
      end
      transactions = self.filter_by_array(response, 'type', ['0', '1'], false)
      return self.parseTransactions(transactions, currency, since, limit)
    end

    def fetch_withdrawals(code = nil, since = nil, limit = nil, params = {})
      self.load_markets
      request = {}
      if since != nil
        request['timedelta'] = self.milliseconds - since
      end
      response = self.privatePostWithdrawalRequests(self.shallow_extend(request, params))
      #
      #     [
      #         {
      #             status => 2,
      #             datetime => '2018-10-17 10:58:13',
      #             currency => 'BTC',
      #             amount => '0.29669259',
      #             address => 'aaaaa',
      #             type => 1,
      #             id => 111111,
      #             transaction_id => 'xxxx',
      #         },
      #         {
      #             status => 2,
      #             datetime => '2018-10-17 10:55:17',
      #             currency => 'ETH',
      #             amount => '1.11010664',
      #             address => 'aaaa',
      #             type => 16,
      #             id => 222222,
      #             transaction_id => 'xxxxx',
      #         },
      #     ]
      #
      return self.parseTransactions(response, nil, since, limit)
    end

    def parse_transaction(transaction, currency = nil)
      #
      # fetchTransactions
      #
      #     {
      #         "fee" => "0.00000000",
      #         "btc_usd" => "0.00",
      #         "id" => 1234567894,
      #         "usd" => 0,
      #         "btc" => 0,
      #         "datetime" => "2018-09-08 09:00:31",
      #         "type" => "1",
      #         "xrp" => "-20.00000000",
      #         "eur" => 0,
      #     }
      #
      # fetchWithdrawals
      #
      #     {
      #         status => 2,
      #         datetime => '2018-10-17 10:58:13',
      #         currency => 'BTC',
      #         amount => '0.29669259',
      #         address => 'aaaaa',
      #         type => 1,
      #         id => 111111,
      #         transaction_id => 'xxxx',
      #     }
      #
      timestamp = self.parse8601(self.safe_string(transaction, 'datetime'))
      code = nil
      id = self.safe_string(transaction, 'id')
      currencyId = self.get_currency_id_from_transaction(transaction)
      if self.currencies_by_id.include?(currencyId)
        currency = self.currencies_by_id[currencyId]
      elsif currencyId != nil
        code = currencyId.upcase
        code = self.common_currency_code(code)
      end
      feeCost = self.safe_float(transaction, 'fee')
      feeCurrency = nil
      amount = nil
      if currency != nil
        amount = self.safe_float(transaction, currency['id'], amount)
        feeCurrency = currency['code']
        code = currency['code']
      elsif (code != nil) && (currencyId != nil)
        amount = self.safe_float(transaction, currencyId, amount)
        feeCurrency = code
      end
      if amount != nil
        # withdrawals have a negative amount
        amount = amount.abs
      end
      status = self.parse_transaction_status_by_type(self.safe_string(transaction, 'status'))
      type = self.safe_string(transaction, 'type')
      if status.nil?
        if type == '0'
          type = 'deposit'
        elsif type == '1'
          type = 'withdrawal'
        end
      else
        type = 'withdrawal'
      end
      txid = self.safe_string(transaction, 'transaction_id')
      address = self.safe_string(transaction, 'address')
      tag = nil # not documented
      return {
        'info' => transaction,
        'id' => id,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => address,
        'tag' => tag,
        'type' => type,
        'amount' => amount,
        'currency' => code,
        'status' => status,
        'updated' => nil,
        'fee' => {
          'currency' => feeCurrency,
          'cost' => feeCost,
          'rate' => nil
        }
      }
    end

    def parse_transaction_status_by_type(status)
      # withdrawals:
      # 0(open), 1(in process), 2(finished), 3(canceled) or 4(failed).
      statuses = {
        '0' => 'pending', # Open
        '1' => 'pending', # In process
        '2' => 'ok', # Finished
        '3' => 'canceled', # Canceled
        '4' => 'failed', # Failed
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      #
      #     {
      #         price => '0.00008012',
      #         currency_pair => 'XRP/BTC',
      #         datetime => '2019-01-31 21:23:36',
      #         amount => '15.00000000',
      #         type => '0',
      #         id => '2814205012'
      #     }
      #
      id = self.safe_string(order, 'id')
      side = self.safe_string(order, 'type')
      if side != nil
        side = (side == '1') ? 'sell' : 'buy'
      end
      timestamp = self.parse8601(self.safe_string(order, 'datetime'))
      symbol = nil
      marketId = self.safe_string(order, 'currency_pair')
      if marketId != nil
        marketId = marketId.gsub('/', '')
        marketId = marketId.downcase
        if self.markets_by_id.include?(marketId)
          market = self.markets_by_id[marketId]
          symbol = market['symbol']
        end
      end
      amount = self.safe_float(order, 'amount')
      filled = 0.0
      trades = []
      transactions = self.safe_value(order, 'transactions')
      feeCost = nil
      cost = nil
      if transactions != nil
        if transactions.is_a?(Array)
          feeCost = 0.0
          for i in (0...transactions.length)
            trade = self.parse_trade(self.shallow_extend({
              'order_id' => id,
              'side' => side
            }, transactions[i]), market)
            filled += trade['amount']
            feeCost += trade['fee']['cost']
            if cost.nil?
              cost = 0.0
            end
            cost += trade['cost']
            trades.push(trade)
          end
        end
      end
      status = self.parse_order_status(self.safe_string(order, 'status'))
      if (status == 'closed') && (amount.nil?)
        amount = filled
      end
      remaining = nil
      if amount != nil
        remaining = amount - filled
      end
      price = self.safe_float(order, 'price')
      if market.nil?
        market = self.get_market_from_trades(trades)
      end
      feeCurrency = nil
      if market != nil
        if symbol.nil?
          symbol = market['symbol']
        end
        feeCurrency = market['quote']
      end
      if cost.nil?
        if price != nil
          cost = price * filled
        end
      elsif price.nil?
        if filled > 0
          price = cost / filled
        end
      end
      fee = nil
      if feeCost != nil
        if feeCurrency != nil
          fee = {
            'cost' => feeCost,
            'currency' => feeCurrency
          }
        end
      end
      return {
        'id' => id,
        'datetime' => self.iso8601(timestamp),
        'timestamp' => timestamp,
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => nil,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'trades' => trades,
        'fee' => fee,
        'info' => order
      }
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      market = nil
      self.load_markets
      if symbol != nil
        market = self.market(symbol)
      end
      response = self.privatePostOpenOrdersAll(params)
      #     [
      #         {
      #             price => '0.00008012',
      #             currency_pair => 'XRP/BTC',
      #             datetime => '2019-01-31 21:23:36',
      #             amount => '15.00000000',
      #             type => '0',
      #             id => '2814205012',
      #         }
      #     ]
      #
      result = []
      for i in (0...response.length)
        order = self.parse_order(response[i], market)
        result.push(self.shallow_extend(order, {
          'status' => 'open',
          'type' => 'limit'
        }))
      end
      if symbol.nil?
        return self.filter_by_since_limit(result, since, limit)
      end
      return self.filter_by_symbol_since_limit(result, symbol, since, limit)
    end

    def get_currency_name(code)
      if code == 'BTC'
        return 'bitcoin'
      end
      return code.downcase
    end

    def is_fiat(code)
      if code == 'USD'
        return true
      end
      if code == 'EUR'
        return true
      end
      return false
    end

    def fetch_deposit_address(code, params = {})
      if self.is_fiat(code)
        raise(NotSupported, self.id + ' fiat fetchDepositAddress for ' + code + ' is not implemented yet')
      end
      name = self.get_currency_name(code)
      v1 = (code == 'BTC')
      method = v1 ? 'v1' : 'private' # v1 or v2
      method += 'Post' + self.capitalize(name)
      method += v1 ? 'Deposit' : ''
      method += 'Address'
      response = self.send_wrapper(method, params)
      address = v1 ? response : self.safe_string(response, 'address')
      tag = v1 ? nil : self.safe_string(response, 'destination_tag')
      self.check_address(address)
      return {
        'currency' => code,
        'address' => address,
        'tag' => tag,
        'info' => response
      }
    end

    def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      if self.is_fiat(code)
        raise(NotSupported, self.id + ' fiat withdraw for ' + code + ' is not implemented yet')
      end
      name = self.get_currency_name(code)
      request = {
        'amount' => amount,
        'address' => address
      }
      v1 = (code == 'BTC')
      method = v1 ? 'v1' : 'private' # v1 or v2
      method += 'Post' + self.capitalize(name) + 'Withdrawal'
      query = params
      if code == 'XRP'
        if tag != nil
          request['destination_tag'] = tag
          query = self.omit(params, 'destination_tag')
        else
          raise(ExchangeError, self.id + ' withdraw requires a destination_tag param for ' + code)
        end
      end
      response = self.send_wrapper(method, self.shallow_extend(request, query))
      return {
        'info' => response,
        'id' => response['id']
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/'
      if api != 'v1'
        url += self.version + '/'
      end
      url += self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if api == 'public'
        if query
          url += '?' + self.urlencode(query)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        auth = nonce + self.uid + self.apiKey
        signature = self.encode(self.hmac(self.encode(auth), self.encode(self.secret)))
        query = self.shallow_extend({
          'key' => self.apiKey,
          'signature' => signature.upcase,
          'nonce' => nonce
        }, query)
        body = self.urlencode(query)
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(httpCode, reason, url, method, headers, body, response)
      if response.nil?
        return
      end
      # fetchDepositAddress returns {"error" => "No permission found"} on apiKeys that don't have the permission required
      status = self.safe_string(response, 'status')
      error = self.safe_value(response, 'error')
      if status == 'error' || error
        errors = []
        if error.is_a?(String)
          errors.push(error)
        else
          keys = error.keys
          for i in (0...keys.length)
            key = keys[i]
            value = self.safe_value(error, key)
            if value.is_a?(Array)
              errors = self.array_concat(errors, value)
            else
              errors.push(value)
            end
          end
        end
        reason = self.safe_value(response, 'reason', {})
        all = self.safe_value(reason, '__all__')
        if all != nil
          if all.is_a?(Array)
            for i in (0...all.length)
              errors.push(all[i])
            end
          end
        end
        code = self.safe_string(response, 'code')
        if code == 'API0005'
          raise(AuthenticationError, self.id + ' invalid signature, use the uid for the main account if you have subaccounts')
        end
        exact = self.exceptions['exact']
        broad = self.exceptions['broad']
        feedback = self.id + ' ' + body
        for i in (0...errors.length)
          value = errors[i]
          if exact.include?(value)
            raise(exact[value], feedback)
          end
          broadKey = self.findBroadlyMatchedKey(broad, value)
          if broadKey != nil
            raise(broad[broadKey], feedback)
          end
        end
        raise(ExchangeError, feedback)
      end
    end
  end
end
