# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coss < Exchange
    def describe
      return self.class.deep_extend(super, {
        'id' => 'coss',
        'name' => 'COSS',
        'countries' => ['SG', 'NL'],
        'rateLimit' => 1000,
        'version' => 'v1',
        'certified' => true,
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/50328158-22e53c00-0503-11e9-825c-c5cfd79bfa74.jpg',
          'api' => {
            'trade' => 'https://trade.coss.io/c/api/v1',
            'engine' => 'https://engine.coss.io/api/v1',
            'public' => 'https://trade.coss.io/c/api/v1',
            'web' => 'https://trade.coss.io/c', # undocumented
            'exchange' => 'https://exchange.coss.io/api'
          },
          'www' => 'https://www.coss.io',
          'doc' => 'https://api.coss.io/v1/spec',
          'referral' => 'https://www.coss.io/c/reg?r=OWCMHQVW2Q'
        },
        'has' => {
          'fetchTrades' => true,
          'fetchTicker' => true,
          'fetchTickers' => true,
          'fetchMarkets' => true,
          'fetchCurrencies' => true,
          'fetchBalance' => true,
          'fetchOrderBook' => true,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchOrderTrades' => true,
          'fetchClosedOrders' => true,
          'fetchOpenOrders' => true,
          'fetchOHLCV' => true,
          'createOrder' => true,
          'cancelOrder' => true
        },
        'timeframes' => {
          '1m' => '1m',
          '5m' => '5m',
          '15m' => '15m',
          '30m' => '30m',
          '1h' => '1h',
          '2h' => '2h',
          '4h' => '4h',
          '6h' => '6h',
          '12h' => '12h',
          '1d' => '1d',
          '1w' => '1w'
        },
        'api' => {
          'exchange' => {
            'get' => [
              'getmarketsummaries'
            ]
          },
          'public' => {
            'get' => [
              'market-price',
              'exchange-info'
            ]
          },
          'web' => {
            'get' => [
              'coins/getinfo/all', # undocumented
              'order/symbols', # undocumented
              'coins/get_base_list', # undocumented
            ]
          },
          'engine' => {
            'get' => [
              'dp',
              'ht',
              'cs'
            ]
          },
          'trade' => {
            'get' => [
              'ping',
              'time',
              'account/balances',
              'account/details'
            ],
            'post' => [
              'order/add',
              'order/details',
              'order/list/open',
              'order/list/completed',
              'order/list/all',
              'order/trade-detail'
            ],
            'delete' => [
              'order/cancel'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => true,
            'percentage' => true,
            'taker' => 0.0020,
            'maker' => 0.0014
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {},
            'deposit' => {}
          }
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetExchangeInfo(params)
      #
      #     {        timezone =>   "UTC",
      #           server_time =>    1545171487108,
      #           rate_limits => [{     type => "REQUESTS",
      #                            interval => "MINUTE",
      #                               limit =>  1000       }],
      #       base_currencies => [{ currency_code => "BTC", minimum_total_order => "0.0001" },
      #                          { currency_code => "USDT", minimum_total_order => "1" },
      #                          { currency_code => "EUR", minimum_total_order => "1" }],
      #                 coins => [{        currency_code => "ADI",
      #                                            name => "Aditus",
      #                            minimum_order_amount => "0.00000001" },
      #                          ...
      #                          {        currency_code => "NPXSXEM",
      #                                            name => "PundiX-XEM",
      #                            minimum_order_amount => "0.00000001"  }                ],
      #               symbols => [{               symbol => "ADI_BTC",
      #                            amount_limit_decimal =>  0,
      #                             price_limit_decimal =>  8,
      #                                   allow_trading =>  true      },
      #                          ...
      #                          {               symbol => "ETH_GUSD",
      #                            amount_limit_decimal =>  5,
      #                             price_limit_decimal =>  3,
      #                                   allow_trading =>  true       }     ]               }
      #
      result = []
      markets = self.class.safe_value(response, 'symbols', [])
      baseCurrencies = self.class.safe_value(response, 'base_currencies', [])
      baseCurrenciesByIds = self.class.index_by(baseCurrencies, 'currency_code')
      currencies = self.class.safe_value(response, 'coins', [])
      currenciesByIds = self.class.index_by(currencies, 'currency_code')
      for i in (0...markets.length)
        market = markets[i]
        marketId = market['symbol']
        baseId, quoteId = marketId.split('_')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        precision = {
          'amount' => self.class.safe_integer(market, 'amount_limit_decimal'),
          'price' => self.class.safe_integer(market, 'price_limit_decimal')
        }
        active = self.class.safe_value(market, 'allow_trading', false)
        baseCurrency = self.class.safe_value(baseCurrenciesByIds, baseId, {})
        minCost = self.class.safe_float(baseCurrency, 'minimum_total_order')
        currency = self.class.safe_value(currenciesByIds, baseId, {})
        defaultMinAmount = 10**-precision['amount']
        minAmount = self.class.safe_float(currency, 'minimum_order_amount', defaultMinAmount)
        result.push({
          'symbol' => symbol,
          'id' => marketId,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'base' => base,
          'quote' => quote,
          'active' => active,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => minAmount,
              'max' => nil
            },
            'price' => {
              'min' => nil,
              'max' => nil
            },
            'cost' => {
              'min' => minCost,
              'max' => nil
            }
          },
          'info' => market
        })
      end
      return result
    end

    def fetch_currencies(params = {})
      response = self.webGetCoinsGetinfoAll(params)
      #
      #     [{                 currency_code => "VET",
      #                                  name => "VeChain",
      #                             buy_limit =>  0,
      #                            sell_limit =>  0,
      #                                  usdt =>  0,
      #                transaction_time_limit =>  5,
      #                                status => "trade",
      #                         withdrawn_fee => "0.6",
      #              minimum_withdrawn_amount => "1.2",
      #                minimum_deposit_amount => "0.6",
      #                  minimum_order_amount => "0.00000001",
      #                        decimal_format => "0.########",
      #                            token_type =>  null, # "erc", "eos", "stellar", "tron", "ripple"...
      #                                buy_at =>  0,
      #                               sell_at =>  0,
      #                              min_rate =>  0,
      #                              max_rate =>  0,
      #                       allow_withdrawn =>  false,
      #                         allow_deposit =>  false,
      #         explorer_website_mainnet_link =>  null,
      #         explorer_website_testnet_link =>  null,
      #            deposit_block_confirmation => "6",
      #           withdraw_block_confirmation => "0",
      #                              icon_url => "https://s2.coinmarketcap.com/static/img/coins/32x32/3077.png",
      #                               is_fiat =>  false,
      #                            allow_sell =>  true,
      #                             allow_buy =>  true                                                           }]
      #
      result = {}
      for i in (0...response.length)
        currency = response[i]
        currencyId = self.class.safe_string(currency, 'currency_code')
        code = self.common_currency_code(currencyId)
        name = self.class.safe_string(currency, 'name')
        allowBuy = self.class.safe_value(currency, 'allow_buy')
        allowSell = self.class.safe_value(currency, 'allow_sell')
        allowWithdrawals = self.class.safe_value(currency, 'allow_withdrawn')
        allowDeposits = self.class.safe_value(currency, 'allow_deposit')
        active = allowBuy && allowSell && allowWithdrawals && allowDeposits
        fee = self.class.safe_float(currency, 'withdrawn_fee')
        type = self.class.safe_string(currency, 'token_type')
        #
        # decimal_format can be anything...
        #
        #     0.########
        #     #.########
        #     0.##
        #     ''(empty string)
        #     0.000000
        #     null(nil)
        #     0.0000
        #     0.###
        #
        decimalFormat = self.class.safe_string(currency, 'decimal_format')
        precision = 8
        if decimalFormat != nil
          parts = decimalFormat.split('.')
          numParts = parts.length # transpiler workaround for array lengths
          if numParts > 1
            if parts[1].length > 1
              precision = parts[1].length
            end
          end
        end
        result[code] = {
          'id' => currencyId,
          'code' => code,
          'info' => currency,
          'name' => name,
          'active' => active,
          'fee' => fee,
          'precision' => precision,
          'type' => type,
          'limits' => {
            'amount' => {
              'min' => self.class.safe_float(currency, 'minimum_order_amount'),
              'max' => nil
            },
            'withdraw' => {
              'min' => self.class.safe_float(currency, 'minimum_withdrawn_amount'),
              'max' => nil
            }
          }
        }
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.tradeGetAccountBalances(params)
      #
      #     [{ currency_code => "ETH",
      #               address => "0x6820511d43111a941d3e187b9e36ec64af763bde", # deposit address
      #                 total => "0.20399125",
      #             available => "0.20399125",
      #              in_order => "0",
      #                  memo =>  null                                         }, # tag, if any
      #       { currency_code => "ICX",
      #               address => "",
      #                 total => "0",
      #             available => "0",
      #              in_order => "0",
      #                  memo =>  null  }                                         ]
      #
      result = {}
      for i in (0...response.length)
        balance = response[i]
        currencyId = self.class.safe_string(balance, 'currency_code')
        code = self.common_currency_code(currencyId)
        total = self.class.safe_float(balance, 'total')
        used = self.class.safe_float(balance, 'in_order')
        free = self.class.safe_float(balance, 'available')
        result[code] = {
          'total' => total,
          'used' => used,
          'free' => free
        }
      end
      return self.parse_balance(result)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        (ohlcv[0]).to_i,   # timestamp
        ohlcv[1].to_f, # Open
        ohlcv[2].to_f, # High
        ohlcv[3].to_f, # Low
        ohlcv[4].to_f, # Close
        ohlcv[5].to_f, # base Volume
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id'],
        'tt' => self.timeframes[timeframe]
      }
      response = self.engineGetCs(self.class.shallow_extend(request, params))
      #
      #     {       tt =>   "1m",
      #         symbol =>   "ETH_BTC",
      #       nextTime =>    1545138960000,
      #         series => [[ 1545138960000,
      #                     "0.02705000",
      #                     "0.02705000",
      #                     "0.02705000",
      #                     "0.02705000",
      #                     "0.00000000"    ],
      #                   ...
      #                   [ 1545168900000,
      #                     "0.02684000",
      #                     "0.02684000",
      #                     "0.02684000",
      #                     "0.02684000",
      #                     "0.00000000"    ]  ],
      #          limit =>    500                    }
      #
      return self.parse_ohlcvs(response['series'], market, timeframe, since, limit)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      marketId = self.market_id(symbol)
      request = { 'symbol' => marketId }
      # limit argument is not supported on COSS's end
      response = self.engineGetDp(self.class.shallow_extend(request, params))
      #
      #     { symbol =>   "COSS_ETH",
      #         asks => [["0.00065200", "214.15000000"],
      #                 ["0.00065300", "645.45000000"],
      #                 ...
      #                 ["0.00076400", "380.00000000"],
      #                 ["0.00076900", "25.00000000"]     ],
      #        limit =>    100,
      #         bids => [["0.00065100", "666.99000000"],
      #                 ["0.00065000", "1171.93000000"],
      #                 ...
      #                 ["0.00037700", "3300.00000000"],
      #                 ["0.00037600", "2010.82000000"]   ],
      #         time =>    1545180569354                       }
      #
      timestamp = self.class.safe_integer(response, 'time')
      return self.parse_order_book(response, timestamp)
    end

    def parse_ticker(ticker, market = nil)
      #
      #      { MarketName => "COSS-ETH",
      #              High =>  0.00066,
      #               Low =>  0.000628,
      #        BaseVolume =>  131.09652674,
      #              Last =>  0.000636,
      #         TimeStamp => "2018-12-19T05:16:41.369Z",
      #            Volume =>  206126.6143710692,
      #               Ask => "0.00063600",
      #               Bid => "0.00063400",
      #           PrevDay =>  0.000636                   }
      #
      timestamp = self.class.parse8601(self.class.safe_string(ticker, 'TimeStamp'))
      symbol = nil
      marketId = self.class.safe_string(ticker, 'MarketName')
      if marketId != nil
        marketId = marketId.gsub('-', '_')
      end
      market = self.class.safe_value(self.markets_by_id, marketId, market)
      if market.nil?
        if marketId != nil
          baseId, quoteId = marketId.split('_')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
      end
      if market != nil
        symbol = market['symbol']
      end
      previous = self.class.safe_float(ticker, 'PrevDay')
      last = self.class.safe_float(ticker, 'Last')
      change = nil
      percentage = nil
      if last != nil
        if previous != nil
          change = last - previous
          if previous > 0
            percentage = (change / previous) * 100
          end
        end
      end
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.class.iso8601(timestamp),
        'high' => self.class.safe_float(ticker, 'High'),
        'low' => self.class.safe_float(ticker, 'Low'),
        'bid' => self.class.safe_float(ticker, 'Bid'),
        'bidVolume' => nil,
        'ask' => self.class.safe_float(ticker, 'Ask'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => previous,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => change,
        'percentage' => percentage,
        'average' => nil,
        'baseVolume' => self.class.safe_float(ticker, 'Volume'),
        'quoteVolume' => self.class.safe_float(ticker, 'BaseVolume'),
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      response = self.exchangeGetGetmarketsummaries(params)
      #
      #     { success =>    true,
      #       message =>   "",
      #        result => [{ MarketName => "COSS-ETH",
      #                          High =>  0.00066,
      #                           Low =>  0.000628,
      #                    BaseVolume =>  131.09652674,
      #                          Last =>  0.000636,
      #                     TimeStamp => "2018-12-19T05:16:41.369Z",
      #                        Volume =>  206126.6143710692,
      #                           Ask => "0.00063600",
      #                           Bid => "0.00063400",
      #                       PrevDay =>  0.000636                   },
      #                  ...
      #                  { MarketName => "XLM-BTC",
      #                          High =>  0.0000309,
      #                           Low =>  0.0000309,
      #                    BaseVolume =>  0,
      #                          Last =>  0.0000309,
      #                     TimeStamp => "2018-12-19T02:00:02.145Z",
      #                        Volume =>  0,
      #                           Ask => "0.00003300",
      #                           Bid => "0.00003090",
      #                       PrevDay =>  0.0000309                  }  ],
      #       volumes => [{ CoinName => "ETH", Volume => 668.1928095999999 }, # these are overall exchange volumes
      #                  { CoinName => "USD", Volume => 9942.58480324 },
      #                  { CoinName => "BTC", Volume => 43.749184570000004 },
      #                  { CoinName => "COSS", Volume => 909909.26644574 },
      #                  { CoinName => "EUR", Volume => 0 },
      #                  { CoinName => "TUSD", Volume => 2613.3395026999997 },
      #                  { CoinName => "USDT", Volume => 1017152.07416519 },
      #                  { CoinName => "GUSD", Volume => 1.80438 },
      #                  { CoinName => "XRP", Volume => 15.95508 },
      #                  { CoinName => "GBP", Volume => 0 },
      #                  { CoinName => "USDC", Volume => 0 }                   ],
      #             t =>    1545196604371                                       }
      #
      tickers = self.class.safe_value(response, 'result', [])
      result = {}
      for i in (0...tickers.length)
        ticker = self.parse_ticker(tickers[i])
        symbol = ticker['symbol']
        result[symbol] = ticker
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      tickers = self.fetch_tickers([symbol], params)
      return tickers[symbol]
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'symbol' => market['id']
      }
      response = self.engineGetHt(self.class.shallow_extend(request, params))
      #
      #     {  symbol =>   "COSS_ETH",
      #         limit =>    100,
      #       history => [{           id =>  481321,
      #                           price => "0.00065100",
      #                             qty => "272.92000000",
      #                    isBuyerMaker =>  false,
      #                            time =>  1545180845019  },
      #                  {           id =>  481322,
      #                           price => "0.00065200",
      #                             qty => "1.90000000",
      #                    isBuyerMaker =>  true,
      #                            time =>  1545180847535 },
      #                  ...
      #                  {           id =>  481420,
      #                           price => "0.00065300",
      #                             qty => "2.00000000",
      #                    isBuyerMaker =>  true,
      #                            time =>  1545181167702 }   ],
      #          time =>    1545181171274                        }
      #
      return self.parse_trades(response['history'], market, since, limit)
    end

    def parse_trade_fee(fee)
      if fee.nil?
        return fee
      end
      parts = fee.split(' ')
      numParts = parts.length
      cost = parts[0]
      code = nil
      if numParts > 1
        code = self.common_currency_code(parts[1])
      end
      return {
        'cost' => cost,
        'currency' => code
      }
    end

    def parse_trade(trade, market = nil)
      #
      # fetchTrades(public)
      #
      #      {           id =>  481322,
      #               price => "0.00065200",
      #                 qty => "1.90000000",
      #        isBuyerMaker =>  true,
      #                time =>  1545180847535 }
      #
      # fetchOrderTrades(private)
      #
      #     [{         hex_id =>  null,
      #                 symbol => "COSS_ETH",
      #               order_id => "ad6f6b47-3def-4add-a5d5-2549a9df1593",
      #             order_side => "BUY",
      #                  price => "0.00065900",
      #               quantity => "10",
      #                    fee => "0.00700000 COSS",
      #         additional_fee => "0.00000461 ETH",
      #                  total => "0.00659000 ETH",
      #              timestamp =>  1545152356075                          }]
      #
      id = self.class.safe_string(trade, 'id')
      timestamp = self.class.safe_integer(trade, 'time')
      orderId = self.class.safe_string(trade, 'order_id')
      side = self.class.safe_string(trade, 'order_side')
      if side != nil
        side = side.downcase
      end
      symbol = nil
      marketId = self.class.safe_string(trade, 'symbol')
      if marketId != nil
        market = self.class.safe_value(self.markets_by_id, marketId, market)
        if market.nil?
          baseId, quoteId = marketId.split('_')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        end
      elsif market != nil
        symbol = market['symbol']
      end
      cost = nil
      price = self.class.safe_float(trade, 'price')
      amount = self.class.safe_float_2(trade, 'qty', 'quantity')
      if amount != nil
        if price != nil
          cost = price * amount
        end
      end
      result = {
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.class.iso8601(timestamp),
        'symbol' => symbol,
        'id' => id,
        'order' => orderId,
        'type' => nil,
        'takerOrMaker' => nil,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount
      }
      fee = self.parse_trade_fee(self.class.safe_string(trade, 'fee'))
      if fee != nil
        additionalFee = self.parse_trade_fee(self.class.safe_string(trade, 'additional_fee'))
        if additionalFee.nil?
          result['fee'] = fee
        else
          result['fees'] = [
            fee,
            additionalFee
          ]
        end
      end
      return result
    end

    def fetch_orders_by_type(type, symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchOrders requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        # 'from_id' => 'b2a2d379-f9b6-418b-9414-cbf8330b20d1', # string(uuid), fetchOrders(all orders) only
        # 'page' => 0, # different pagination in fetchOpenOrders and fetchClosedOrders
        # 'limit' => 50, # optional, max = default = 50
        'symbol' => market['id'], # required
      }
      if limit != nil
        request['limit'] = limit # max = default = 50
      end
      method = 'tradePostOrderList' + type
      response = self.send_wrapper(method, self.class.shallow_extend(request, params))
      #
      # fetchOrders, fetchClosedOrders
      #
      #     [{       hex_id => "5c192784330fe51149f556bb",
      #             order_id => "5e46e1b1-93d5-4656-9b43-a5635b08eae9",
      #           account_id => "a0c20128-b9e0-484e-9bc8-b8bb86340e5b",
      #         order_symbol => "COSS_ETH",
      #           order_side => "BUY",
      #               status => "filled",
      #           createTime =>  1545152388019,
      #                 type => "limit",
      #         timeMatching =>  0,
      #          order_price => "0.00065900",
      #           order_size => "10",
      #             executed => "10",
      #           stop_price => "0.00000000",
      #                  avg => "0.00065900",
      #                total => "0.00659000 ETH"                        }  ]
      #
      # fetchOpenOrders
      #
      #     {
      #         "total" => 2,
      #         "list" => [
      #             {
      #                 "order_id" => "9e5ae4dd-3369-401d-81f5-dff985e1c4ty",
      #                 "account_id" => "9e5ae4dd-3369-401d-81f5-dff985e1c4a6",
      #                 "order_symbol" => "eth-btc",
      #                 "order_side" => "BUY",
      #                 "status" => "OPEN",
      #                 "createTime" => 1538114348750,
      #                 "type" => "limit",
      #                 "order_price" => "0.12345678",
      #                 "order_size" => "10.12345678",
      #                 "executed" => "0",
      #                 "stop_price" => "02.12345678",
      #                 "avg" => "1.12345678",
      #                 "total" => "2.12345678"
      #             }
      #         ]
      #     }
      #
      # the following code is to handle the above difference in response formats
      orders = nil
      if response.is_a?(Array)
        orders = response
      else
        orders = self.class.safe_value(response, 'list', [])
      end
      return self.parse_orders(orders, market, since, limit)
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_type('All', symbol, since, limit, params)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_type('Completed', symbol, since, limit, params)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      return self.fetch_orders_by_type('Open', symbol, since, limit, params)
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      response = self.tradePostOrderDetails(self.class.shallow_extend({
        'order_id' => id
      }, params))
      return self.parse_order(response)
    end

    def fetch_order_trades(id, symbol = nil, since = nil, limit = nil, params = {})
      self.load_markets
      market = nil
      if symbol != nil
        market = self.market(symbol)
      end
      request = {
        'order_id' => id
      }
      response = self.tradePostOrderTradeDetail(self.class.shallow_extend(request, params))
      #
      #     [{         hex_id =>  null,
      #                 symbol => "COSS_ETH",
      #               order_id => "ad6f6b47-3def-4add-a5d5-2549a9df1593",
      #             order_side => "BUY",
      #                  price => "0.00065900",
      #               quantity => "10",
      #                    fee => "0.00700000 COSS",
      #         additional_fee => "0.00000461 ETH",
      #                  total => "0.00659000 ETH",
      #              timestamp =>  1545152356075                          }]
      #
      return self.parse_trades(response, market, since, limit)
    end

    def parse_order_status(status)
      if status.nil?
        return status
      end
      statuses = {
        'OPEN' => 'open',
        'CANCELLED' => 'canceled',
        'FILLED' => 'closed',
        'PARTIAL_FILL' => 'open',
        'CANCELLING' => 'open'
      }
      return self.class.safe_string(statuses, status.upcase, status)
    end

    def parse_order(order, market = nil)
      #
      #       {       hex_id => "5c192784330fe51149f556bb", # missing in fetchOpenOrders
      #             order_id => "5e46e1b1-93d5-4656-9b43-a5635b08eae9",
      #           account_id => "a0c20128-b9e0-484e-9bc8-b8bb86340e5b",
      #         order_symbol => "COSS_ETH", # coss-eth in docs
      #           order_side => "BUY",
      #               status => "filled",
      #           createTime =>  1545152388019,
      #                 type => "limit",
      #         timeMatching =>  0, # missing in fetchOpenOrders
      #          order_price => "0.00065900",
      #           order_size => "10",
      #             executed => "10",
      #           stop_price => "0.00000000",
      #                  avg => "0.00065900",
      #                total => "0.00659000 ETH"                        }
      #
      id = self.class.safe_string(order, 'order_id')
      symbol = nil
      marketId = self.class.safe_string(order, 'order_symbol')
      if marketId.nil?
        if market != nil
          symbol = market['symbol']
        end
      else
        # a minor workaround for lowercase eth-btc symbols
        marketId = marketId.upcase
        marketId = marketId.gsub('-', '_')
        market = self.class.safe_value(self.markets_by_id, marketId, market)
        if market.nil?
          baseId, quoteId = marketId.split('_')
          base = self.common_currency_code(baseId)
          quote = self.common_currency_code(quoteId)
          symbol = base + '/' + quote
        else
          symbol = market['symbol']
        end
      end
      timestamp = self.class.safe_integer(order, 'createTime')
      status = self.parse_order_status(self.class.safe_string(order, 'status'))
      price = self.class.safe_float(order, 'order_price')
      filled = self.class.safe_float(order, 'executed')
      type = self.class.safe_string(order, 'type')
      amount = self.class.safe_float(order, 'order_size')
      remaining = nil
      if amount != nil
        if filled != nil
          remaining = amount - filled
        end
      end
      average = self.class.safe_float(order, 'avg')
      side = self.class.safe_string(order, 'order_side')
      if side != nil
        side = side.downcase
      end
      cost = self.class.safe_float(order, 'total')
      fee = nil
      trades = nil
      return {
        'info' => order,
        'id' => id,
        'timestamp' => timestamp,
        'datetime' => self.class.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => symbol,
        'type' => type,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'cost' => cost,
        'average' => average,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'fee' => fee,
        'trades' => trades
      }
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'order_symbol' => market['id'],
        'order_price' => self.price_to_precision(symbol, price.to_f),
        'order_size' => self.amount_to_precision(symbol, amount.to_f),
        'order_side' => side.upcase,
        'type' => type
      }
      response = self.tradePostOrderAdd(self.class.shallow_extend(request, params))
      #
      #     {
      #         "order_id" => "9e5ae4dd-3369-401d-81f5-dff985e1c4ty",
      #         "account_id" => "9e5ae4dd-3369-401d-81f5-dff985e1c4a6",
      #         "order_symbol" => "eth-btc",
      #         "order_side" => "BUY",
      #         "status" => "OPEN",
      #         "createTime" => 1538114348750,
      #         "type" => "limit",
      #         "order_price" => "0.12345678",
      #         "order_size" => "10.12345678",
      #         "executed" => "0",
      #         "stop_price" => "02.12345678",
      #         "avg" => "1.12345678",
      #         "total" => "2.12345678"
      #     }
      #
      return self.parse_order(response, market)
    end

    def cancel_order(id, symbol = nil, params = {})
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' cancelOrder requires a symbol argument')
      end
      self.load_markets
      market = self.market(symbol)
      request = {
        'order_id' => id,
        'order_symbol' => market['id']
      }
      response = self.tradeDeleteOrderCancel(self.class.shallow_extend(request, params))
      #
      #     { order_symbol => "COSS_ETH",
      #           order_id => "30f2d698-39a0-4b9f-a3a6-a179542373bd",
      #         order_size =>  0,
      #         account_id => "a0c20128-b9e0-484e-9bc8-b8bb86340e5b",
      #          timestamp =>  1545202728814,
      #         recvWindow =>  null                                   }
      #
      return self.parse_order(response)
    end

    def nonce
      return self.class.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api] + '/' + path
      if api == 'trade'
        self.check_required_credentials
        timestamp = self.nonce
        query = self.class.shallow_extend({
          'timestamp' => timestamp, # required(int64)
          # 'recvWindow' => 10000, # optional(int32)
        }, params)
        request = nil
        if method == 'GET'
          request = self.class.urlencode(query)
          url += '?' + request
        else
          request = self.class.json(query)
          body = request
        end
        headers = {
          'Signature' => self.class.hmac(self.class.encode(request), self.class.encode(self.secret)),
          'Authorization' => self.apiKey
        }
      else
        if params
          url += '?' + self.class.urlencode(params)
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end
  end
end
