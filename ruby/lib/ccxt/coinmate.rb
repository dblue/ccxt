# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Coinmate < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'coinmate',
        'name' => 'CoinMate',
        'countries' => ['GB', 'CZ', 'EU'], # UK, Czech Republic
        'rateLimit' => 1000,
        'has' => {
          'CORS' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27811229-c1efb510-606c-11e7-9a36-84ba2ce412d8.jpg',
          'api' => 'https://coinmate.io/api',
          'www' => 'https://coinmate.io',
          'fees' => 'https://coinmate.io/fees',
          'doc' => [
            'https://coinmate.docs.apiary.io',
            'https://coinmate.io/developers'
          ],
          'referral' => 'https://coinmate.io?referral=YTFkM1RsOWFObVpmY1ZjMGREQmpTRnBsWjJJNVp3PT0'
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true,
          'uid' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'orderBook',
              'ticker',
              'transactions'
            ]
          },
          'private' => {
            'post' => [
              'balances',
              'bitcoinWithdrawal',
              'bitcoinDepositAddresses',
              'buyInstant',
              'buyLimit',
              'cancelOrder',
              'cancelOrderWithInfo',
              'createVoucher',
              'openOrders',
              'redeemVoucher',
              'sellInstant',
              'sellLimit',
              'transactionHistory',
              'unconfirmedBitcoinDeposits'
            ]
          }
        },
        'markets' => {
          'BTC/EUR' => { 'id' => 'BTC_EUR', 'symbol' => 'BTC/EUR', 'base' => 'BTC', 'quote' => 'EUR', 'precision' => { 'amount' => 4, 'price' => 2 }, 'maker' => 0.25 / 100, 'taker' => 0.12 / 100 },
          'BTC/CZK' => { 'id' => 'BTC_CZK', 'symbol' => 'BTC/CZK', 'base' => 'BTC', 'quote' => 'CZK', 'precision' => { 'amount' => 4, 'price' => 2 }, 'maker' => 0.25 / 100, 'taker' => 0.12 / 100 },
          'LTC/EUR' => { 'id' => 'LTC_EUR', 'symbol' => 'LTC/EUR', 'base' => 'LTC', 'quote' => 'EUR', 'precision' => { 'amount' => 4, 'price' => 2 }, 'maker' => 0.25 / 100, 'taker' => 0.12 / 100 },
          'LTC/CZK' => { 'id' => 'LTC_CZK', 'symbol' => 'LTC/CZK', 'base' => 'LTC', 'quote' => 'CZK', 'precision' => { 'amount' => 4, 'price' => 2 }, 'maker' => 0.25 / 100, 'taker' => 0.12 / 100 },
          'LTC/BTC' => { 'id' => 'LTC_BTC', 'symbol' => 'LTC/BTC', 'base' => 'LTC', 'quote' => 'BTC', 'precision' => { 'amount' => 4, 'price' => 5 }, 'maker' => 0.25 / 100, 'taker' => 0.12 / 100 },
          'ETH/EUR' => { 'id' => 'ETH_EUR', 'symbol' => 'ETH/EUR', 'base' => 'ETH', 'quote' => 'EUR', 'precision' => { 'amount' => 4, 'price' => 2 }},
          'ETH/CZK' => { 'id' => 'ETH_CZK', 'symbol' => 'ETH/CZK', 'base' => 'ETH', 'quote' => 'CZK', 'precision' => { 'amount' => 4, 'price' => 2 }},
          'ETH/BTC' => { 'id' => 'ETH_BTC', 'symbol' => 'ETH/BTC', 'base' => 'ETH', 'quote' => 'BTC', 'precision' => { 'amount' => 4, 'price' => 5 }},
          'XRP/EUR' => { 'id' => 'XRP_EUR', 'symbol' => 'XRP/EUR', 'base' => 'XRP', 'quote' => 'EUR', 'precision' => { 'amount' => 4, 'price' => 5 }},
          'XRP/CZK' => { 'id' => 'XRP_CZK', 'symbol' => 'XRP/CZK', 'base' => 'XRP', 'quote' => 'CZK', 'precision' => { 'amount' => 4, 'price' => 5 }},
          'XRP/BTC' => { 'id' => 'XRP_BTC', 'symbol' => 'XRP/BTC', 'base' => 'XRP', 'quote' => 'BTC', 'precision' => { 'amount' => 4, 'price' => 8 }},
          'BCH/EUR' => { 'id' => 'BCH_EUR', 'symbol' => 'BCH/EUR', 'base' => 'BCH', 'quote' => 'EUR', 'precision' => { 'amount' => 4, 'price' => 2 }},
          'BCH/CZK' => { 'id' => 'BCH_CZK', 'symbol' => 'BCH/CZK', 'base' => 'BCH', 'quote' => 'CZK', 'precision' => { 'amount' => 4, 'price' => 2 }},
          'BCH/BTC' => { 'id' => 'BCH_BTC', 'symbol' => 'BCH/BTC', 'base' => 'BCH', 'quote' => 'BTC', 'precision' => { 'amount' => 4, 'price' => 5 }}
        },
        'fees' => {
          'trading' => {
            'maker' => 0.05 / 100,
            'taker' => 0.15 / 100
          }
        }
      })
    end

    def fetch_balance(params = {})
      response = self.privatePostBalances
      balances = response['data']
      result = { 'info' => balances }
      currencies = self.currencies.keys
      for i in (0...currencies.length)
        currency = currencies[i]
        account = self.account
        if balances.include?(currency)
          account['free'] = balances[currency]['available']
          account['used'] = balances[currency]['reserved']
          account['total'] = balances[currency]['balance']
        end
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      response = self.publicGetOrderBook(self.shallow_extend({
        'currencyPair' => self.market_id(symbol),
        'groupByPriceLimit' => 'False'
      }, params))
      orderbook = response['data']
      timestamp = orderbook['timestamp'] * 1000
      return self.parse_order_book(orderbook, timestamp, 'bids', 'asks', 'price', 'amount')
    end

    def fetch_ticker(symbol, params = {})
      response = self.publicGetTicker(self.shallow_extend({
        'currencyPair' => self.market_id(symbol)
      }, params))
      ticker = response['data']
      timestamp = ticker['timestamp'] * 1000
      last = self.safe_float(ticker, 'last')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'bid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'ask'),
        'vwap' => nil,
        'askVolume' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'amount'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      if !market
        market = self.markets_by_id[trade['currencyPair']]
      end
      return {
        'id' => trade['transactionId'],
        'info' => trade,
        'timestamp' => trade['timestamp'],
        'datetime' => self.iso8601(trade['timestamp']),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => nil,
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      market = self.market(symbol)
      response = self.publicGetTransactions(self.shallow_extend({
        'currencyPair' => market['id'],
        'minutesIntoHistory' => 10
      }, params))
      return self.parse_trades(response['data'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      method = 'privatePost' + self.capitalize(side)
      order = {
        'currencyPair' => self.market_id(symbol)
      }
      if type == 'market'
        if side == 'buy'
          order['total'] = amount # amount in fiat
        else
          order['amount'] = amount # amount in fiat
        end
        method += 'Instant'
      else
        order['amount'] = amount # amount in crypto
        order['price'] = price
        method += self.capitalize(type)
      end
      response = self.send_wrapper(method, self.shallow_extend(order, params))
      return {
        'info' => response,
        'id' => response['data'].to_s
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      return self.privatePostCancelOrder({ 'orderId' => id })
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'] + '/' + path
      if api == 'public'
        if params
          url += '?' + self.urlencode(params)
        end
      else
        self.check_required_credentials
        nonce = self.nonce.to_s
        auth = nonce + self.uid + self.apiKey
        signature = self.hmac(self.encode(auth), self.encode(self.secret))
        body = self.urlencode(self.shallow_extend({
          'clientId' => self.uid,
          'nonce' => nonce,
          'publicKey' => self.apiKey,
          'signature' => signature.upcase
        }, params))
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if response.include?('error')
        if response['error']
          raise(ExchangeError, self.id + ' ' + self.json(response))
        end
      end
      return response
    end
  end
end
