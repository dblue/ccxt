# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Ccex < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'ccex',
        'name' => 'C-CEX',
        'countries' => ['DE', 'EU'],
        'rateLimit' => 1500,
        'has' => {
          'CORS' => false,
          'fetchTickers' => true,
          'fetchOrderBooks' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766433-16881f90-5ed8-11e7-92f8-3d92cc747a6c.jpg',
          'api' => {
            'web' => 'https://c-cex.com/t',
            'public' => 'https://c-cex.com/t/api_pub.html',
            'private' => 'https://c-cex.com/t/api.html'
          },
          'www' => 'https://c-cex.com',
          'doc' => 'https://c-cex.com/?id=api'
        },
        'api' => {
          'web' => {
            'get' => [
              'coinnames',
              '{market}',
              'pairs',
              'prices',
              'volume_{coin}'
            ]
          },
          'public' => {
            'get' => [
              'balancedistribution',
              'markethistory',
              'markets',
              'marketsummaries',
              'orderbook',
              'fullorderbook'
            ]
          },
          'private' => {
            'get' => [
              'buylimit',
              'cancel',
              'getbalance',
              'getbalances',
              'getopenorders',
              'getorder',
              'getorderhistory',
              'mytrades',
              'selllimit'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'taker' => 0.2 / 100,
            'maker' => 0.2 / 100
          }
        },
        'commonCurrencies' => {
          'BLC' => 'Cryptobullcoin',
          'CRC' => 'CoreCoin',
          'IOT' => 'IoTcoin',
          'LUX' => 'Luxmi',
          'VIT' => 'VitalCoin',
          'XID' => 'InternationalDiamond'
        }
      })
    end

    def fetch_markets(params = {})
      result = {}
      response = self.webGetPairs
      markets = response['pairs']
      for i in (0...markets.length)
        id = markets[i]
        baseId, quoteId = id.split('-')
        base = baseId.upcase
        quote = quoteId.upcase
        base = self.common_currency_code(base)
        quote = self.common_currency_code(quote)
        symbol = base + '/' + quote
        result[symbol] = {
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'info' => id
        }
      end
      # an alternative documented parser
      #     markets = self.publicGetMarkets
      #     for p in (0...markets['result'].length)
      #         market = markets['result'][p]
      #         id = market['MarketName']
      #         base = market['MarketCurrency']
      #         quote = market['BaseCurrency']
      #         base = self.common_currency_code(base)
      #         quote = self.common_currency_code(quote)
      #         symbol = base + '/' + quote
      #         result.push({
      #             'id' => id,
      #             'symbol' => symbol,
      #             'base' => base,
      #             'quote' => quote,
      #             'info' => market,
      #         })
      #     }
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      response = self.privateGetGetbalances
      balances = response['result']
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        code = balance['Currency']
        currency = self.common_currency_code(code)
        account = {
          'free' => balance['Available'],
          'used' => balance['Pending'],
          'total' => balance['Balance']
        }
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      request = {
        'market' => self.market_id(symbol),
        'type' => 'both'
      }
      if limit != nil
        request['depth'] = limit
      end # 100
      response = self.publicGetOrderbook(self.shallow_extend(request, params))
      orderbook = response['result']
      return self.parse_order_book(orderbook, nil, 'buy', 'sell', 'Rate', 'Quantity')
    end

    def fetch_order_books(symbols = nil, params = {})
      self.load_markets
      orderbooks = {}
      response = self.publicGetFullorderbook
      sides = response['result'].keys
      for i in (0...sides.length)
        side = sides[i]
        bidasks = response['result'][side]
        bidasksByMarketId = self.group_by(bidasks, 'Market')
        marketIds = bidasksByMarketId.keys
        for j in (0...marketIds.length)
          marketId = marketIds[j]
          symbol = marketId
          if self.markets_by_id.include?(marketId)
            market = self.markets_by_id[symbol]
            symbol = market['symbol']
          else
            baseId, quoteId = symbol.split('-')
            invertedId = quoteId + '-' + baseId
            if self.markets_by_id.include?(invertedId)
              market = self.markets_by_id[invertedId]
              symbol = market['symbol']
            end
          end
          if orderbooks.include?(!(symbol))
            orderbooks[symbol] = {}
          end
          orderbooks[symbol][side] = bidasksByMarketId[marketId]
        end
      end
      result = {}
      keys = orderbooks.keys
      for k in (0...keys.length)
        key = keys[k]
        result[key] = self.parse_order_book(orderbooks[key], nil, 'buy', 'sell', 'Rate', 'Quantity')
      end
      return result
    end

    def parse_ticker(ticker, market = nil)
      timestamp = ticker['updated'] * 1000
      symbol = nil
      if market != nil
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'lastprice')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => self.safe_float(ticker, 'high'),
        'low' => self.safe_float(ticker, 'low'),
        'bid' => self.safe_float(ticker, 'buy'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'sell'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => self.safe_float(ticker, 'avg'),
        'baseVolume' => nil,
        'quoteVolume' => self.safe_float(ticker, 'buysupport'),
        'info' => ticker
      }
    end

    def fetch_tickers(symbols = nil, params = {})
      self.load_markets
      tickers = self.webGetPrices(params)
      result = {}
      ids = tickers.keys
      for i in (0...ids.length)
        id = ids[i]
        ticker = tickers[id]
        market = nil
        symbol = nil
        if self.markets_by_id.include?(id)
          market = self.markets_by_id[id]
          symbol = market['symbol']
        else
          uppercase = id.upcase
          base, quote = uppercase.split('-')
          base = self.common_currency_code(base)
          quote = self.common_currency_code(quote)
          symbol = base + '/' + quote
        end
        result[symbol] = self.parse_ticker(ticker, market)
      end
      return result
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.webGetMarket(self.shallow_extend({
        'market' => market['id'].downcase
      }, params))
      ticker = response['ticker']
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      timestamp = self.parse8601(trade['TimeStamp'])
      return {
        'id' => trade['Id'].to_s,
        'info' => trade,
        'order' => nil,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => trade['OrderType'].downcase,
        'price' => trade['Price'],
        'amount' => trade['Quantity']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarkethistory(self.shallow_extend({
        'market' => market['id'],
        'type' => 'both',
        'depth' => 100
      }, params))
      return self.parse_trades(response['result'], market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      method = 'privateGet' + self.capitalize(side) + type
      response = self.send_wrapper(method, self.shallow_extend({
        'market' => self.market_id(symbol),
        'quantity' => amount,
        'rate' => price
      }, params))
      return {
        'info' => response,
        'id' => response['result']['uuid']
      }
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.privateGetCancel({ 'uuid' => id })
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      url = self.urls['api'][api]
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce.to_s
        query = self.keysort(self.shallow_extend({
          'a' => path,
          'apikey' => self.apiKey,
          'nonce' => nonce
        }, params))
        url += '?' + self.urlencode(query)
        headers = { 'apisign' => self.hmac(self.encode(url), self.encode(self.secret), 'sha512') }
      elsif api == 'public'
        url += '?' + self.urlencode(self.shallow_extend({
          'a' => 'get' + path
        }, params))
      else
        url += '/' + self.implode_params(path, params) + '.json'
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = self.fetch2(path, api, method, params, headers, body)
      if api == 'web'
        return response
      end
      if response.include?('success')
        if response['success']
          return response
        end
      end
      raise(ExchangeError, self.id + ' ' + self.json(response))
    end
  end
end
