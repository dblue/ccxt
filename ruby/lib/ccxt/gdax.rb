# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Gdax < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'gdax',
        'name' => 'GDAX',
        'countries' => ['US'],
        'rateLimit' => 1000,
        'userAgent' => self.userAgents['chrome'],
        'has' => {
          'cancelAllOrders' => true,
          'CORS' => true,
          'deposit' => true,
          'fetchAccounts' => true,
          'fetchClosedOrders' => true,
          'fetchDepositAddress' => true,
          'fetchMyTrades' => true,
          'fetchOHLCV' => true,
          'fetchOpenOrders' => true,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchTransactions' => true,
          'withdraw' => true
        },
        'timeframes' => {
          '1m' => 60,
          '5m' => 300,
          '15m' => 900,
          '1h' => 3600,
          '6h' => 21600,
          '1d' => 86400
        },
        'urls' => {
          'test' => 'https://api-public.sandbox.gdax.com',
          'logo' => 'https://user-images.githubusercontent.com/1294454/27766527-b1be41c6-5edb-11e7-95f6-5b496c469e2c.jpg',
          'api' => 'https://api.gdax.com',
          'www' => 'https://www.gdax.com',
          'doc' => 'https://docs.gdax.com',
          'fees' => [
            'https://www.gdax.com/fees',
            'https://support.gdax.com/customer/en/portal/topics/939402-depositing-and-withdrawing-funds/articles'
          ]
        },
        'requiredCredentials' => {
          'apiKey' => true,
          'secret' => true,
          'password' => true
        },
        'api' => {
          'public' => {
            'get' => [
              'currencies',
              'products',
              'products/{id}/book',
              'products/{id}/candles',
              'products/{id}/stats',
              'products/{id}/ticker',
              'products/{id}/trades',
              'time'
            ]
          },
          'private' => {
            'get' => [
              'accounts',
              'accounts/{id}',
              'accounts/{id}/holds',
              'accounts/{id}/ledger',
              'accounts/{id}/transfers',
              'coinbase-accounts',
              'fills',
              'funding',
              'orders',
              'orders/{id}',
              'otc/orders',
              'payment-methods',
              'position',
              'reports/{id}',
              'users/self/trailing-volume'
            ],
            'post' => [
              'conversions',
              'deposits/coinbase-account',
              'deposits/payment-method',
              'coinbase-accounts/{id}/addresses',
              'funding/repay',
              'orders',
              'position/close',
              'profiles/margin-transfer',
              'reports',
              'withdrawals/coinbase',
              'withdrawals/crypto',
              'withdrawals/payment-method'
            ],
            'delete' => [
              'orders',
              'orders/{id}'
            ]
          }
        },
        'fees' => {
          'trading' => {
            'tierBased' => true, # complicated tier system per coin
            'percentage' => true,
            'maker' => 0.15 / 100, # highest fee of all tiers
            'taker' => 0.25 / 100, # highest fee of all tiers
          },
          'funding' => {
            'tierBased' => false,
            'percentage' => false,
            'withdraw' => {
              'BCH' => 0,
              'BTC' => 0,
              'LTC' => 0,
              'ETH' => 0,
              'EUR' => 0.15,
              'USD' => 25
            },
            'deposit' => {
              'BCH' => 0,
              'BTC' => 0,
              'LTC' => 0,
              'ETH' => 0,
              'EUR' => 0.15,
              'USD' => 10
            }
          }
        },
        'exceptions' => {
          'exact' => {
            'Insufficient funds' => InsufficientFunds,
            'NotFound' => OrderNotFound,
            'Invalid API Key' => AuthenticationError,
            'invalid signature' => AuthenticationError,
            'Invalid Passphrase' => AuthenticationError,
            'Invalid order id' => InvalidOrder
          },
          'broad' => {
            'Order already done' => OrderNotFound,
            'order not found' => OrderNotFound,
            'price too small' => InvalidOrder,
            'price too precise' => InvalidOrder
          }
        }
      })
    end

    async def fetch_markets(params = {})
      response = await{ self.publicGetProducts(params) }
      result = []
      for i in (0...response.length)
        market = response[i]
        id = self.safe_string(market, 'id')
        baseId = self.safe_string(market, 'base_currency')
        quoteId = self.safe_string(market, 'quote_currency')
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        priceLimits = {
          'min' => self.safe_float(market, 'quote_increment'),
          'max' => nil
        }
        precision = {
          'amount' => 8,
          'price' => self.precision_from_string(self.safe_string(market, 'quote_increment'))
        }
        taker = self.fees['trading']['taker']  # does not seem right
        if (base == 'ETH') || (base == 'LTC')
          taker = 0.003
        end
        active = market['status'] == 'online'
        result.push(self.shallow_extend(self.fees['trading'], {
          'id' => id,
          'symbol' => symbol,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'base' => base,
          'quote' => quote,
          'precision' => precision,
          'limits' => {
            'amount' => {
              'min' => self.safe_float(market, 'base_min_size'),
              'max' => self.safe_float(market, 'base_max_size')
            },
            'price' => priceLimits,
            'cost' => {
              'min' => self.safe_float(market, 'min_market_funds'),
              'max' => self.safe_float(market, 'max_market_funds')
            }
          },
          'taker' => taker,
          'active' => active,
          'info' => market
        }))
      end
      return result
    end

    async def fetch_accounts(params = {})
      response = await{ self.privateGetAccounts(params) }
      #
      #     [
      #         {
      #             id => '4aac9c60-cbda-4396-9da4-4aa71e95fba0',
      #             currency => 'BTC',
      #             balance => '0.0000000000000000',
      #             available => '0',
      #             hold => '0.0000000000000000',
      #             profile_id => 'b709263e-f42a-4c7d-949a-a95c83d065da'
      #         },
      #         {
      #             id => 'f75fa69a-1ad1-4a80-bd61-ee7faa6135a3',
      #             currency => 'USDC',
      #             balance => '0.0000000000000000',
      #             available => '0',
      #             hold => '0.0000000000000000',
      #             profile_id => 'b709263e-f42a-4c7d-949a-a95c83d065da'
      #         },
      #     ]
      #
      result = []
      for i in (0...response.length)
        account = response[i]
        accountId = self.safe_string(account, 'id')
        currencyId = self.safe_string(account, 'currency')
        code = self.common_currency_code(currencyId)
        result.push({
          'id' => accountId,
          'type' => nil,
          'currency' => code,
          'info' => account
        })
      end
      return result
    end

    async def fetch_balance(params = {})
      await{ self.load_markets }
      balances = await{ self.privateGetAccounts(params) }
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency']
        account = {
          'free' => self.safe_float(balance, 'available'),
          'used' => self.safe_float(balance, 'hold'),
          'total' => self.safe_float(balance, 'balance')
        }
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    async def fetch_order_book(symbol, limit = nil, params = {})
      await{ self.load_markets }
      orderbook = await{ self.publicGetProductsIdBook(self.shallow_extend({
        'id' => self.market_id(symbol),
        'level' => 2, # 1 best bidask, 2 aggregated, 3 full
      }, params)) }
      return self.parse_order_book(orderbook)
    end

    async def fetch_ticker(symbol, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      request = self.shallow_extend({
        'id' => market['id']
      }, params)
      ticker = await{ self.publicGetProductsIdTicker(request) }
      timestamp = self.parse8601(self.safe_value(ticker, 'time'))
      bid = nil
      ask = nil
      if ticker.include?('bid')
        bid = self.safe_float(ticker, 'bid')
      end
      if ticker.include?('ask')
        ask = self.safe_float(ticker, 'ask')
      end
      last = self.safe_float(ticker, 'price')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => bid,
        'bidVolume' => nil,
        'ask' => ask,
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'volume'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def parse_trade(trade, market = nil)
      timestamp = self.parse8601(self.safe_string_2(trade, 'time', 'created_at'))
      symbol = nil
      if market.nil?
        marketId = self.safe_string(trade, 'product_id')
        market = self.safe_value(self.markets_by_id, marketId)
      end
      if market
        symbol = market['symbol']
      end
      feeRate = nil
      feeCurrency = nil
      takerOrMaker = nil
      if market != nil
        feeCurrency = market['quote']
        if trade.include?('liquidity')
          takerOrMaker = (trade['liquidity'] == 'T') ? 'taker' : 'maker'
          feeRate = market[takerOrMaker]
        end
      end
      feeCost = self.safe_float(trade, 'fill_fees')
      if feeCost.nil?
        feeCost = self.safe_float(trade, 'fee')
      end
      fee = {
        'cost' => feeCost,
        'currency' => feeCurrency,
        'rate' => feeRate
      }
      type = nil
      id = self.safe_string(trade, 'trade_id')
      side = (trade['side'] == 'buy') ? 'sell' : 'buy'
      orderId = self.safe_string(trade, 'order_id')
      # GDAX returns inverted side to fetchMyTrades vs fetchTrades
      if orderId != nil
        side = (trade['side'] == 'buy') ? 'buy' : 'sell'
      end
      price = self.safe_float(trade, 'price')
      amount = self.safe_float(trade, 'size')
      return {
        'id' => id,
        'order' => orderId,
        'info' => trade,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => symbol,
        'type' => type,
        'takerOrMaker' => takerOrMaker,
        'side' => side,
        'price' => price,
        'amount' => amount,
        'fee' => fee,
        'cost' => price * amount
      }
    end

    async def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      # as of 2018-08-23
      if symbol.nil?
        raise(ArgumentsRequired, self.id + ' fetchMyTrades requires a symbol argument')
      end
      await{ self.load_markets }
      market = self.market(symbol)
      request = {
        'product_id' => market['id']
      }
      if limit != nil
        request['limit'] = limit
      end
      response = await{ self.privateGetFills(self.shallow_extend(request, params)) }
      return self.parse_trades(response, market, since, limit)
    end

    async def fetch_trades(symbol, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      response = await{ self.publicGetProductsIdTrades(self.shallow_extend({
        'id' => market['id'], # fixes issue #2
      }, params)) }
      return self.parse_trades(response, market, since, limit)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      return [
        ohlcv[0] * 1000,
        ohlcv[3],
        ohlcv[2],
        ohlcv[1],
        ohlcv[4],
        ohlcv[5]
      ]
    end

    async def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      await{ self.load_markets }
      market = self.market(symbol)
      granularity = self.timeframes[timeframe]
      request = {
        'id' => market['id'],
        'granularity' => granularity
      }
      if since != nil
        request['start'] = self.ymdhms(since)
        if limit.nil?
          # https://docs.gdax.com/#get-historic-rates
          limit = 300 # max = 300
        end
        request['end'] = self.ymdhms(self.sum(limit * granularity * 1000, since))
      end
      response = await{ self.publicGetProductsIdCandles(self.shallow_extend(request, params)) }
      return self.parse_ohlcvs(response, market, timeframe, since, limit)
    end

    async def fetch_time
      response = await{ self.publicGetTime }
      return self.parse8601(response['iso'])
    end

    def parse_order_status(status)
      statuses = {
        'pending' => 'open',
        'active' => 'open',
        'open' => 'open',
        'done' => 'closed',
        'canceled' => 'canceled',
        'canceling' => 'open'
      }
      return self.safe_string(statuses, status, status)
    end

    def parse_order(order, market = nil)
      timestamp = self.parse8601(order['created_at'])
      symbol = nil
      if market.nil?
        if self.markets_by_id.include?(order['product_id'])
          market = self.markets_by_id[order['product_id']]
        end
      end
      status = self.parse_order_status(self.safe_string(order, 'status'))
      price = self.safe_float(order, 'price')
      amount = self.safe_float(order, 'size')
      if amount.nil?
        amount = self.safe_float(order, 'funds')
      end
      if amount.nil?
        amount = self.safe_float(order, 'specified_funds')
      end
      filled = self.safe_float(order, 'filled_size')
      remaining = nil
      if amount != nil
        if filled != nil
          remaining = amount - filled
        end
      end
      cost = self.safe_float(order, 'executed_value')
      fee = {
        'cost' => self.safe_float(order, 'fill_fees'),
        'currency' => nil,
        'rate' => nil
      }
      if market
        symbol = market['symbol']
      end
      return {
        'id' => order['id'],
        'info' => order,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'status' => status,
        'symbol' => symbol,
        'type' => order['type'],
        'side' => order['side'],
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'fee' => fee
      }
    end

    async def fetch_order(id, symbol = nil, params = {})
      await{ self.load_markets }
      response = await{ self.privateGetOrdersId(self.shallow_extend({
        'id' => id
      }, params)) }
      return self.parse_order(response)
    end

    async def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      request = {
        'status' => 'all'
      }
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['product_id'] = market['id']
      end
      response = await{ self.privateGetOrders(self.shallow_extend(request, params)) }
      return self.parse_orders(response, market, since, limit)
    end

    async def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      request = {}
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['product_id'] = market['id']
      end
      response = await{ self.privateGetOrders(self.shallow_extend(request, params)) }
      return self.parse_orders(response, market, since, limit)
    end

    async def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      request = {
        'status' => 'done'
      }
      market = nil
      if symbol != nil
        market = self.market(symbol)
        request['product_id'] = market['id']
      end
      response = await{ self.privateGetOrders(self.shallow_extend(request, params)) }
      return self.parse_orders(response, market, since, limit)
    end

    async def create_order(symbol, type, side, amount, price = nil, params = {})
      await{ self.load_markets }
      # oid = self.nonce.to_s
      order = {
        'product_id' => self.market_id(symbol),
        'side' => side,
        'size' => self.amount_to_precision(symbol, amount),
        'type' => type
      }
      if type == 'limit'
        order['price'] = self.price_to_precision(symbol, price)
      end
      response = await{ self.privatePostOrders(self.shallow_extend(order, params)) }
      return self.parse_order(response)
    end

    async def cancel_order(id, symbol = nil, params = {})
      await{ self.load_markets }
      return await{ self.privateDeleteOrdersId({ 'id' => id }) }
    end

    async def cancel_all_orders(symbol = nil, params = {})
      return await{ self.privateDeleteOrders(params) }
    end

    def calculate_fee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {})
      market = self.markets[symbol]
      rate = market[takerOrMaker]
      cost = amount * price
      currency = market['quote']
      return {
        'type' => takerOrMaker,
        'currency' => currency,
        'rate' => rate,
        'cost' => self.currency_to_precision(currency, rate * cost.to_f)
      }
    end

    async def get_payment_methods
      response = await{ self.privateGetPaymentMethods }
      return response
    end

    async def deposit(code, amount, address, params = {})
      await{ self.load_markets }
      currency = self.currency(code)
      request = {
        'currency' => currency['id'],
        'amount' => amount
      }
      method = 'privatePostDeposits'
      if params.include?('payment_method_id')
        # deposit from a payment_method, like a bank account
        method += 'PaymentMethod'
      elsif params.include?('coinbase_account_id')
        # deposit into GDAX account from a Coinbase account
        method += 'CoinbaseAccount'
      else
        # deposit methodotherwise we did not receive a supported deposit location
        # relevant docs link for the Googlers
        # https://docs.gdax.com/#deposits
        raise(NotSupported, self.id + ' deposit requires one of `coinbase_account_id` or `payment_method_id` extra params')
      end
      response = await{ self.send_wrapper(method, self.shallow_extend(request, params)) }
      if !response
        raise(ExchangeError, self.id + ' deposit error => ' + self.json(response))
      end
      return {
        'info' => response,
        'id' => response['id']
      }
    end

    async def withdraw(code, amount, address, tag = nil, params = {})
      self.check_address(address)
      currency = self.currency(code)
      await{ self.load_markets }
      request = {
        'currency' => currency['id'],
        'amount' => amount
      }
      method = 'privatePostWithdrawals'
      if params.include?('payment_method_id')
        method += 'PaymentMethod'
      elsif params.include?('coinbase_account_id')
        method += 'CoinbaseAccount'
      else
        method += 'Crypto'
        request['crypto_address'] = address
      end
      response = await{ self.send_wrapper(method, self.shallow_extend(request, params)) }
      if !response
        raise(ExchangeError, self.id + ' withdraw error => ' + self.json(response))
      end
      return {
        'info' => response,
        'id' => response['id']
      }
    end

    async def fetch_transactions(code = nil, since = nil, limit = nil, params = {})
      await{ self.load_markets }
      await{ self.loadAccounts }
      currency = nil
      id = self.safe_string(params, 'id') # account id
      if id.nil?
        if code.nil?
          raise(ArgumentsRequired, self.id + ' fetchTransactions requires a currency code argument if no account id specified in params')
        end
        currency = self.currency(code)
        accountsByCurrencyCode = self.index_by(self.accounts, 'currency')
        account = self.safe_value(accountsByCurrencyCode, code)
        if account.nil?
          raise(ExchangeError, self.id + ' fetchTransactions could not find account id for ' + code)
        end
        id = account['id']
      end
      request = {
        'id' => id
      }
      if limit != nil
        request['limit'] = limit
      end
      response = await{ self.privateGetAccountsIdTransfers(self.shallow_extend(request, params)) }
      for i in (0...response.length)
        response[i]['currency'] = code
      end
      return self.parseTransactions(response, currency, since, limit)
    end

    def parse_transaction_status(transaction)
      if transaction && transaction['canceled_at'].include?('canceled_at')
        return 'canceled'
      elsif transaction && transaction['completed_at'].include?('completed_at')
        return 'ok'
      elsif transaction.include?((('canceled_at')) && !transaction['canceled_at']) && (transaction.include?(('completed_at')) && !transaction['completed_at']) && (transaction.include?(('processed_at')) && !transaction['processed_at'])
        return 'pending'
      elsif transaction && transaction['processed_at'].include?('processed_at')
        return 'pending'
      else
        return 'failed'
      end
    end

    def parse_transaction(transaction, currency = nil)
      details = self.safe_value(transaction, 'details', {})
      id = self.safe_string(transaction, 'id')
      txid = self.safe_string(details, 'crypto_transaction_hash')
      timestamp = self.parse8601(self.safe_string(transaction, 'created_at'))
      updated = self.parse8601(self.safe_string(transaction, 'processed_at'))
      code = nil
      currencyId = self.safe_string(transaction, 'currency')
      if self.currencies_by_id.include?(currencyId)
        currency = self.currencies_by_id[currencyId]
        code = currency['code']
      else
        code = self.common_currency_code(currencyId)
      end
      fee = nil
      status = self.parse_transaction_status(transaction)
      amount = self.safe_float(transaction, 'amount')
      type = self.safe_string(transaction, 'type')
      address = self.safe_string(details, 'crypto_address')
      tag = self.safe_string(details, 'destination_tag')
      address = self.safe_string(transaction, 'crypto_address', address)
      if type == 'withdraw'
        type = 'withdrawal'
        address = self.safe_string(details, 'sent_to_address', address)
      end
      return {
        'info' => transaction,
        'id' => id,
        'txid' => txid,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'address' => address,
        'tag' => tag,
        'type' => type,
        'amount' => amount,
        'currency' => code,
        'status' => status,
        'updated' => updated,
        'fee' => fee
      }
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      request = '/' + self.implode_params(path, params)
      query = self.omit(params, self.extract_params(path))
      if method == 'GET'
        if query
          request += '?' + self.urlencode(query)
        end
      end
      url = self.urls['api'] + request
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce.to_s
        payload = ''
        if method != 'GET'
          if query
            body = self.json(query)
            payload = body
          end
        end
        # payload = (body) ? body : ''
        what = nonce + method + request + payload
        secret = Base64.decode64(self.secret)
        signature = self.hmac(self.encode(what), secret, 'sha256', 'base64')
        headers = {
          'CB-ACCESS-KEY' => self.apiKey,
          'CB-ACCESS-SIGN' => self.decode(signature),
          'CB-ACCESS-TIMESTAMP' => nonce,
          'CB-ACCESS-PASSPHRASE' => self.password,
          'Content-Type' => 'application/json'
        }
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    async def fetch_deposit_address(code, params = {})
      await{ self.load_markets }
      currency = self.currency(code)
      accounts = self.safe_value(self.options, 'coinbaseAccounts')
      if accounts.nil?
        accounts = await{ self.privateGetCoinbaseAccounts }
        self.options['coinbaseAccounts'] = accounts # cache it
        self.options['coinbaseAccountsByCurrencyId'] = self.index_by(accounts, 'currency')
      end
      currencyId = currency['id']
      account = self.safe_value(self.options['coinbaseAccountsByCurrencyId'], currencyId)
      if account.nil?
        # eslint-disable-next-line quotes
        raise(InvalidAddress, self.id + " fetchDepositAddress could not find currency code " + code + " with id = " + currencyId + " in self.options['coinbaseAccountsByCurrencyId']")
      end
      response = await{ self.privatePostCoinbaseAccountsIdAddresses(self.shallow_extend({
        'id' => account['id']
      }, params)) }
      address = self.safe_string(response, 'address')
      tag = self.safe_string(response, 'destination_tag')
      return {
        'currency' => code,
        'address' => self.check_address(address),
        'tag' => tag,
        'info' => response
      }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if (code == 400) || (code == 404)
        if body[0] == '{'
          message = response['message']
          feedback = self.id + ' ' + message
          exact = self.exceptions['exact']
          if exact.include?(message)
            raise(exact[message], feedback)
          end
          broad = self.exceptions['broad']
          broadKey = self.findBroadlyMatchedKey(broad, message)
          if broadKey != nil
            raise(broad[broadKey], feedback)
          end
          raise(ExchangeError, feedback) # unknown message
        end
        raise(ExchangeError, self.id + ' ' + body)
      end
    end

    async def request(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      response = await{ self.fetch2(path, api, method, params, headers, body) }
      if response.include?('message')
        raise(ExchangeError, self.id + ' ' + self.json(response))
      end
      return response
    end
  end
end
