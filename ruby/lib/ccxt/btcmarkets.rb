# -*- coding: utf-8 -*-
# frozen_string_literal: true

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

module Ccxt
  class Btcmarkets < Exchange
    def describe
      return self.deep_extend(super, {
        'id' => 'btcmarkets',
        'name' => 'BTC Markets',
        'countries' => ['AU'], # Australia
        'rateLimit' => 1000, # market data cached for 1 second(trades cached for 2 seconds)
        'has' => {
          'CORS' => false,
          'fetchOHLCV' => true,
          'fetchOrder' => true,
          'fetchOrders' => true,
          'fetchClosedOrders' => 'emulated',
          'fetchOpenOrders' => true,
          'fetchMyTrades' => true,
          'cancelOrders' => true
        },
        'urls' => {
          'logo' => 'https://user-images.githubusercontent.com/1294454/29142911-0e1acfc2-7d5c-11e7-98c4-07d9532b29d7.jpg',
          'api' => {
            'public' => 'https://api.btcmarkets.net',
            'private' => 'https://api.btcmarkets.net',
            'web' => 'https://btcmarkets.net/data'
          },
          'www' => 'https://btcmarkets.net',
          'doc' => 'https://github.com/BTCMarkets/API'
        },
        'api' => {
          'public' => {
            'get' => [
              'market/{id}/tick',
              'market/{id}/orderbook',
              'market/{id}/trades',
              'v2/market/{id}/tickByTime/{timeframe}',
              'v2/market/{id}/trades',
              'v2/market/active'
            ]
          },
          'private' => {
            'get' => [
              'account/balance',
              'account/{id}/tradingfee',
              'v2/order/open',
              'v2/order/open/{id}',
              'v2/order/history/{id}',
              'v2/order/trade/history/{id}',
              'v2/transaction/history/{currency}'
            ],
            'post' => [
              'fundtransfer/withdrawCrypto',
              'fundtransfer/withdrawEFT',
              'order/create',
              'order/cancel',
              'order/history',
              'order/open',
              'order/trade/history',
              'order/createBatch', # they promise it's coming soon...
              'order/detail'
            ]
          },
          'web' => {
            'get' => [
              'market/BTCMarkets/{id}/tickByTime'
            ]
          }
        },
        'timeframes' => {
          '1m' => 'minute',
          '1h' => 'hour',
          '1d' => 'day'
        },
        'exceptions' => {
          '3' => InvalidOrder,
          '6' => DDoSProtection
        }
      })
    end

    def fetch_markets(params = {})
      response = self.publicGetV2MarketActive
      result = []
      markets = response['markets']
      for i in (0...markets.length)
        market = markets[i]
        baseId = market['instrument']
        quoteId = market['currency']
        id = baseId + '/' + quoteId
        base = self.common_currency_code(baseId)
        quote = self.common_currency_code(quoteId)
        symbol = base + '/' + quote
        fee = (quote == 'AUD') ? 0.0085 : 0.0022
        pricePrecision = 2
        amountPrecision = 4
        minAmount = 0.001 # where does it come from?
        minPrice = nil
        if quote == 'AUD'
          if (base == 'XRP') || (base == 'OMG')
            pricePrecision = 4
          end
          amountPrecision = -Math.log10(minAmount)
          minPrice = 10**-pricePrecision
        end
        precision = {
          'amount' => amountPrecision,
          'price' => pricePrecision
        }
        limits = {
          'amount' => {
            'min' => minAmount,
            'max' => nil
          },
          'price' => {
            'min' => minPrice,
            'max' => nil
          },
          'cost' => {
            'min' => nil,
            'max' => nil
          }
        }
        result.push({
          'info' => market,
          'id' => id,
          'symbol' => symbol,
          'base' => base,
          'quote' => quote,
          'baseId' => baseId,
          'quoteId' => quoteId,
          'maker' => fee,
          'taker' => fee,
          'limits' => limits,
          'precision' => precision
        })
      end
      return result
    end

    def fetch_balance(params = {})
      self.load_markets
      balances = self.privateGetAccountBalance
      result = { 'info' => balances }
      for b in (0...balances.length)
        balance = balances[b]
        currency = balance['currency']
        multiplier = 100000000
        total = parse_float(balance['balance'] / multiplier)
        used = parse_float(balance['pendingFunds'] / multiplier)
        free = total - used
        account = {
          'free' => free,
          'used' => used,
          'total' => total
        }
        result[currency] = account
      end
      return self.parse_balance(result)
    end

    def parse_ohlcv(ohlcv, market = nil, timeframe = '1m', since = nil, limit = nil)
      multiplier = 100000000 # for price and volume
      return [
        ohlcv[0],
        parse_float(ohlcv[1]) / multiplier,
        parse_float(ohlcv[2]) / multiplier,
        parse_float(ohlcv[3]) / multiplier,
        parse_float(ohlcv[4]) / multiplier,
        parse_float(ohlcv[5]) / multiplier
      ]
    end

    def fetch_ohlcv(symbol, timeframe = '1m', since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      request = {
        'id' => market['id'],
        'timeWindow' => self.timeframes[timeframe]
      }
      if since != nil
        request['since'] = since
      end
      response = self.webGetMarketBTCMarketsIdTickByTime(self.shallow_extend(request, params))
      return self.parse_ohlcvs(response['ticks'], market, timeframe, since, limit)
    end

    def fetch_order_book(symbol, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      orderbook = self.publicGetMarketIdOrderbook(self.shallow_extend({
        'id' => market['id']
      }, params))
      timestamp = orderbook['timestamp'] * 1000
      return self.parse_order_book(orderbook, timestamp)
    end

    def parse_ticker(ticker, market = nil)
      timestamp = ticker['timestamp'] * 1000
      symbol = nil
      if market
        symbol = market['symbol']
      end
      last = self.safe_float(ticker, 'lastPrice')
      return {
        'symbol' => symbol,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'high' => nil,
        'low' => nil,
        'bid' => self.safe_float(ticker, 'bestBid'),
        'bidVolume' => nil,
        'ask' => self.safe_float(ticker, 'bestAsk'),
        'askVolume' => nil,
        'vwap' => nil,
        'open' => nil,
        'close' => last,
        'last' => last,
        'previousClose' => nil,
        'change' => nil,
        'percentage' => nil,
        'average' => nil,
        'baseVolume' => self.safe_float(ticker, 'volume24h'),
        'quoteVolume' => nil,
        'info' => ticker
      }
    end

    def fetch_ticker(symbol, params = {})
      self.load_markets
      market = self.market(symbol)
      ticker = self.publicGetMarketIdTick(self.shallow_extend({
        'id' => market['id']
      }, params))
      return self.parse_ticker(ticker, market)
    end

    def parse_trade(trade, market)
      timestamp = trade['date'] * 1000
      return {
        'info' => trade,
        'id' => trade['tid'].to_s,
        'order' => nil,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => nil,
        'price' => trade['price'],
        'amount' => trade['amount']
      }
    end

    def fetch_trades(symbol, since = nil, limit = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      response = self.publicGetMarketIdTrades(self.shallow_extend({
        # 'since' => 59868345231,
        'id' => market['id']
      }, params))
      return self.parse_trades(response, market, since, limit)
    end

    def create_order(symbol, type, side, amount, price = nil, params = {})
      self.load_markets
      market = self.market(symbol)
      multiplier = 100000000 # for price and volume
      orderSide = (side == 'buy') ? 'Bid' : 'Ask'
      order = self.ordered({
        'currency' => market['quote']
      })
      order['currency'] = market['quote']
      order['instrument'] = market['base']
      order['price'] = parse_int(price * multiplier)
      order['volume'] = parse_int(amount * multiplier)
      order['orderSide'] = orderSide
      order['ordertype'] = self.capitalize(type)
      order['clientRequestId'] = self.nonce.to_s
      response = self.privatePostOrderCreate(order)
      return {
        'info' => response,
        'id' => response['id'].to_s
      }
    end

    def cancel_orders(ids, symbol = nil, params = {})
      self.load_markets
      for i in (0...ids.length)
        ids[i] = parse_int(ids[i])
      end
      return self.privatePostOrderCancel({ 'orderIds' => ids })
    end

    def cancel_order(id, symbol = nil, params = {})
      self.load_markets
      return self.cancel_orders([id])
    end

    def calculate_fee(symbol, type, side, amount, price, takerOrMaker = 'taker', params = {})
      market = self.markets[symbol]
      rate = market[takerOrMaker]
      currency = nil
      cost = nil
      if market['quote'] == 'AUD'
        currency = market['quote']
        cost = parse_float(self.cost_to_precision(symbol, amount * price))
      else
        currency = market['base']
        cost = parse_float(self.amount_to_precision(symbol, amount))
      end
      return {
        'type' => takerOrMaker,
        'currency' => currency,
        'rate' => rate,
        'cost' => parse_float(self.fee_to_precision(symbol, rate * cost))
      }
    end

    def parse_my_trade(trade, market)
      multiplier = 100000000
      timestamp = trade['creationTime']
      side = (trade['side'] == 'Bid') ? 'buy' : 'sell'
      # BTCMarkets always charge in AUD for AUD-related transactions.
      currency = (market['quote'] == 'AUD') ? market['quote'] : market['base']
      return {
        'info' => trade,
        'id' => trade['id'].to_s,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'symbol' => market['symbol'],
        'type' => nil,
        'side' => side,
        'price' => trade['price'] / multiplier,
        'fee' => {
          'currency' => currency,
          'cost' => trade['fee'] / multiplier
        },
        'amount' => trade['volume'] / multiplier,
        'order' => self.safe_string(trade, 'orderId')
      }
    end

    def parse_my_trades(trades, market = nil, since = nil, limit = nil)
      result = []
      for i in (0...trades.length)
        trade = self.parse_my_trade(trades[i], market)
        result.push(trade)
      end
      return result
    end

    def parse_order(order, market = nil)
      multiplier = 100000000
      side = (order['orderSide'] == 'Bid') ? 'buy' : 'sell'
      type = (order['ordertype'] == 'Limit') ? 'limit' : 'market'
      timestamp = order['creationTime']
      if market.nil?
        market = self.market(order['instrument'] + '/' + order['currency'])
      end
      status = 'open'
      if order['status'] == 'Failed' || order['status'] == 'Cancelled' || order['status'] == 'Partially Cancelled' || order['status'] == 'Error'
        status = 'canceled'
      elsif order['status'] == 'Fully Matched' || order['status'] == 'Partially Matched'
        status = 'closed'
      end
      price = self.safe_float(order, 'price') / multiplier
      amount = self.safe_float(order, 'volume') / multiplier
      remaining = self.safe_float(order, 'openVolume', 0.0) / multiplier
      filled = amount - remaining
      cost = price * amount
      trades = self.parse_my_trades(order['trades'], market)
      result = {
        'info' => order,
        'id' => order['id'].to_s,
        'timestamp' => timestamp,
        'datetime' => self.iso8601(timestamp),
        'lastTradeTimestamp' => nil,
        'symbol' => market['symbol'],
        'type' => type,
        'side' => side,
        'price' => price,
        'cost' => cost,
        'amount' => amount,
        'filled' => filled,
        'remaining' => remaining,
        'status' => status,
        'trades' => trades,
        'fee' => nil
      }
      return result
    end

    def fetch_order(id, symbol = nil, params = {})
      self.load_markets
      ids = [parse_int(id)]
      response = self.privatePostOrderDetail(self.shallow_extend({
        'orderIds' => ids
      }, params))
      numOrders = response['orders'].length
      if numOrders < 1
        raise(OrderNotFound, self.id + ' No matching order found => ' + id)
      end
      order = response['orders'][0]
      return self.parse_order(order)
    end

    def prepare_history_request(market, since = nil, limit = nil)
      request = self.ordered({
        'currency' => market['quote'],
        'instrument' => market['base']
      })
      if limit != nil
        request['limit'] = limit
      else
        request['limit'] = 100
      end
      if since != nil
        request['since'] = since
      else
        request['since'] = 0
      end
      return request
    end

    def fetch_orders(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(NotSupported, self.id + ' => fetchOrders requires a `symbol` parameter.')
      end
      self.load_markets
      market = self.market(symbol)
      request = self.prepare_history_request(market, since, limit)
      response = self.privatePostOrderHistory(self.shallow_extend(request, params))
      return self.parse_orders(response['orders'], market)
    end

    def fetch_open_orders(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(NotSupported, self.id + ' => fetchOpenOrders requires a `symbol` parameter.')
      end
      self.load_markets
      market = self.market(symbol)
      request = self.prepare_history_request(market, since, limit)
      response = self.privatePostOrderOpen(self.shallow_extend(request, params))
      return self.parse_orders(response['orders'], market)
    end

    def fetch_closed_orders(symbol = nil, since = nil, limit = nil, params = {})
      orders = self.fetch_orders(symbol, since, limit, params)
      return self.filter_by(orders, 'status', 'closed')
    end

    def fetch_my_trades(symbol = nil, since = nil, limit = nil, params = {})
      if symbol.nil?
        raise(NotSupported, self.id + ' => fetchMyTrades requires a `symbol` parameter.')
      end
      self.load_markets
      market = self.market(symbol)
      request = self.prepare_history_request(market, since, limit)
      response = self.privatePostOrderTradeHistory(self.shallow_extend(request, params))
      return self.parse_my_trades(response['trades'], market)
    end

    def nonce
      return self.milliseconds
    end

    def sign(path, api = 'public', method = 'GET', params = {}, headers = nil, body = nil)
      uri = '/' + self.implode_params(path, params)
      url = self.urls['api'][api] + uri
      if api == 'private'
        self.check_required_credentials
        nonce = self.nonce.to_s
        # eslint-disable-next-line quotes
        auth = uri + "\n" + nonce + "\n"
        headers = {
          'Content-Type' => 'application/json',
          'apikey' => self.apiKey,
          'timestamp' => nonce
        }
        if method == 'POST'
          body = self.json(params)
          auth += body
        end
        secret = Base64.decode64(self.secret)
        signature = self.hmac(self.encode(auth), secret, 'sha512', 'base64')
        headers['signature'] = self.decode(signature)
      else
        if params
          url += '?' + self.urlencode(params)
        end
      end
      return { 'url' => url, 'method' => method, 'body' => body, 'headers' => headers }
    end

    def handle_errors(code, reason, url, method, headers, body, response)
      if body.length < 2
        return
      end # fallback to default error handler
      if body[0] == '{'
        if response.include?('success')
          if !response['success']
            error = self.safe_string(response, 'errorCode')
            message = self.id + ' ' + self.json(response)
            if self.exceptions.include?(error)
              exceptionClass = self.exceptions[error]
              raise(exceptionClass, message)
            else
              raise(ExchangeError, message)
            end
          end
        end
      end
    end
  end
end
